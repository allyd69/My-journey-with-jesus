/**
 * @license React
 * eslint-plugin-react-hooks.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var core$1 = require('@babel/core');
var BabelParser = require('@babel/parser');
var v4 = require('zod/v4');
var v4$1 = require('zod-validation-error/v4');
var crypto = require('crypto');
var HermesParser = require('hermes-parser');
var util = require('util');

const SETTINGS_KEY = 'react-hooks';
const SETTINGS_ADDITIONAL_EFFECT_HOOKS_KEY = 'additionalEffectHooks';
function getAdditionalEffectHooksFromSettings(settings) {
    var _a;
    const additionalHooks = (_a = settings[SETTINGS_KEY]) === null || _a === void 0 ? void 0 : _a[SETTINGS_ADDITIONAL_EFFECT_HOOKS_KEY];
    if (additionalHooks != null && typeof additionalHooks === 'string') {
        return new RegExp(additionalHooks);
    }
    return undefined;
}

const rule$1 = {
    meta: {
        type: 'suggestion',
        docs: {
            description: 'verifies the list of dependencies for Hooks like useEffect and similar',
            recommended: true,
            url: 'https://github.com/facebook/react/issues/14920',
        },
        fixable: 'code',
        hasSuggestions: true,
        schema: [
            {
                type: 'object',
                additionalProperties: false,
                enableDangerousAutofixThisMayCauseInfiniteLoops: false,
                properties: {
                    additionalHooks: {
                        type: 'string',
                    },
                    enableDangerousAutofixThisMayCauseInfiniteLoops: {
                        type: 'boolean',
                    },
                    experimental_autoDependenciesHooks: {
                        type: 'array',
                        items: {
                            type: 'string',
                        },
                    },
                    requireExplicitEffectDeps: {
                        type: 'boolean',
                    },
                },
            },
        ],
    },
    create(context) {
        const rawOptions = context.options && context.options[0];
        const settings = context.settings || {};
        const additionalHooks = rawOptions && rawOptions.additionalHooks
            ? new RegExp(rawOptions.additionalHooks)
            : getAdditionalEffectHooksFromSettings(settings);
        const enableDangerousAutofixThisMayCauseInfiniteLoops = (rawOptions &&
            rawOptions.enableDangerousAutofixThisMayCauseInfiniteLoops) ||
            false;
        const experimental_autoDependenciesHooks = rawOptions && Array.isArray(rawOptions.experimental_autoDependenciesHooks)
            ? rawOptions.experimental_autoDependenciesHooks
            : [];
        const requireExplicitEffectDeps = (rawOptions && rawOptions.requireExplicitEffectDeps) || false;
        const options = {
            additionalHooks,
            experimental_autoDependenciesHooks,
            enableDangerousAutofixThisMayCauseInfiniteLoops,
            requireExplicitEffectDeps,
        };
        function reportProblem(problem) {
            if (enableDangerousAutofixThisMayCauseInfiniteLoops) {
                if (Array.isArray(problem.suggest) &&
                    problem.suggest.length > 0 &&
                    problem.suggest[0]) {
                    problem.fix = problem.suggest[0].fix;
                }
            }
            context.report(problem);
        }
        const getSourceCode = typeof context.getSourceCode === 'function'
            ? () => {
                return context.getSourceCode();
            }
            : () => {
                return context.sourceCode;
            };
        const getScope = typeof context.getScope === 'function'
            ? () => {
                return context.getScope();
            }
            : (node) => {
                return context.sourceCode.getScope(node);
            };
        const scopeManager = getSourceCode().scopeManager;
        const setStateCallSites = new WeakMap();
        const stateVariables = new WeakSet();
        const stableKnownValueCache = new WeakMap();
        const functionWithoutCapturedValueCache = new WeakMap();
        const useEffectEventVariables = new WeakSet();
        function memoizeWithWeakMap(fn, map) {
            return function (arg) {
                if (map.has(arg)) {
                    return map.get(arg);
                }
                const result = fn(arg);
                map.set(arg, result);
                return result;
            };
        }
        function visitFunctionWithDependencies(node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect, isAutoDepsHook) {
            if (isEffect && node.async) {
                reportProblem({
                    node: node,
                    message: `Effect callbacks are synchronous to prevent race conditions. ` +
                        `Put the async function inside:\n\n` +
                        'useEffect(() => {\n' +
                        '  async function fetchData() {\n' +
                        '    // You can await here\n' +
                        '    const response = await MyAPI.getData(someId);\n' +
                        '    // ...\n' +
                        '  }\n' +
                        '  fetchData();\n' +
                        `}, [someId]); // Or [] if effect doesn't need props or state\n\n` +
                        'Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching',
                });
            }
            const scope = scopeManager.acquire(node);
            if (!scope) {
                throw new Error('Unable to acquire scope for the current node. This is a bug in eslint-plugin-react-hooks, please file an issue.');
            }
            const pureScopes = new Set();
            let componentScope = null;
            {
                let currentScope = scope.upper;
                while (currentScope) {
                    pureScopes.add(currentScope);
                    if (currentScope.type === 'function' ||
                        currentScope.type === 'hook' ||
                        currentScope.type === 'component') {
                        break;
                    }
                    currentScope = currentScope.upper;
                }
                if (!currentScope) {
                    return;
                }
                componentScope = currentScope;
            }
            const isArray = Array.isArray;
            function isStableKnownHookValue(resolved) {
                if (!isArray(resolved.defs)) {
                    return false;
                }
                const def = resolved.defs[0];
                if (def == null) {
                    return false;
                }
                const defNode = def.node;
                if (defNode.type !== 'VariableDeclarator') {
                    return false;
                }
                let init = defNode.init;
                if (init == null) {
                    return false;
                }
                while (init.type === 'TSAsExpression' || init.type === 'AsExpression') {
                    init = init.expression;
                }
                let declaration = defNode.parent;
                if (declaration == null && componentScope != null) {
                    fastFindReferenceWithParent(componentScope.block, def.node.id);
                    declaration = def.node.parent;
                    if (declaration == null) {
                        return false;
                    }
                }
                if (declaration != null &&
                    'kind' in declaration &&
                    declaration.kind === 'const' &&
                    init.type === 'Literal' &&
                    (typeof init.value === 'string' ||
                        typeof init.value === 'number' ||
                        init.value === null)) {
                    return true;
                }
                if (init.type !== 'CallExpression') {
                    return false;
                }
                let callee = init.callee;
                if (callee.type === 'MemberExpression' &&
                    'name' in callee.object &&
                    callee.object.name === 'React' &&
                    callee.property != null &&
                    !callee.computed) {
                    callee = callee.property;
                }
                if (callee.type !== 'Identifier') {
                    return false;
                }
                const definitionNode = def.node;
                const id = definitionNode.id;
                const { name } = callee;
                if (name === 'useRef' && id.type === 'Identifier') {
                    return true;
                }
                else if (isUseEffectEventIdentifier$1(callee) &&
                    id.type === 'Identifier') {
                    for (const ref of resolved.references) {
                        if (ref !== id) {
                            useEffectEventVariables.add(ref.identifier);
                        }
                    }
                    return true;
                }
                else if (name === 'useState' ||
                    name === 'useReducer' ||
                    name === 'useActionState') {
                    if (id.type === 'ArrayPattern' &&
                        id.elements.length === 2 &&
                        isArray(resolved.identifiers)) {
                        if (id.elements[1] === resolved.identifiers[0]) {
                            if (name === 'useState') {
                                const references = resolved.references;
                                let writeCount = 0;
                                for (const reference of references) {
                                    if (reference.isWrite()) {
                                        writeCount++;
                                    }
                                    if (writeCount > 1) {
                                        return false;
                                    }
                                    setStateCallSites.set(reference.identifier, id.elements[0]);
                                }
                            }
                            return true;
                        }
                        else if (id.elements[0] === resolved.identifiers[0]) {
                            if (name === 'useState') {
                                const references = resolved.references;
                                for (const reference of references) {
                                    stateVariables.add(reference.identifier);
                                }
                            }
                            return false;
                        }
                    }
                }
                else if (name === 'useTransition') {
                    if (id.type === 'ArrayPattern' &&
                        id.elements.length === 2 &&
                        Array.isArray(resolved.identifiers)) {
                        if (id.elements[1] === resolved.identifiers[0]) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function isFunctionWithoutCapturedValues(resolved) {
                if (!isArray(resolved.defs)) {
                    return false;
                }
                const def = resolved.defs[0];
                if (def == null) {
                    return false;
                }
                if (def.node == null || def.node.id == null) {
                    return false;
                }
                const fnNode = def.node;
                const childScopes = (componentScope === null || componentScope === void 0 ? void 0 : componentScope.childScopes) || [];
                let fnScope = null;
                for (const childScope of childScopes) {
                    const childScopeBlock = childScope.block;
                    if ((fnNode.type === 'FunctionDeclaration' &&
                        childScopeBlock === fnNode) ||
                        (fnNode.type === 'VariableDeclarator' &&
                            childScopeBlock.parent === fnNode)) {
                        fnScope = childScope;
                        break;
                    }
                }
                if (fnScope == null) {
                    return false;
                }
                for (const ref of fnScope.through) {
                    if (ref.resolved == null) {
                        continue;
                    }
                    if (pureScopes.has(ref.resolved.scope) &&
                        !memoizedIsStableKnownHookValue(ref.resolved)) {
                        return false;
                    }
                }
                return true;
            }
            const memoizedIsStableKnownHookValue = memoizeWithWeakMap(isStableKnownHookValue, stableKnownValueCache);
            const memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(isFunctionWithoutCapturedValues, functionWithoutCapturedValueCache);
            const currentRefsInEffectCleanup = new Map();
            function isInsideEffectCleanup(reference) {
                let curScope = reference.from;
                let isInReturnedFunction = false;
                while (curScope != null && curScope.block !== node) {
                    if (curScope.type === 'function') {
                        isInReturnedFunction =
                            curScope.block.parent != null &&
                                curScope.block.parent.type === 'ReturnStatement';
                    }
                    curScope = curScope.upper;
                }
                return isInReturnedFunction;
            }
            const dependencies = new Map();
            const optionalChains = new Map();
            gatherDependenciesRecursively(scope);
            function gatherDependenciesRecursively(currentScope) {
                var _a, _b, _c, _d, _e;
                for (const reference of currentScope.references) {
                    if (!reference.resolved) {
                        continue;
                    }
                    if (!pureScopes.has(reference.resolved.scope)) {
                        continue;
                    }
                    const referenceNode = fastFindReferenceWithParent(node, reference.identifier);
                    if (referenceNode == null) {
                        continue;
                    }
                    const dependencyNode = getDependency(referenceNode);
                    const dependency = analyzePropertyChain(dependencyNode, optionalChains);
                    if (isEffect &&
                        dependencyNode.type === 'Identifier' &&
                        (((_a = dependencyNode.parent) === null || _a === void 0 ? void 0 : _a.type) === 'MemberExpression' ||
                            ((_b = dependencyNode.parent) === null || _b === void 0 ? void 0 : _b.type) === 'OptionalMemberExpression') &&
                        !dependencyNode.parent.computed &&
                        dependencyNode.parent.property.type === 'Identifier' &&
                        dependencyNode.parent.property.name === 'current' &&
                        isInsideEffectCleanup(reference)) {
                        currentRefsInEffectCleanup.set(dependency, {
                            reference,
                            dependencyNode,
                        });
                    }
                    if (((_c = dependencyNode.parent) === null || _c === void 0 ? void 0 : _c.type) === 'TSTypeQuery' ||
                        ((_d = dependencyNode.parent) === null || _d === void 0 ? void 0 : _d.type) === 'TSTypeReference') {
                        continue;
                    }
                    const def = reference.resolved.defs[0];
                    if (def == null) {
                        continue;
                    }
                    if (def.node != null && def.node.init === node.parent) {
                        continue;
                    }
                    if (def.type === 'TypeParameter') {
                        continue;
                    }
                    if (!dependencies.has(dependency)) {
                        const resolved = reference.resolved;
                        const isStable = memoizedIsStableKnownHookValue(resolved) ||
                            memoizedIsFunctionWithoutCapturedValues(resolved);
                        dependencies.set(dependency, {
                            isStable,
                            references: [reference],
                        });
                    }
                    else {
                        (_e = dependencies.get(dependency)) === null || _e === void 0 ? void 0 : _e.references.push(reference);
                    }
                }
                for (const childScope of currentScope.childScopes) {
                    gatherDependenciesRecursively(childScope);
                }
            }
            currentRefsInEffectCleanup.forEach(({ reference, dependencyNode }, dependency) => {
                var _a, _b;
                const references = ((_a = reference.resolved) === null || _a === void 0 ? void 0 : _a.references) || [];
                let foundCurrentAssignment = false;
                for (const ref of references) {
                    const { identifier } = ref;
                    const { parent } = identifier;
                    if (parent != null &&
                        parent.type === 'MemberExpression' &&
                        !parent.computed &&
                        parent.property.type === 'Identifier' &&
                        parent.property.name === 'current' &&
                        ((_b = parent.parent) === null || _b === void 0 ? void 0 : _b.type) === 'AssignmentExpression' &&
                        parent.parent.left === parent) {
                        foundCurrentAssignment = true;
                        break;
                    }
                }
                if (foundCurrentAssignment) {
                    return;
                }
                reportProblem({
                    node: dependencyNode.parent.property,
                    message: `The ref value '${dependency}.current' will likely have ` +
                        `changed by the time this effect cleanup function runs. If ` +
                        `this ref points to a node rendered by React, copy ` +
                        `'${dependency}.current' to a variable inside the effect, and ` +
                        `use that variable in the cleanup function.`,
                });
            });
            const staleAssignments = new Set();
            function reportStaleAssignment(writeExpr, key) {
                if (staleAssignments.has(key)) {
                    return;
                }
                staleAssignments.add(key);
                reportProblem({
                    node: writeExpr,
                    message: `Assignments to the '${key}' variable from inside React Hook ` +
                        `${getSourceCode().getText(reactiveHook)} will be lost after each ` +
                        `render. To preserve the value over time, store it in a useRef ` +
                        `Hook and keep the mutable value in the '.current' property. ` +
                        `Otherwise, you can move this variable directly inside ` +
                        `${getSourceCode().getText(reactiveHook)}.`,
                });
            }
            const stableDependencies = new Set();
            dependencies.forEach(({ isStable, references }, key) => {
                if (isStable) {
                    stableDependencies.add(key);
                }
                references.forEach(reference => {
                    if (reference.writeExpr) {
                        reportStaleAssignment(reference.writeExpr, key);
                    }
                });
            });
            if (staleAssignments.size > 0) {
                return;
            }
            if (!declaredDependenciesNode) {
                if (isAutoDepsHook) {
                    return;
                }
                let setStateInsideEffectWithoutDeps = null;
                dependencies.forEach(({ references }, key) => {
                    if (setStateInsideEffectWithoutDeps) {
                        return;
                    }
                    references.forEach(reference => {
                        if (setStateInsideEffectWithoutDeps) {
                            return;
                        }
                        const id = reference.identifier;
                        const isSetState = setStateCallSites.has(id);
                        if (!isSetState) {
                            return;
                        }
                        let fnScope = reference.from;
                        while (fnScope != null && fnScope.type !== 'function') {
                            fnScope = fnScope.upper;
                        }
                        const isDirectlyInsideEffect = (fnScope === null || fnScope === void 0 ? void 0 : fnScope.block) === node;
                        if (isDirectlyInsideEffect) {
                            setStateInsideEffectWithoutDeps = key;
                        }
                    });
                });
                if (setStateInsideEffectWithoutDeps) {
                    const { suggestedDependencies } = collectRecommendations({
                        dependencies,
                        declaredDependencies: [],
                        stableDependencies,
                        externalDependencies: new Set(),
                        isEffect: true,
                    });
                    reportProblem({
                        node: reactiveHook,
                        message: `React Hook ${reactiveHookName} contains a call to '${setStateInsideEffectWithoutDeps}'. ` +
                            `Without a list of dependencies, this can lead to an infinite chain of updates. ` +
                            `To fix this, pass [` +
                            suggestedDependencies.join(', ') +
                            `] as a second argument to the ${reactiveHookName} Hook.`,
                        suggest: [
                            {
                                desc: `Add dependencies array: [${suggestedDependencies.join(', ')}]`,
                                fix(fixer) {
                                    return fixer.insertTextAfter(node, `, [${suggestedDependencies.join(', ')}]`);
                                },
                            },
                        ],
                    });
                }
                return;
            }
            if (isAutoDepsHook &&
                declaredDependenciesNode.type === 'Literal' &&
                declaredDependenciesNode.value === null) {
                return;
            }
            const declaredDependencies = [];
            const externalDependencies = new Set();
            const isArrayExpression = declaredDependenciesNode.type === 'ArrayExpression';
            const isTSAsArrayExpression = declaredDependenciesNode.type === 'TSAsExpression' &&
                declaredDependenciesNode.expression.type === 'ArrayExpression';
            if (!isArrayExpression && !isTSAsArrayExpression) {
                reportProblem({
                    node: declaredDependenciesNode,
                    message: `React Hook ${getSourceCode().getText(reactiveHook)} was passed a ` +
                        'dependency list that is not an array literal. This means we ' +
                        "can't statically verify whether you've passed the correct " +
                        'dependencies.',
                });
            }
            else {
                const arrayExpression = isTSAsArrayExpression
                    ? declaredDependenciesNode.expression
                    : declaredDependenciesNode;
                arrayExpression.elements.forEach(declaredDependencyNode => {
                    if (declaredDependencyNode === null) {
                        return;
                    }
                    if (declaredDependencyNode.type === 'SpreadElement') {
                        reportProblem({
                            node: declaredDependencyNode,
                            message: `React Hook ${getSourceCode().getText(reactiveHook)} has a spread ` +
                                "element in its dependency array. This means we can't " +
                                "statically verify whether you've passed the " +
                                'correct dependencies.',
                        });
                        return;
                    }
                    if (useEffectEventVariables.has(declaredDependencyNode)) {
                        reportProblem({
                            node: declaredDependencyNode,
                            message: 'Functions returned from `useEffectEvent` must not be included in the dependency array. ' +
                                `Remove \`${getSourceCode().getText(declaredDependencyNode)}\` from the list.`,
                            suggest: [
                                {
                                    desc: `Remove the dependency \`${getSourceCode().getText(declaredDependencyNode)}\``,
                                    fix(fixer) {
                                        return fixer.removeRange(declaredDependencyNode.range);
                                    },
                                },
                            ],
                        });
                    }
                    let declaredDependency;
                    try {
                        declaredDependency = analyzePropertyChain(declaredDependencyNode, null);
                    }
                    catch (error) {
                        if (error instanceof Error &&
                            /Unsupported node type/.test(error.message)) {
                            if (declaredDependencyNode.type === 'Literal') {
                                if (declaredDependencyNode.value &&
                                    dependencies.has(declaredDependencyNode.value)) {
                                    reportProblem({
                                        node: declaredDependencyNode,
                                        message: `The ${declaredDependencyNode.raw} literal is not a valid dependency ` +
                                            `because it never changes. ` +
                                            `Did you mean to include ${declaredDependencyNode.value} in the array instead?`,
                                    });
                                }
                                else {
                                    reportProblem({
                                        node: declaredDependencyNode,
                                        message: `The ${declaredDependencyNode.raw} literal is not a valid dependency ` +
                                            'because it never changes. You can safely remove it.',
                                    });
                                }
                            }
                            else {
                                reportProblem({
                                    node: declaredDependencyNode,
                                    message: `React Hook ${getSourceCode().getText(reactiveHook)} has a ` +
                                        `complex expression in the dependency array. ` +
                                        'Extract it to a separate variable so it can be statically checked.',
                                });
                            }
                            return;
                        }
                        else {
                            throw error;
                        }
                    }
                    let maybeID = declaredDependencyNode;
                    while (maybeID.type === 'MemberExpression' ||
                        maybeID.type === 'OptionalMemberExpression' ||
                        maybeID.type === 'ChainExpression') {
                        maybeID = maybeID.object || maybeID.expression.object;
                    }
                    const isDeclaredInComponent = !componentScope.through.some(ref => ref.identifier === maybeID);
                    declaredDependencies.push({
                        key: declaredDependency,
                        node: declaredDependencyNode,
                    });
                    if (!isDeclaredInComponent) {
                        externalDependencies.add(declaredDependency);
                    }
                });
            }
            const { suggestedDependencies, unnecessaryDependencies, missingDependencies, duplicateDependencies, } = collectRecommendations({
                dependencies,
                declaredDependencies,
                stableDependencies,
                externalDependencies,
                isEffect,
            });
            let suggestedDeps = suggestedDependencies;
            const problemCount = duplicateDependencies.size +
                missingDependencies.size +
                unnecessaryDependencies.size;
            if (problemCount === 0) {
                const constructions = scanForConstructions({
                    declaredDependencies,
                    declaredDependenciesNode,
                    componentScope,
                    scope,
                });
                constructions.forEach(({ construction, isUsedOutsideOfHook, depType }) => {
                    var _a;
                    const wrapperHook = depType === 'function' ? 'useCallback' : 'useMemo';
                    const constructionType = depType === 'function' ? 'definition' : 'initialization';
                    const defaultAdvice = `wrap the ${constructionType} of '${construction.name.name}' in its own ${wrapperHook}() Hook.`;
                    const advice = isUsedOutsideOfHook
                        ? `To fix this, ${defaultAdvice}`
                        : `Move it inside the ${reactiveHookName} callback. Alternatively, ${defaultAdvice}`;
                    const causation = depType === 'conditional' || depType === 'logical expression'
                        ? 'could make'
                        : 'makes';
                    const message = `The '${construction.name.name}' ${depType} ${causation} the dependencies of ` +
                        `${reactiveHookName} Hook (at line ${(_a = declaredDependenciesNode.loc) === null || _a === void 0 ? void 0 : _a.start.line}) ` +
                        `change on every render. ${advice}`;
                    let suggest;
                    if (isUsedOutsideOfHook &&
                        construction.type === 'Variable' &&
                        depType === 'function') {
                        suggest = [
                            {
                                desc: `Wrap the ${constructionType} of '${construction.name.name}' in its own ${wrapperHook}() Hook.`,
                                fix(fixer) {
                                    const [before, after] = wrapperHook === 'useMemo'
                                        ? [`useMemo(() => { return `, '; })']
                                        : ['useCallback(', ')'];
                                    return [
                                        fixer.insertTextBefore(construction.node.init, before),
                                        fixer.insertTextAfter(construction.node.init, after),
                                    ];
                                },
                            },
                        ];
                    }
                    reportProblem({
                        node: construction.node,
                        message,
                        suggest,
                    });
                });
                return;
            }
            if (!isEffect && missingDependencies.size > 0) {
                suggestedDeps = collectRecommendations({
                    dependencies,
                    declaredDependencies: [],
                    stableDependencies,
                    externalDependencies,
                    isEffect,
                }).suggestedDependencies;
            }
            function areDeclaredDepsAlphabetized() {
                if (declaredDependencies.length === 0) {
                    return true;
                }
                const declaredDepKeys = declaredDependencies.map(dep => dep.key);
                const sortedDeclaredDepKeys = declaredDepKeys.slice().sort();
                return declaredDepKeys.join(',') === sortedDeclaredDepKeys.join(',');
            }
            if (areDeclaredDepsAlphabetized()) {
                suggestedDeps.sort();
            }
            function formatDependency(path) {
                const members = path.split('.');
                let finalPath = '';
                for (let i = 0; i < members.length; i++) {
                    if (i !== 0) {
                        const pathSoFar = members.slice(0, i + 1).join('.');
                        const isOptional = optionalChains.get(pathSoFar) === true;
                        finalPath += isOptional ? '?.' : '.';
                    }
                    finalPath += members[i];
                }
                return finalPath;
            }
            function getWarningMessage(deps, singlePrefix, label, fixVerb) {
                if (deps.size === 0) {
                    return null;
                }
                return ((deps.size > 1 ? '' : singlePrefix + ' ') +
                    label +
                    ' ' +
                    (deps.size > 1 ? 'dependencies' : 'dependency') +
                    ': ' +
                    joinEnglish(Array.from(deps)
                        .sort()
                        .map(name => "'" + formatDependency(name) + "'")) +
                    `. Either ${fixVerb} ${deps.size > 1 ? 'them' : 'it'} or remove the dependency array.`);
            }
            let extraWarning = '';
            if (unnecessaryDependencies.size > 0) {
                let badRef = null;
                Array.from(unnecessaryDependencies.keys()).forEach(key => {
                    if (badRef !== null) {
                        return;
                    }
                    if (key.endsWith('.current')) {
                        badRef = key;
                    }
                });
                if (badRef !== null) {
                    extraWarning =
                        ` Mutable values like '${badRef}' aren't valid dependencies ` +
                            "because mutating them doesn't re-render the component.";
                }
                else if (externalDependencies.size > 0) {
                    const dep = Array.from(externalDependencies)[0];
                    if (!scope.set.has(dep)) {
                        extraWarning =
                            ` Outer scope values like '${dep}' aren't valid dependencies ` +
                                `because mutating them doesn't re-render the component.`;
                    }
                }
            }
            if (!extraWarning && missingDependencies.has('props')) {
                const propDep = dependencies.get('props');
                if (propDep == null) {
                    return;
                }
                const refs = propDep.references;
                if (!Array.isArray(refs)) {
                    return;
                }
                let isPropsOnlyUsedInMembers = true;
                for (const ref of refs) {
                    const id = fastFindReferenceWithParent(componentScope.block, ref.identifier);
                    if (!id) {
                        isPropsOnlyUsedInMembers = false;
                        break;
                    }
                    const parent = id.parent;
                    if (parent == null) {
                        isPropsOnlyUsedInMembers = false;
                        break;
                    }
                    if (parent.type !== 'MemberExpression' &&
                        parent.type !== 'OptionalMemberExpression') {
                        isPropsOnlyUsedInMembers = false;
                        break;
                    }
                }
                if (isPropsOnlyUsedInMembers) {
                    extraWarning =
                        ` However, 'props' will change when *any* prop changes, so the ` +
                            `preferred fix is to destructure the 'props' object outside of ` +
                            `the ${reactiveHookName} call and refer to those specific props ` +
                            `inside ${getSourceCode().getText(reactiveHook)}.`;
                }
            }
            if (!extraWarning && missingDependencies.size > 0) {
                let missingCallbackDep = null;
                missingDependencies.forEach(missingDep => {
                    var _a;
                    if (missingCallbackDep) {
                        return;
                    }
                    const topScopeRef = componentScope.set.get(missingDep);
                    const usedDep = dependencies.get(missingDep);
                    if (!(usedDep === null || usedDep === void 0 ? void 0 : usedDep.references) ||
                        ((_a = usedDep === null || usedDep === void 0 ? void 0 : usedDep.references[0]) === null || _a === void 0 ? void 0 : _a.resolved) !== topScopeRef) {
                        return;
                    }
                    const def = topScopeRef === null || topScopeRef === void 0 ? void 0 : topScopeRef.defs[0];
                    if (def == null || def.name == null || def.type !== 'Parameter') {
                        return;
                    }
                    let isFunctionCall = false;
                    let id;
                    for (const reference of usedDep.references) {
                        id = reference.identifier;
                        if (id != null &&
                            id.parent != null &&
                            (id.parent.type === 'CallExpression' ||
                                id.parent.type === 'OptionalCallExpression') &&
                            id.parent.callee === id) {
                            isFunctionCall = true;
                            break;
                        }
                    }
                    if (!isFunctionCall) {
                        return;
                    }
                    missingCallbackDep = missingDep;
                });
                if (missingCallbackDep !== null) {
                    extraWarning =
                        ` If '${missingCallbackDep}' changes too often, ` +
                            `find the parent component that defines it ` +
                            `and wrap that definition in useCallback.`;
                }
            }
            if (!extraWarning && missingDependencies.size > 0) {
                let setStateRecommendation = null;
                for (const missingDep of missingDependencies) {
                    if (setStateRecommendation !== null) {
                        break;
                    }
                    const usedDep = dependencies.get(missingDep);
                    const references = usedDep.references;
                    let id;
                    let maybeCall;
                    for (const reference of references) {
                        id = reference.identifier;
                        maybeCall = id.parent;
                        while (maybeCall != null && maybeCall !== componentScope.block) {
                            if (maybeCall.type === 'CallExpression') {
                                const correspondingStateVariable = setStateCallSites.get(maybeCall.callee);
                                if (correspondingStateVariable != null) {
                                    if ('name' in correspondingStateVariable &&
                                        correspondingStateVariable.name === missingDep) {
                                        setStateRecommendation = {
                                            missingDep,
                                            setter: 'name' in maybeCall.callee ? maybeCall.callee.name : '',
                                            form: 'updater',
                                        };
                                    }
                                    else if (stateVariables.has(id)) {
                                        setStateRecommendation = {
                                            missingDep,
                                            setter: 'name' in maybeCall.callee ? maybeCall.callee.name : '',
                                            form: 'reducer',
                                        };
                                    }
                                    else {
                                        const resolved = reference.resolved;
                                        if (resolved != null) {
                                            const def = resolved.defs[0];
                                            if (def != null && def.type === 'Parameter') {
                                                setStateRecommendation = {
                                                    missingDep,
                                                    setter: 'name' in maybeCall.callee
                                                        ? maybeCall.callee.name
                                                        : '',
                                                    form: 'inlineReducer',
                                                };
                                            }
                                        }
                                    }
                                    break;
                                }
                            }
                            maybeCall = maybeCall.parent;
                        }
                        if (setStateRecommendation !== null) {
                            break;
                        }
                    }
                }
                if (setStateRecommendation !== null) {
                    switch (setStateRecommendation.form) {
                        case 'reducer':
                            extraWarning =
                                ` You can also replace multiple useState variables with useReducer ` +
                                    `if '${setStateRecommendation.setter}' needs the ` +
                                    `current value of '${setStateRecommendation.missingDep}'.`;
                            break;
                        case 'inlineReducer':
                            extraWarning =
                                ` If '${setStateRecommendation.setter}' needs the ` +
                                    `current value of '${setStateRecommendation.missingDep}', ` +
                                    `you can also switch to useReducer instead of useState and ` +
                                    `read '${setStateRecommendation.missingDep}' in the reducer.`;
                            break;
                        case 'updater':
                            extraWarning =
                                ` You can also do a functional update '${setStateRecommendation.setter}(${setStateRecommendation.missingDep.slice(0, 1)} => ...)' if you only need '${setStateRecommendation.missingDep}'` + ` in the '${setStateRecommendation.setter}' call.`;
                            break;
                        default:
                            throw new Error('Unknown case.');
                    }
                }
            }
            reportProblem({
                node: declaredDependenciesNode,
                message: `React Hook ${getSourceCode().getText(reactiveHook)} has ` +
                    (getWarningMessage(missingDependencies, 'a', 'missing', 'include') ||
                        getWarningMessage(unnecessaryDependencies, 'an', 'unnecessary', 'exclude') ||
                        getWarningMessage(duplicateDependencies, 'a', 'duplicate', 'omit')) +
                    extraWarning,
                suggest: [
                    {
                        desc: `Update the dependencies array to be: [${suggestedDeps
                            .map(formatDependency)
                            .join(', ')}]`,
                        fix(fixer) {
                            return fixer.replaceText(declaredDependenciesNode, `[${suggestedDeps.map(formatDependency).join(', ')}]`);
                        },
                    },
                ],
            });
        }
        function visitCallExpression(node) {
            const callbackIndex = getReactiveHookCallbackIndex(node.callee, options);
            if (callbackIndex === -1) {
                return;
            }
            let callback = node.arguments[callbackIndex];
            const reactiveHook = node.callee;
            const nodeWithoutNamespace = getNodeWithoutReactNamespace$1(reactiveHook);
            const reactiveHookName = 'name' in nodeWithoutNamespace ? nodeWithoutNamespace.name : '';
            const maybeNode = node.arguments[callbackIndex + 1];
            const declaredDependenciesNode = maybeNode &&
                !(maybeNode.type === 'Identifier' && maybeNode.name === 'undefined')
                ? maybeNode
                : undefined;
            const isEffect = /Effect($|[^a-z])/g.test(reactiveHookName);
            if (!callback) {
                reportProblem({
                    node: reactiveHook,
                    message: `React Hook ${reactiveHookName} requires an effect callback. ` +
                        `Did you forget to pass a callback to the hook?`,
                });
                return;
            }
            if (!maybeNode && isEffect && options.requireExplicitEffectDeps) {
                reportProblem({
                    node: reactiveHook,
                    message: `React Hook ${reactiveHookName} always requires dependencies. ` +
                        `Please add a dependency array or an explicit \`undefined\``,
                });
            }
            const isAutoDepsHook = options.experimental_autoDependenciesHooks.includes(reactiveHookName);
            if ((!declaredDependenciesNode ||
                (isAutoDepsHook &&
                    declaredDependenciesNode.type === 'Literal' &&
                    declaredDependenciesNode.value === null)) &&
                !isEffect) {
                if (reactiveHookName === 'useMemo' ||
                    reactiveHookName === 'useCallback') {
                    reportProblem({
                        node: reactiveHook,
                        message: `React Hook ${reactiveHookName} does nothing when called with ` +
                            `only one argument. Did you forget to pass an array of ` +
                            `dependencies?`,
                    });
                }
                return;
            }
            while (callback.type === 'TSAsExpression' ||
                callback.type === 'AsExpression') {
                callback = callback.expression;
            }
            switch (callback.type) {
                case 'FunctionExpression':
                case 'ArrowFunctionExpression':
                    visitFunctionWithDependencies(callback, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect, isAutoDepsHook);
                    return;
                case 'Identifier':
                    if (!declaredDependenciesNode ||
                        (isAutoDepsHook &&
                            declaredDependenciesNode.type === 'Literal' &&
                            declaredDependenciesNode.value === null)) {
                        return;
                    }
                    if ('elements' in declaredDependenciesNode &&
                        declaredDependenciesNode.elements &&
                        declaredDependenciesNode.elements.some(el => el && el.type === 'Identifier' && el.name === callback.name)) {
                        return;
                    }
                    const variable = getScope(callback).set.get(callback.name);
                    if (variable == null || variable.defs == null) {
                        return;
                    }
                    const def = variable.defs[0];
                    if (!def || !def.node) {
                        break;
                    }
                    if (def.type === 'Parameter') {
                        reportProblem({
                            node: reactiveHook,
                            message: getUnknownDependenciesMessage(reactiveHookName),
                        });
                        return;
                    }
                    if (def.type !== 'Variable' && def.type !== 'FunctionName') {
                        break;
                    }
                    switch (def.node.type) {
                        case 'FunctionDeclaration':
                            visitFunctionWithDependencies(def.node, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect, isAutoDepsHook);
                            return;
                        case 'VariableDeclarator':
                            const init = def.node.init;
                            if (!init) {
                                break;
                            }
                            switch (init.type) {
                                case 'ArrowFunctionExpression':
                                case 'FunctionExpression':
                                    visitFunctionWithDependencies(init, declaredDependenciesNode, reactiveHook, reactiveHookName, isEffect, isAutoDepsHook);
                                    return;
                            }
                            break;
                    }
                    break;
                default:
                    reportProblem({
                        node: reactiveHook,
                        message: getUnknownDependenciesMessage(reactiveHookName),
                    });
                    return;
            }
            reportProblem({
                node: reactiveHook,
                message: `React Hook ${reactiveHookName} has a missing dependency: '${callback.name}'. ` +
                    `Either include it or remove the dependency array.`,
                suggest: [
                    {
                        desc: `Update the dependencies array to be: [${callback.name}]`,
                        fix(fixer) {
                            return fixer.replaceText(declaredDependenciesNode, `[${callback.name}]`);
                        },
                    },
                ],
            });
        }
        return {
            CallExpression: visitCallExpression,
        };
    },
};
function collectRecommendations({ dependencies, declaredDependencies, stableDependencies, externalDependencies, isEffect, }) {
    const depTree = createDepTree();
    function createDepTree() {
        return {
            isUsed: false,
            isSatisfiedRecursively: false,
            isSubtreeUsed: false,
            children: new Map(),
        };
    }
    dependencies.forEach((_, key) => {
        const node = getOrCreateNodeByPath(depTree, key);
        node.isUsed = true;
        markAllParentsByPath(depTree, key, parent => {
            parent.isSubtreeUsed = true;
        });
    });
    declaredDependencies.forEach(({ key }) => {
        const node = getOrCreateNodeByPath(depTree, key);
        node.isSatisfiedRecursively = true;
    });
    stableDependencies.forEach(key => {
        const node = getOrCreateNodeByPath(depTree, key);
        node.isSatisfiedRecursively = true;
    });
    function getOrCreateNodeByPath(rootNode, path) {
        const keys = path.split('.');
        let node = rootNode;
        for (const key of keys) {
            let child = node.children.get(key);
            if (!child) {
                child = createDepTree();
                node.children.set(key, child);
            }
            node = child;
        }
        return node;
    }
    function markAllParentsByPath(rootNode, path, fn) {
        const keys = path.split('.');
        let node = rootNode;
        for (const key of keys) {
            const child = node.children.get(key);
            if (!child) {
                return;
            }
            fn(child);
            node = child;
        }
    }
    const missingDependencies = new Set();
    const satisfyingDependencies = new Set();
    scanTreeRecursively(depTree, missingDependencies, satisfyingDependencies, key => key);
    function scanTreeRecursively(node, missingPaths, satisfyingPaths, keyToPath) {
        node.children.forEach((child, key) => {
            const path = keyToPath(key);
            if (child.isSatisfiedRecursively) {
                if (child.isSubtreeUsed) {
                    satisfyingPaths.add(path);
                }
                return;
            }
            if (child.isUsed) {
                missingPaths.add(path);
                return;
            }
            scanTreeRecursively(child, missingPaths, satisfyingPaths, childKey => path + '.' + childKey);
        });
    }
    const suggestedDependencies = [];
    const unnecessaryDependencies = new Set();
    const duplicateDependencies = new Set();
    declaredDependencies.forEach(({ key }) => {
        if (satisfyingDependencies.has(key)) {
            if (suggestedDependencies.indexOf(key) === -1) {
                suggestedDependencies.push(key);
            }
            else {
                duplicateDependencies.add(key);
            }
        }
        else {
            if (isEffect &&
                !key.endsWith('.current') &&
                !externalDependencies.has(key)) {
                if (suggestedDependencies.indexOf(key) === -1) {
                    suggestedDependencies.push(key);
                }
            }
            else {
                unnecessaryDependencies.add(key);
            }
        }
    });
    missingDependencies.forEach(key => {
        suggestedDependencies.push(key);
    });
    return {
        suggestedDependencies,
        unnecessaryDependencies,
        duplicateDependencies,
        missingDependencies,
    };
}
function getConstructionExpressionType(node) {
    switch (node.type) {
        case 'ObjectExpression':
            return 'object';
        case 'ArrayExpression':
            return 'array';
        case 'ArrowFunctionExpression':
        case 'FunctionExpression':
            return 'function';
        case 'ClassExpression':
            return 'class';
        case 'ConditionalExpression':
            if (getConstructionExpressionType(node.consequent) != null ||
                getConstructionExpressionType(node.alternate) != null) {
                return 'conditional';
            }
            return null;
        case 'LogicalExpression':
            if (getConstructionExpressionType(node.left) != null ||
                getConstructionExpressionType(node.right) != null) {
                return 'logical expression';
            }
            return null;
        case 'JSXFragment':
            return 'JSX fragment';
        case 'JSXElement':
            return 'JSX element';
        case 'AssignmentExpression':
            if (getConstructionExpressionType(node.right) != null) {
                return 'assignment expression';
            }
            return null;
        case 'NewExpression':
            return 'object construction';
        case 'Literal':
            if (node.value instanceof RegExp) {
                return 'regular expression';
            }
            return null;
        case 'TypeCastExpression':
        case 'AsExpression':
        case 'TSAsExpression':
            return getConstructionExpressionType(node.expression);
    }
    return null;
}
function scanForConstructions({ declaredDependencies, declaredDependenciesNode, componentScope, scope, }) {
    const constructions = declaredDependencies
        .map(({ key }) => {
        const ref = componentScope.variables.find(v => v.name === key);
        if (ref == null) {
            return null;
        }
        const node = ref.defs[0];
        if (node == null) {
            return null;
        }
        if (node.type === 'Variable' &&
            node.node.type === 'VariableDeclarator' &&
            node.node.id.type === 'Identifier' &&
            node.node.init != null) {
            const constantExpressionType = getConstructionExpressionType(node.node.init);
            if (constantExpressionType) {
                return [ref, constantExpressionType];
            }
        }
        if (node.type === 'FunctionName' &&
            node.node.type === 'FunctionDeclaration') {
            return [ref, 'function'];
        }
        if (node.type === 'ClassName' && node.node.type === 'ClassDeclaration') {
            return [ref, 'class'];
        }
        return null;
    })
        .filter(Boolean);
    function isUsedOutsideOfHook(ref) {
        let foundWriteExpr = false;
        for (const reference of ref.references) {
            if (reference.writeExpr) {
                if (foundWriteExpr) {
                    return true;
                }
                else {
                    foundWriteExpr = true;
                    continue;
                }
            }
            let currentScope = reference.from;
            while (currentScope !== scope && currentScope != null) {
                currentScope = currentScope.upper;
            }
            if (currentScope !== scope) {
                if (!isAncestorNodeOf(declaredDependenciesNode, reference.identifier)) {
                    return true;
                }
            }
        }
        return false;
    }
    return constructions.map(([ref, depType]) => ({
        construction: ref.defs[0],
        depType,
        isUsedOutsideOfHook: isUsedOutsideOfHook(ref),
    }));
}
function getDependency(node) {
    if (node.parent &&
        (node.parent.type === 'MemberExpression' ||
            node.parent.type === 'OptionalMemberExpression') &&
        node.parent.object === node &&
        'name' in node.parent.property &&
        node.parent.property.name !== 'current' &&
        !node.parent.computed &&
        !(node.parent.parent != null &&
            (node.parent.parent.type === 'CallExpression' ||
                node.parent.parent.type === 'OptionalCallExpression') &&
            node.parent.parent.callee === node.parent)) {
        return getDependency(node.parent);
    }
    else if (node.type === 'MemberExpression' &&
        node.parent &&
        node.parent.type === 'AssignmentExpression' &&
        node.parent.left === node) {
        return node.object;
    }
    else {
        return node;
    }
}
function markNode(node, optionalChains, result) {
    if (optionalChains) {
        if ('optional' in node && node.optional) {
            if (!optionalChains.has(result)) {
                optionalChains.set(result, true);
            }
        }
        else {
            optionalChains.set(result, false);
        }
    }
}
function analyzePropertyChain(node, optionalChains) {
    if (node.type === 'Identifier' || node.type === 'JSXIdentifier') {
        const result = node.name;
        if (optionalChains) {
            optionalChains.set(result, false);
        }
        return result;
    }
    else if (node.type === 'MemberExpression' && !node.computed) {
        const object = analyzePropertyChain(node.object, optionalChains);
        const property = analyzePropertyChain(node.property, null);
        const result = `${object}.${property}`;
        markNode(node, optionalChains, result);
        return result;
    }
    else if (node.type === 'OptionalMemberExpression' && !node.computed) {
        const object = analyzePropertyChain(node.object, optionalChains);
        const property = analyzePropertyChain(node.property, null);
        const result = `${object}.${property}`;
        markNode(node, optionalChains, result);
        return result;
    }
    else if (node.type === 'ChainExpression' &&
        (!('computed' in node) || !node.computed)) {
        const expression = node.expression;
        if (expression.type === 'CallExpression') {
            throw new Error(`Unsupported node type: ${expression.type}`);
        }
        const object = analyzePropertyChain(expression.object, optionalChains);
        const property = analyzePropertyChain(expression.property, null);
        const result = `${object}.${property}`;
        markNode(expression, optionalChains, result);
        return result;
    }
    else {
        throw new Error(`Unsupported node type: ${node.type}`);
    }
}
function getNodeWithoutReactNamespace$1(node) {
    if (node.type === 'MemberExpression' &&
        node.object.type === 'Identifier' &&
        node.object.name === 'React' &&
        node.property.type === 'Identifier' &&
        !node.computed) {
        return node.property;
    }
    return node;
}
function getReactiveHookCallbackIndex(calleeNode, options) {
    const node = getNodeWithoutReactNamespace$1(calleeNode);
    if (node.type !== 'Identifier') {
        return -1;
    }
    switch (node.name) {
        case 'useEffect':
        case 'useLayoutEffect':
        case 'useCallback':
        case 'useMemo':
            return 0;
        case 'useImperativeHandle':
            return 1;
        default:
            if (node === calleeNode && options && options.additionalHooks) {
                let name;
                try {
                    name = analyzePropertyChain(node, null);
                }
                catch (error) {
                    if (error instanceof Error &&
                        /Unsupported node type/.test(error.message)) {
                        return 0;
                    }
                    else {
                        throw error;
                    }
                }
                return options.additionalHooks.test(name) ? 0 : -1;
            }
            else {
                return -1;
            }
    }
}
function fastFindReferenceWithParent(start, target) {
    const queue = [start];
    let item;
    while (queue.length) {
        item = queue.shift();
        if (isSameIdentifier(item, target)) {
            return item;
        }
        if (!isAncestorNodeOf(item, target)) {
            continue;
        }
        for (const [key, value] of Object.entries(item)) {
            if (key === 'parent') {
                continue;
            }
            if (isNodeLike(value)) {
                value.parent = item;
                queue.push(value);
            }
            else if (Array.isArray(value)) {
                value.forEach(val => {
                    if (isNodeLike(val)) {
                        val.parent = item;
                        queue.push(val);
                    }
                });
            }
        }
    }
    return null;
}
function joinEnglish(arr) {
    let s = '';
    for (let i = 0; i < arr.length; i++) {
        s += arr[i];
        if (i === 0 && arr.length === 2) {
            s += ' and ';
        }
        else if (i === arr.length - 2 && arr.length > 2) {
            s += ', and ';
        }
        else if (i < arr.length - 1) {
            s += ', ';
        }
    }
    return s;
}
function isNodeLike(val) {
    return (typeof val === 'object' &&
        val !== null &&
        !Array.isArray(val) &&
        'type' in val &&
        typeof val.type === 'string');
}
function isSameIdentifier(a, b) {
    return ((a.type === 'Identifier' || a.type === 'JSXIdentifier') &&
        a.type === b.type &&
        a.name === b.name &&
        !!a.range &&
        !!b.range &&
        a.range[0] === b.range[0] &&
        a.range[1] === b.range[1]);
}
function isAncestorNodeOf(a, b) {
    return (!!a.range &&
        !!b.range &&
        a.range[0] <= b.range[0] &&
        a.range[1] >= b.range[1]);
}
function isUseEffectEventIdentifier$1(node) {
    return node.type === 'Identifier' && node.name === 'useEffectEvent';
}
function getUnknownDependenciesMessage(reactiveHookName) {
    return (`React Hook ${reactiveHookName} received a function whose dependencies ` +
        `are unknown. Pass an inline function instead.`);
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var invariant_1;
var hasRequiredInvariant;

function requireInvariant () {
	if (hasRequiredInvariant) return invariant_1;
	hasRequiredInvariant = 1;

	var invariant = function(condition, format, a, b, c, d, e, f) {
	  {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	invariant_1 = invariant;
	return invariant_1;
}

var invariantExports = requireInvariant();
var invariant = /*@__PURE__*/getDefaultExportFromCjs(invariantExports);

var lib$3 = {};

var isReactComponent = {};

var buildMatchMemberExpression = {};

var matchesPattern = {};

var generated$3 = {};

var shallowEqual = {};

var hasRequiredShallowEqual;

function requireShallowEqual () {
	if (hasRequiredShallowEqual) return shallowEqual;
	hasRequiredShallowEqual = 1;

	Object.defineProperty(shallowEqual, "__esModule", {
	  value: true
	});
	shallowEqual.default = shallowEqual$1;
	function shallowEqual$1(actual, expected) {
	  const keys = Object.keys(expected);
	  for (const key of keys) {
	    if (actual[key] !== expected[key]) {
	      return false;
	    }
	  }
	  return true;
	}

	
	return shallowEqual;
}

var deprecationWarning = {};

var hasRequiredDeprecationWarning;

function requireDeprecationWarning () {
	if (hasRequiredDeprecationWarning) return deprecationWarning;
	hasRequiredDeprecationWarning = 1;

	Object.defineProperty(deprecationWarning, "__esModule", {
	  value: true
	});
	deprecationWarning.default = deprecationWarning$1;
	const warnings = new Set();
	function deprecationWarning$1(oldName, newName, prefix = "") {
	  if (warnings.has(oldName)) return;
	  warnings.add(oldName);
	  const {
	    internal,
	    trace
	  } = captureShortStackTrace(1, 2);
	  if (internal) {
	    return;
	  }
	  console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`\n${trace}`);
	}
	function captureShortStackTrace(skip, length) {
	  const {
	    stackTraceLimit,
	    prepareStackTrace
	  } = Error;
	  let stackTrace;
	  Error.stackTraceLimit = 1 + skip + length;
	  Error.prepareStackTrace = function (err, stack) {
	    stackTrace = stack;
	  };
	  Error.stackTraceLimit = stackTraceLimit;
	  Error.prepareStackTrace = prepareStackTrace;
	  if (!stackTrace) return {
	    internal: false,
	    trace: ""
	  };
	  const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
	  return {
	    internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
	    trace: shortStackTrace.map(frame => `    at ${frame}`).join("\n")
	  };
	}

	
	return deprecationWarning;
}

var hasRequiredGenerated$3;

function requireGenerated$3 () {
	if (hasRequiredGenerated$3) return generated$3;
	hasRequiredGenerated$3 = 1;

	Object.defineProperty(generated$3, "__esModule", {
	  value: true
	});
	generated$3.isAccessor = isAccessor;
	generated$3.isAnyTypeAnnotation = isAnyTypeAnnotation;
	generated$3.isArgumentPlaceholder = isArgumentPlaceholder;
	generated$3.isArrayExpression = isArrayExpression;
	generated$3.isArrayPattern = isArrayPattern;
	generated$3.isArrayTypeAnnotation = isArrayTypeAnnotation;
	generated$3.isArrowFunctionExpression = isArrowFunctionExpression;
	generated$3.isAssignmentExpression = isAssignmentExpression;
	generated$3.isAssignmentPattern = isAssignmentPattern;
	generated$3.isAwaitExpression = isAwaitExpression;
	generated$3.isBigIntLiteral = isBigIntLiteral;
	generated$3.isBinary = isBinary;
	generated$3.isBinaryExpression = isBinaryExpression;
	generated$3.isBindExpression = isBindExpression;
	generated$3.isBlock = isBlock;
	generated$3.isBlockParent = isBlockParent;
	generated$3.isBlockStatement = isBlockStatement;
	generated$3.isBooleanLiteral = isBooleanLiteral;
	generated$3.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
	generated$3.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
	generated$3.isBreakStatement = isBreakStatement;
	generated$3.isCallExpression = isCallExpression;
	generated$3.isCatchClause = isCatchClause;
	generated$3.isClass = isClass;
	generated$3.isClassAccessorProperty = isClassAccessorProperty;
	generated$3.isClassBody = isClassBody;
	generated$3.isClassDeclaration = isClassDeclaration;
	generated$3.isClassExpression = isClassExpression;
	generated$3.isClassImplements = isClassImplements;
	generated$3.isClassMethod = isClassMethod;
	generated$3.isClassPrivateMethod = isClassPrivateMethod;
	generated$3.isClassPrivateProperty = isClassPrivateProperty;
	generated$3.isClassProperty = isClassProperty;
	generated$3.isCompletionStatement = isCompletionStatement;
	generated$3.isConditional = isConditional;
	generated$3.isConditionalExpression = isConditionalExpression;
	generated$3.isContinueStatement = isContinueStatement;
	generated$3.isDebuggerStatement = isDebuggerStatement;
	generated$3.isDecimalLiteral = isDecimalLiteral;
	generated$3.isDeclaration = isDeclaration;
	generated$3.isDeclareClass = isDeclareClass;
	generated$3.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
	generated$3.isDeclareExportDeclaration = isDeclareExportDeclaration;
	generated$3.isDeclareFunction = isDeclareFunction;
	generated$3.isDeclareInterface = isDeclareInterface;
	generated$3.isDeclareModule = isDeclareModule;
	generated$3.isDeclareModuleExports = isDeclareModuleExports;
	generated$3.isDeclareOpaqueType = isDeclareOpaqueType;
	generated$3.isDeclareTypeAlias = isDeclareTypeAlias;
	generated$3.isDeclareVariable = isDeclareVariable;
	generated$3.isDeclaredPredicate = isDeclaredPredicate;
	generated$3.isDecorator = isDecorator;
	generated$3.isDirective = isDirective;
	generated$3.isDirectiveLiteral = isDirectiveLiteral;
	generated$3.isDoExpression = isDoExpression;
	generated$3.isDoWhileStatement = isDoWhileStatement;
	generated$3.isEmptyStatement = isEmptyStatement;
	generated$3.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
	generated$3.isEnumBody = isEnumBody;
	generated$3.isEnumBooleanBody = isEnumBooleanBody;
	generated$3.isEnumBooleanMember = isEnumBooleanMember;
	generated$3.isEnumDeclaration = isEnumDeclaration;
	generated$3.isEnumDefaultedMember = isEnumDefaultedMember;
	generated$3.isEnumMember = isEnumMember;
	generated$3.isEnumNumberBody = isEnumNumberBody;
	generated$3.isEnumNumberMember = isEnumNumberMember;
	generated$3.isEnumStringBody = isEnumStringBody;
	generated$3.isEnumStringMember = isEnumStringMember;
	generated$3.isEnumSymbolBody = isEnumSymbolBody;
	generated$3.isExistsTypeAnnotation = isExistsTypeAnnotation;
	generated$3.isExportAllDeclaration = isExportAllDeclaration;
	generated$3.isExportDeclaration = isExportDeclaration;
	generated$3.isExportDefaultDeclaration = isExportDefaultDeclaration;
	generated$3.isExportDefaultSpecifier = isExportDefaultSpecifier;
	generated$3.isExportNamedDeclaration = isExportNamedDeclaration;
	generated$3.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
	generated$3.isExportSpecifier = isExportSpecifier;
	generated$3.isExpression = isExpression;
	generated$3.isExpressionStatement = isExpressionStatement;
	generated$3.isExpressionWrapper = isExpressionWrapper;
	generated$3.isFile = isFile;
	generated$3.isFlow = isFlow;
	generated$3.isFlowBaseAnnotation = isFlowBaseAnnotation;
	generated$3.isFlowDeclaration = isFlowDeclaration;
	generated$3.isFlowPredicate = isFlowPredicate;
	generated$3.isFlowType = isFlowType;
	generated$3.isFor = isFor;
	generated$3.isForInStatement = isForInStatement;
	generated$3.isForOfStatement = isForOfStatement;
	generated$3.isForStatement = isForStatement;
	generated$3.isForXStatement = isForXStatement;
	generated$3.isFunction = isFunction;
	generated$3.isFunctionDeclaration = isFunctionDeclaration;
	generated$3.isFunctionExpression = isFunctionExpression;
	generated$3.isFunctionParent = isFunctionParent;
	generated$3.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
	generated$3.isFunctionTypeParam = isFunctionTypeParam;
	generated$3.isGenericTypeAnnotation = isGenericTypeAnnotation;
	generated$3.isIdentifier = isIdentifier;
	generated$3.isIfStatement = isIfStatement;
	generated$3.isImmutable = isImmutable;
	generated$3.isImport = isImport;
	generated$3.isImportAttribute = isImportAttribute;
	generated$3.isImportDeclaration = isImportDeclaration;
	generated$3.isImportDefaultSpecifier = isImportDefaultSpecifier;
	generated$3.isImportExpression = isImportExpression;
	generated$3.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
	generated$3.isImportOrExportDeclaration = isImportOrExportDeclaration;
	generated$3.isImportSpecifier = isImportSpecifier;
	generated$3.isIndexedAccessType = isIndexedAccessType;
	generated$3.isInferredPredicate = isInferredPredicate;
	generated$3.isInterfaceDeclaration = isInterfaceDeclaration;
	generated$3.isInterfaceExtends = isInterfaceExtends;
	generated$3.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
	generated$3.isInterpreterDirective = isInterpreterDirective;
	generated$3.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
	generated$3.isJSX = isJSX;
	generated$3.isJSXAttribute = isJSXAttribute;
	generated$3.isJSXClosingElement = isJSXClosingElement;
	generated$3.isJSXClosingFragment = isJSXClosingFragment;
	generated$3.isJSXElement = isJSXElement;
	generated$3.isJSXEmptyExpression = isJSXEmptyExpression;
	generated$3.isJSXExpressionContainer = isJSXExpressionContainer;
	generated$3.isJSXFragment = isJSXFragment;
	generated$3.isJSXIdentifier = isJSXIdentifier;
	generated$3.isJSXMemberExpression = isJSXMemberExpression;
	generated$3.isJSXNamespacedName = isJSXNamespacedName;
	generated$3.isJSXOpeningElement = isJSXOpeningElement;
	generated$3.isJSXOpeningFragment = isJSXOpeningFragment;
	generated$3.isJSXSpreadAttribute = isJSXSpreadAttribute;
	generated$3.isJSXSpreadChild = isJSXSpreadChild;
	generated$3.isJSXText = isJSXText;
	generated$3.isLVal = isLVal;
	generated$3.isLabeledStatement = isLabeledStatement;
	generated$3.isLiteral = isLiteral;
	generated$3.isLogicalExpression = isLogicalExpression;
	generated$3.isLoop = isLoop;
	generated$3.isMemberExpression = isMemberExpression;
	generated$3.isMetaProperty = isMetaProperty;
	generated$3.isMethod = isMethod;
	generated$3.isMiscellaneous = isMiscellaneous;
	generated$3.isMixedTypeAnnotation = isMixedTypeAnnotation;
	generated$3.isModuleDeclaration = isModuleDeclaration;
	generated$3.isModuleExpression = isModuleExpression;
	generated$3.isModuleSpecifier = isModuleSpecifier;
	generated$3.isNewExpression = isNewExpression;
	generated$3.isNoop = isNoop;
	generated$3.isNullLiteral = isNullLiteral;
	generated$3.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
	generated$3.isNullableTypeAnnotation = isNullableTypeAnnotation;
	generated$3.isNumberLiteral = isNumberLiteral;
	generated$3.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
	generated$3.isNumberTypeAnnotation = isNumberTypeAnnotation;
	generated$3.isNumericLiteral = isNumericLiteral;
	generated$3.isObjectExpression = isObjectExpression;
	generated$3.isObjectMember = isObjectMember;
	generated$3.isObjectMethod = isObjectMethod;
	generated$3.isObjectPattern = isObjectPattern;
	generated$3.isObjectProperty = isObjectProperty;
	generated$3.isObjectTypeAnnotation = isObjectTypeAnnotation;
	generated$3.isObjectTypeCallProperty = isObjectTypeCallProperty;
	generated$3.isObjectTypeIndexer = isObjectTypeIndexer;
	generated$3.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
	generated$3.isObjectTypeProperty = isObjectTypeProperty;
	generated$3.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
	generated$3.isOpaqueType = isOpaqueType;
	generated$3.isOptionalCallExpression = isOptionalCallExpression;
	generated$3.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
	generated$3.isOptionalMemberExpression = isOptionalMemberExpression;
	generated$3.isParenthesizedExpression = isParenthesizedExpression;
	generated$3.isPattern = isPattern;
	generated$3.isPatternLike = isPatternLike;
	generated$3.isPipelineBareFunction = isPipelineBareFunction;
	generated$3.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
	generated$3.isPipelineTopicExpression = isPipelineTopicExpression;
	generated$3.isPlaceholder = isPlaceholder;
	generated$3.isPrivate = isPrivate;
	generated$3.isPrivateName = isPrivateName;
	generated$3.isProgram = isProgram;
	generated$3.isProperty = isProperty;
	generated$3.isPureish = isPureish;
	generated$3.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
	generated$3.isRecordExpression = isRecordExpression;
	generated$3.isRegExpLiteral = isRegExpLiteral;
	generated$3.isRegexLiteral = isRegexLiteral;
	generated$3.isRestElement = isRestElement;
	generated$3.isRestProperty = isRestProperty;
	generated$3.isReturnStatement = isReturnStatement;
	generated$3.isScopable = isScopable;
	generated$3.isSequenceExpression = isSequenceExpression;
	generated$3.isSpreadElement = isSpreadElement;
	generated$3.isSpreadProperty = isSpreadProperty;
	generated$3.isStandardized = isStandardized;
	generated$3.isStatement = isStatement;
	generated$3.isStaticBlock = isStaticBlock;
	generated$3.isStringLiteral = isStringLiteral;
	generated$3.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
	generated$3.isStringTypeAnnotation = isStringTypeAnnotation;
	generated$3.isSuper = isSuper;
	generated$3.isSwitchCase = isSwitchCase;
	generated$3.isSwitchStatement = isSwitchStatement;
	generated$3.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
	generated$3.isTSAnyKeyword = isTSAnyKeyword;
	generated$3.isTSArrayType = isTSArrayType;
	generated$3.isTSAsExpression = isTSAsExpression;
	generated$3.isTSBaseType = isTSBaseType;
	generated$3.isTSBigIntKeyword = isTSBigIntKeyword;
	generated$3.isTSBooleanKeyword = isTSBooleanKeyword;
	generated$3.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
	generated$3.isTSConditionalType = isTSConditionalType;
	generated$3.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
	generated$3.isTSConstructorType = isTSConstructorType;
	generated$3.isTSDeclareFunction = isTSDeclareFunction;
	generated$3.isTSDeclareMethod = isTSDeclareMethod;
	generated$3.isTSEntityName = isTSEntityName;
	generated$3.isTSEnumDeclaration = isTSEnumDeclaration;
	generated$3.isTSEnumMember = isTSEnumMember;
	generated$3.isTSExportAssignment = isTSExportAssignment;
	generated$3.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
	generated$3.isTSExternalModuleReference = isTSExternalModuleReference;
	generated$3.isTSFunctionType = isTSFunctionType;
	generated$3.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
	generated$3.isTSImportType = isTSImportType;
	generated$3.isTSIndexSignature = isTSIndexSignature;
	generated$3.isTSIndexedAccessType = isTSIndexedAccessType;
	generated$3.isTSInferType = isTSInferType;
	generated$3.isTSInstantiationExpression = isTSInstantiationExpression;
	generated$3.isTSInterfaceBody = isTSInterfaceBody;
	generated$3.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
	generated$3.isTSIntersectionType = isTSIntersectionType;
	generated$3.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
	generated$3.isTSLiteralType = isTSLiteralType;
	generated$3.isTSMappedType = isTSMappedType;
	generated$3.isTSMethodSignature = isTSMethodSignature;
	generated$3.isTSModuleBlock = isTSModuleBlock;
	generated$3.isTSModuleDeclaration = isTSModuleDeclaration;
	generated$3.isTSNamedTupleMember = isTSNamedTupleMember;
	generated$3.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
	generated$3.isTSNeverKeyword = isTSNeverKeyword;
	generated$3.isTSNonNullExpression = isTSNonNullExpression;
	generated$3.isTSNullKeyword = isTSNullKeyword;
	generated$3.isTSNumberKeyword = isTSNumberKeyword;
	generated$3.isTSObjectKeyword = isTSObjectKeyword;
	generated$3.isTSOptionalType = isTSOptionalType;
	generated$3.isTSParameterProperty = isTSParameterProperty;
	generated$3.isTSParenthesizedType = isTSParenthesizedType;
	generated$3.isTSPropertySignature = isTSPropertySignature;
	generated$3.isTSQualifiedName = isTSQualifiedName;
	generated$3.isTSRestType = isTSRestType;
	generated$3.isTSSatisfiesExpression = isTSSatisfiesExpression;
	generated$3.isTSStringKeyword = isTSStringKeyword;
	generated$3.isTSSymbolKeyword = isTSSymbolKeyword;
	generated$3.isTSThisType = isTSThisType;
	generated$3.isTSTupleType = isTSTupleType;
	generated$3.isTSType = isTSType;
	generated$3.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
	generated$3.isTSTypeAnnotation = isTSTypeAnnotation;
	generated$3.isTSTypeAssertion = isTSTypeAssertion;
	generated$3.isTSTypeElement = isTSTypeElement;
	generated$3.isTSTypeLiteral = isTSTypeLiteral;
	generated$3.isTSTypeOperator = isTSTypeOperator;
	generated$3.isTSTypeParameter = isTSTypeParameter;
	generated$3.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
	generated$3.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
	generated$3.isTSTypePredicate = isTSTypePredicate;
	generated$3.isTSTypeQuery = isTSTypeQuery;
	generated$3.isTSTypeReference = isTSTypeReference;
	generated$3.isTSUndefinedKeyword = isTSUndefinedKeyword;
	generated$3.isTSUnionType = isTSUnionType;
	generated$3.isTSUnknownKeyword = isTSUnknownKeyword;
	generated$3.isTSVoidKeyword = isTSVoidKeyword;
	generated$3.isTaggedTemplateExpression = isTaggedTemplateExpression;
	generated$3.isTemplateElement = isTemplateElement;
	generated$3.isTemplateLiteral = isTemplateLiteral;
	generated$3.isTerminatorless = isTerminatorless;
	generated$3.isThisExpression = isThisExpression;
	generated$3.isThisTypeAnnotation = isThisTypeAnnotation;
	generated$3.isThrowStatement = isThrowStatement;
	generated$3.isTopicReference = isTopicReference;
	generated$3.isTryStatement = isTryStatement;
	generated$3.isTupleExpression = isTupleExpression;
	generated$3.isTupleTypeAnnotation = isTupleTypeAnnotation;
	generated$3.isTypeAlias = isTypeAlias;
	generated$3.isTypeAnnotation = isTypeAnnotation;
	generated$3.isTypeCastExpression = isTypeCastExpression;
	generated$3.isTypeParameter = isTypeParameter;
	generated$3.isTypeParameterDeclaration = isTypeParameterDeclaration;
	generated$3.isTypeParameterInstantiation = isTypeParameterInstantiation;
	generated$3.isTypeScript = isTypeScript;
	generated$3.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
	generated$3.isUnaryExpression = isUnaryExpression;
	generated$3.isUnaryLike = isUnaryLike;
	generated$3.isUnionTypeAnnotation = isUnionTypeAnnotation;
	generated$3.isUpdateExpression = isUpdateExpression;
	generated$3.isUserWhitespacable = isUserWhitespacable;
	generated$3.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
	generated$3.isVariableDeclaration = isVariableDeclaration;
	generated$3.isVariableDeclarator = isVariableDeclarator;
	generated$3.isVariance = isVariance;
	generated$3.isVoidTypeAnnotation = isVoidTypeAnnotation;
	generated$3.isWhile = isWhile;
	generated$3.isWhileStatement = isWhileStatement;
	generated$3.isWithStatement = isWithStatement;
	generated$3.isYieldExpression = isYieldExpression;
	var _shallowEqual = requireShallowEqual();
	var _deprecationWarning = requireDeprecationWarning();
	function isArrayExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ArrayExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isAssignmentExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "AssignmentExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBinaryExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BinaryExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isInterpreterDirective(node, opts) {
	  if (!node) return false;
	  if (node.type !== "InterpreterDirective") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDirective(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Directive") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDirectiveLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DirectiveLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBlockStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BlockStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBreakStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BreakStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isCallExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "CallExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isCatchClause(node, opts) {
	  if (!node) return false;
	  if (node.type !== "CatchClause") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isConditionalExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ConditionalExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isContinueStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ContinueStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDebuggerStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DebuggerStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDoWhileStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DoWhileStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEmptyStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EmptyStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExpressionStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExpressionStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFile(node, opts) {
	  if (!node) return false;
	  if (node.type !== "File") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isForInStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ForInStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isForStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ForStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFunctionDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "FunctionDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFunctionExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "FunctionExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isIdentifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Identifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isIfStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "IfStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isLabeledStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "LabeledStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isStringLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "StringLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNumericLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NumericLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNullLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NullLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBooleanLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BooleanLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isRegExpLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "RegExpLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isLogicalExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "LogicalExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isMemberExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "MemberExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNewExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NewExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isProgram(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Program") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectMethod(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectMethod") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isRestElement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "RestElement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isReturnStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ReturnStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSequenceExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "SequenceExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isParenthesizedExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ParenthesizedExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSwitchCase(node, opts) {
	  if (!node) return false;
	  if (node.type !== "SwitchCase") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSwitchStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "SwitchStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isThisExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ThisExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isThrowStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ThrowStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTryStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TryStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isUnaryExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "UnaryExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isUpdateExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "UpdateExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isVariableDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "VariableDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isVariableDeclarator(node, opts) {
	  if (!node) return false;
	  if (node.type !== "VariableDeclarator") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isWhileStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "WhileStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isWithStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "WithStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isAssignmentPattern(node, opts) {
	  if (!node) return false;
	  if (node.type !== "AssignmentPattern") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isArrayPattern(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ArrayPattern") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isArrowFunctionExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ArrowFunctionExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassBody(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassBody") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportAllDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExportAllDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportDefaultDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExportDefaultDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportNamedDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExportNamedDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportSpecifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExportSpecifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isForOfStatement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ForOfStatement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ImportDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportDefaultSpecifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ImportDefaultSpecifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportNamespaceSpecifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ImportNamespaceSpecifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportSpecifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ImportSpecifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ImportExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isMetaProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "MetaProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassMethod(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassMethod") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectPattern(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectPattern") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSpreadElement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "SpreadElement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSuper(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Super") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTaggedTemplateExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TaggedTemplateExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTemplateElement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TemplateElement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTemplateLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TemplateLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isYieldExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "YieldExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isAwaitExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "AwaitExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImport(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Import") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBigIntLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BigIntLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportNamespaceSpecifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExportNamespaceSpecifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isOptionalMemberExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "OptionalMemberExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isOptionalCallExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "OptionalCallExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassAccessorProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassAccessorProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassPrivateProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassPrivateProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassPrivateMethod(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassPrivateMethod") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPrivateName(node, opts) {
	  if (!node) return false;
	  if (node.type !== "PrivateName") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isStaticBlock(node, opts) {
	  if (!node) return false;
	  if (node.type !== "StaticBlock") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isAnyTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "AnyTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isArrayTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ArrayTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBooleanTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BooleanTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBooleanLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BooleanLiteralTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNullLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NullLiteralTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClassImplements(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ClassImplements") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareClass(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareClass") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareFunction(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareFunction") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareInterface(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareInterface") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareModule(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareModule") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareModuleExports(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareModuleExports") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareTypeAlias(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareTypeAlias") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareOpaqueType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareOpaqueType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareVariable(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareVariable") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareExportDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareExportDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclareExportAllDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclareExportAllDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclaredPredicate(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DeclaredPredicate") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExistsTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExistsTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFunctionTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "FunctionTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFunctionTypeParam(node, opts) {
	  if (!node) return false;
	  if (node.type !== "FunctionTypeParam") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isGenericTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "GenericTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isInferredPredicate(node, opts) {
	  if (!node) return false;
	  if (node.type !== "InferredPredicate") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isInterfaceExtends(node, opts) {
	  if (!node) return false;
	  if (node.type !== "InterfaceExtends") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isInterfaceDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "InterfaceDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isInterfaceTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "InterfaceTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isIntersectionTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "IntersectionTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isMixedTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "MixedTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEmptyTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EmptyTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNullableTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NullableTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNumberLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NumberLiteralTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNumberTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "NumberTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectTypeInternalSlot(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectTypeInternalSlot") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectTypeCallProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectTypeCallProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectTypeIndexer(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectTypeIndexer") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectTypeProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectTypeProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectTypeSpreadProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ObjectTypeSpreadProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isOpaqueType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "OpaqueType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isQualifiedTypeIdentifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "QualifiedTypeIdentifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isStringLiteralTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "StringLiteralTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isStringTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "StringTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSymbolTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "SymbolTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isThisTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ThisTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTupleTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TupleTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeofTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeofTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeAlias(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeAlias") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeCastExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeCastExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeParameter(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeParameter") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeParameterDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeParameterDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeParameterInstantiation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TypeParameterInstantiation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isUnionTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "UnionTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isVariance(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Variance") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isVoidTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "VoidTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumBooleanBody(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumBooleanBody") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumNumberBody(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumNumberBody") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumStringBody(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumStringBody") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumSymbolBody(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumSymbolBody") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumBooleanMember(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumBooleanMember") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumNumberMember(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumNumberMember") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumStringMember(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumStringMember") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumDefaultedMember(node, opts) {
	  if (!node) return false;
	  if (node.type !== "EnumDefaultedMember") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isIndexedAccessType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "IndexedAccessType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isOptionalIndexedAccessType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "OptionalIndexedAccessType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXAttribute(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXAttribute") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXClosingElement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXClosingElement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXElement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXElement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXEmptyExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXEmptyExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXExpressionContainer(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXExpressionContainer") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXSpreadChild(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXSpreadChild") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXIdentifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXIdentifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXMemberExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXMemberExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXNamespacedName(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXNamespacedName") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXOpeningElement(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXOpeningElement") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXSpreadAttribute(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXSpreadAttribute") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXText(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXText") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXFragment(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXFragment") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXOpeningFragment(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXOpeningFragment") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSXClosingFragment(node, opts) {
	  if (!node) return false;
	  if (node.type !== "JSXClosingFragment") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNoop(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Noop") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPlaceholder(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Placeholder") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isV8IntrinsicIdentifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "V8IntrinsicIdentifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isArgumentPlaceholder(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ArgumentPlaceholder") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBindExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "BindExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportAttribute(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ImportAttribute") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDecorator(node, opts) {
	  if (!node) return false;
	  if (node.type !== "Decorator") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDoExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DoExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportDefaultSpecifier(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ExportDefaultSpecifier") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isRecordExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "RecordExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTupleExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TupleExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDecimalLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "DecimalLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isModuleExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "ModuleExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTopicReference(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TopicReference") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPipelineTopicExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "PipelineTopicExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPipelineBareFunction(node, opts) {
	  if (!node) return false;
	  if (node.type !== "PipelineBareFunction") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPipelinePrimaryTopicReference(node, opts) {
	  if (!node) return false;
	  if (node.type !== "PipelinePrimaryTopicReference") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSParameterProperty(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSParameterProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSDeclareFunction(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSDeclareFunction") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSDeclareMethod(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSDeclareMethod") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSQualifiedName(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSQualifiedName") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSCallSignatureDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSCallSignatureDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSConstructSignatureDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSConstructSignatureDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSPropertySignature(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSPropertySignature") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSMethodSignature(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSMethodSignature") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSIndexSignature(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSIndexSignature") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSAnyKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSAnyKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSBooleanKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSBooleanKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSBigIntKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSBigIntKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSIntrinsicKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSIntrinsicKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSNeverKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSNeverKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSNullKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSNullKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSNumberKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSNumberKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSObjectKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSObjectKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSStringKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSStringKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSSymbolKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSSymbolKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSUndefinedKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSUndefinedKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSUnknownKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSUnknownKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSVoidKeyword(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSVoidKeyword") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSThisType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSThisType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSFunctionType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSFunctionType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSConstructorType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSConstructorType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeReference(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeReference") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypePredicate(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypePredicate") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeQuery(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeQuery") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeLiteral(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSArrayType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSArrayType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTupleType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTupleType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSOptionalType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSOptionalType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSRestType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSRestType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSNamedTupleMember(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSNamedTupleMember") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSUnionType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSUnionType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSIntersectionType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSIntersectionType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSConditionalType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSConditionalType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSInferType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSInferType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSParenthesizedType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSParenthesizedType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeOperator(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeOperator") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSIndexedAccessType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSIndexedAccessType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSMappedType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSMappedType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSLiteralType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSLiteralType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSExpressionWithTypeArguments(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSExpressionWithTypeArguments") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSInterfaceDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSInterfaceDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSInterfaceBody(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSInterfaceBody") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeAliasDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeAliasDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSInstantiationExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSInstantiationExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSAsExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSAsExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSSatisfiesExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSSatisfiesExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeAssertion(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeAssertion") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSEnumDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSEnumDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSEnumMember(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSEnumMember") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSModuleDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSModuleDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSModuleBlock(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSModuleBlock") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSImportType(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSImportType") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSImportEqualsDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSImportEqualsDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSExternalModuleReference(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSExternalModuleReference") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSNonNullExpression(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSNonNullExpression") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSExportAssignment(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSExportAssignment") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSNamespaceExportDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSNamespaceExportDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeAnnotation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeAnnotation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeParameterInstantiation(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeParameterInstantiation") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeParameterDeclaration(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeParameterDeclaration") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeParameter(node, opts) {
	  if (!node) return false;
	  if (node.type !== "TSTypeParameter") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isStandardized(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ArrayExpression":
	    case "AssignmentExpression":
	    case "BinaryExpression":
	    case "InterpreterDirective":
	    case "Directive":
	    case "DirectiveLiteral":
	    case "BlockStatement":
	    case "BreakStatement":
	    case "CallExpression":
	    case "CatchClause":
	    case "ConditionalExpression":
	    case "ContinueStatement":
	    case "DebuggerStatement":
	    case "DoWhileStatement":
	    case "EmptyStatement":
	    case "ExpressionStatement":
	    case "File":
	    case "ForInStatement":
	    case "ForStatement":
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	    case "Identifier":
	    case "IfStatement":
	    case "LabeledStatement":
	    case "StringLiteral":
	    case "NumericLiteral":
	    case "NullLiteral":
	    case "BooleanLiteral":
	    case "RegExpLiteral":
	    case "LogicalExpression":
	    case "MemberExpression":
	    case "NewExpression":
	    case "Program":
	    case "ObjectExpression":
	    case "ObjectMethod":
	    case "ObjectProperty":
	    case "RestElement":
	    case "ReturnStatement":
	    case "SequenceExpression":
	    case "ParenthesizedExpression":
	    case "SwitchCase":
	    case "SwitchStatement":
	    case "ThisExpression":
	    case "ThrowStatement":
	    case "TryStatement":
	    case "UnaryExpression":
	    case "UpdateExpression":
	    case "VariableDeclaration":
	    case "VariableDeclarator":
	    case "WhileStatement":
	    case "WithStatement":
	    case "AssignmentPattern":
	    case "ArrayPattern":
	    case "ArrowFunctionExpression":
	    case "ClassBody":
	    case "ClassExpression":
	    case "ClassDeclaration":
	    case "ExportAllDeclaration":
	    case "ExportDefaultDeclaration":
	    case "ExportNamedDeclaration":
	    case "ExportSpecifier":
	    case "ForOfStatement":
	    case "ImportDeclaration":
	    case "ImportDefaultSpecifier":
	    case "ImportNamespaceSpecifier":
	    case "ImportSpecifier":
	    case "ImportExpression":
	    case "MetaProperty":
	    case "ClassMethod":
	    case "ObjectPattern":
	    case "SpreadElement":
	    case "Super":
	    case "TaggedTemplateExpression":
	    case "TemplateElement":
	    case "TemplateLiteral":
	    case "YieldExpression":
	    case "AwaitExpression":
	    case "Import":
	    case "BigIntLiteral":
	    case "ExportNamespaceSpecifier":
	    case "OptionalMemberExpression":
	    case "OptionalCallExpression":
	    case "ClassProperty":
	    case "ClassAccessorProperty":
	    case "ClassPrivateProperty":
	    case "ClassPrivateMethod":
	    case "PrivateName":
	    case "StaticBlock":
	      break;
	    case "Placeholder":
	      switch (node.expectedNode) {
	        case "Identifier":
	        case "StringLiteral":
	        case "BlockStatement":
	        case "ClassBody":
	          break;
	        default:
	          return false;
	      }
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExpression(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ArrayExpression":
	    case "AssignmentExpression":
	    case "BinaryExpression":
	    case "CallExpression":
	    case "ConditionalExpression":
	    case "FunctionExpression":
	    case "Identifier":
	    case "StringLiteral":
	    case "NumericLiteral":
	    case "NullLiteral":
	    case "BooleanLiteral":
	    case "RegExpLiteral":
	    case "LogicalExpression":
	    case "MemberExpression":
	    case "NewExpression":
	    case "ObjectExpression":
	    case "SequenceExpression":
	    case "ParenthesizedExpression":
	    case "ThisExpression":
	    case "UnaryExpression":
	    case "UpdateExpression":
	    case "ArrowFunctionExpression":
	    case "ClassExpression":
	    case "ImportExpression":
	    case "MetaProperty":
	    case "Super":
	    case "TaggedTemplateExpression":
	    case "TemplateLiteral":
	    case "YieldExpression":
	    case "AwaitExpression":
	    case "Import":
	    case "BigIntLiteral":
	    case "OptionalMemberExpression":
	    case "OptionalCallExpression":
	    case "TypeCastExpression":
	    case "JSXElement":
	    case "JSXFragment":
	    case "BindExpression":
	    case "DoExpression":
	    case "RecordExpression":
	    case "TupleExpression":
	    case "DecimalLiteral":
	    case "ModuleExpression":
	    case "TopicReference":
	    case "PipelineTopicExpression":
	    case "PipelineBareFunction":
	    case "PipelinePrimaryTopicReference":
	    case "TSInstantiationExpression":
	    case "TSAsExpression":
	    case "TSSatisfiesExpression":
	    case "TSTypeAssertion":
	    case "TSNonNullExpression":
	      break;
	    case "Placeholder":
	      switch (node.expectedNode) {
	        case "Expression":
	        case "Identifier":
	        case "StringLiteral":
	          break;
	        default:
	          return false;
	      }
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBinary(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BinaryExpression":
	    case "LogicalExpression":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isScopable(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BlockStatement":
	    case "CatchClause":
	    case "DoWhileStatement":
	    case "ForInStatement":
	    case "ForStatement":
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	    case "Program":
	    case "ObjectMethod":
	    case "SwitchStatement":
	    case "WhileStatement":
	    case "ArrowFunctionExpression":
	    case "ClassExpression":
	    case "ClassDeclaration":
	    case "ForOfStatement":
	    case "ClassMethod":
	    case "ClassPrivateMethod":
	    case "StaticBlock":
	    case "TSModuleBlock":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "BlockStatement") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBlockParent(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BlockStatement":
	    case "CatchClause":
	    case "DoWhileStatement":
	    case "ForInStatement":
	    case "ForStatement":
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	    case "Program":
	    case "ObjectMethod":
	    case "SwitchStatement":
	    case "WhileStatement":
	    case "ArrowFunctionExpression":
	    case "ForOfStatement":
	    case "ClassMethod":
	    case "ClassPrivateMethod":
	    case "StaticBlock":
	    case "TSModuleBlock":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "BlockStatement") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isBlock(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BlockStatement":
	    case "Program":
	    case "TSModuleBlock":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "BlockStatement") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isStatement(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BlockStatement":
	    case "BreakStatement":
	    case "ContinueStatement":
	    case "DebuggerStatement":
	    case "DoWhileStatement":
	    case "EmptyStatement":
	    case "ExpressionStatement":
	    case "ForInStatement":
	    case "ForStatement":
	    case "FunctionDeclaration":
	    case "IfStatement":
	    case "LabeledStatement":
	    case "ReturnStatement":
	    case "SwitchStatement":
	    case "ThrowStatement":
	    case "TryStatement":
	    case "VariableDeclaration":
	    case "WhileStatement":
	    case "WithStatement":
	    case "ClassDeclaration":
	    case "ExportAllDeclaration":
	    case "ExportDefaultDeclaration":
	    case "ExportNamedDeclaration":
	    case "ForOfStatement":
	    case "ImportDeclaration":
	    case "DeclareClass":
	    case "DeclareFunction":
	    case "DeclareInterface":
	    case "DeclareModule":
	    case "DeclareModuleExports":
	    case "DeclareTypeAlias":
	    case "DeclareOpaqueType":
	    case "DeclareVariable":
	    case "DeclareExportDeclaration":
	    case "DeclareExportAllDeclaration":
	    case "InterfaceDeclaration":
	    case "OpaqueType":
	    case "TypeAlias":
	    case "EnumDeclaration":
	    case "TSDeclareFunction":
	    case "TSInterfaceDeclaration":
	    case "TSTypeAliasDeclaration":
	    case "TSEnumDeclaration":
	    case "TSModuleDeclaration":
	    case "TSImportEqualsDeclaration":
	    case "TSExportAssignment":
	    case "TSNamespaceExportDeclaration":
	      break;
	    case "Placeholder":
	      switch (node.expectedNode) {
	        case "Statement":
	        case "Declaration":
	        case "BlockStatement":
	          break;
	        default:
	          return false;
	      }
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTerminatorless(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BreakStatement":
	    case "ContinueStatement":
	    case "ReturnStatement":
	    case "ThrowStatement":
	    case "YieldExpression":
	    case "AwaitExpression":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isCompletionStatement(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "BreakStatement":
	    case "ContinueStatement":
	    case "ReturnStatement":
	    case "ThrowStatement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isConditional(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ConditionalExpression":
	    case "IfStatement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isLoop(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "DoWhileStatement":
	    case "ForInStatement":
	    case "ForStatement":
	    case "WhileStatement":
	    case "ForOfStatement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isWhile(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "DoWhileStatement":
	    case "WhileStatement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExpressionWrapper(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ExpressionStatement":
	    case "ParenthesizedExpression":
	    case "TypeCastExpression":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFor(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ForInStatement":
	    case "ForStatement":
	    case "ForOfStatement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isForXStatement(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ForInStatement":
	    case "ForOfStatement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFunction(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	    case "ObjectMethod":
	    case "ArrowFunctionExpression":
	    case "ClassMethod":
	    case "ClassPrivateMethod":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFunctionParent(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	    case "ObjectMethod":
	    case "ArrowFunctionExpression":
	    case "ClassMethod":
	    case "ClassPrivateMethod":
	    case "StaticBlock":
	    case "TSModuleBlock":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPureish(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "FunctionDeclaration":
	    case "FunctionExpression":
	    case "StringLiteral":
	    case "NumericLiteral":
	    case "NullLiteral":
	    case "BooleanLiteral":
	    case "RegExpLiteral":
	    case "ArrowFunctionExpression":
	    case "BigIntLiteral":
	    case "DecimalLiteral":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "StringLiteral") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isDeclaration(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "FunctionDeclaration":
	    case "VariableDeclaration":
	    case "ClassDeclaration":
	    case "ExportAllDeclaration":
	    case "ExportDefaultDeclaration":
	    case "ExportNamedDeclaration":
	    case "ImportDeclaration":
	    case "DeclareClass":
	    case "DeclareFunction":
	    case "DeclareInterface":
	    case "DeclareModule":
	    case "DeclareModuleExports":
	    case "DeclareTypeAlias":
	    case "DeclareOpaqueType":
	    case "DeclareVariable":
	    case "DeclareExportDeclaration":
	    case "DeclareExportAllDeclaration":
	    case "InterfaceDeclaration":
	    case "OpaqueType":
	    case "TypeAlias":
	    case "EnumDeclaration":
	    case "TSDeclareFunction":
	    case "TSInterfaceDeclaration":
	    case "TSTypeAliasDeclaration":
	    case "TSEnumDeclaration":
	    case "TSModuleDeclaration":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "Declaration") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPatternLike(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "Identifier":
	    case "RestElement":
	    case "AssignmentPattern":
	    case "ArrayPattern":
	    case "ObjectPattern":
	    case "TSAsExpression":
	    case "TSSatisfiesExpression":
	    case "TSTypeAssertion":
	    case "TSNonNullExpression":
	      break;
	    case "Placeholder":
	      switch (node.expectedNode) {
	        case "Pattern":
	        case "Identifier":
	          break;
	        default:
	          return false;
	      }
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isLVal(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "Identifier":
	    case "MemberExpression":
	    case "RestElement":
	    case "AssignmentPattern":
	    case "ArrayPattern":
	    case "ObjectPattern":
	    case "TSParameterProperty":
	    case "TSAsExpression":
	    case "TSSatisfiesExpression":
	    case "TSTypeAssertion":
	    case "TSNonNullExpression":
	      break;
	    case "Placeholder":
	      switch (node.expectedNode) {
	        case "Pattern":
	        case "Identifier":
	          break;
	        default:
	          return false;
	      }
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSEntityName(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "Identifier":
	    case "TSQualifiedName":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "Identifier") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isLiteral(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "StringLiteral":
	    case "NumericLiteral":
	    case "NullLiteral":
	    case "BooleanLiteral":
	    case "RegExpLiteral":
	    case "TemplateLiteral":
	    case "BigIntLiteral":
	    case "DecimalLiteral":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "StringLiteral") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImmutable(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "StringLiteral":
	    case "NumericLiteral":
	    case "NullLiteral":
	    case "BooleanLiteral":
	    case "BigIntLiteral":
	    case "JSXAttribute":
	    case "JSXClosingElement":
	    case "JSXElement":
	    case "JSXExpressionContainer":
	    case "JSXSpreadChild":
	    case "JSXOpeningElement":
	    case "JSXText":
	    case "JSXFragment":
	    case "JSXOpeningFragment":
	    case "JSXClosingFragment":
	    case "DecimalLiteral":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "StringLiteral") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isUserWhitespacable(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ObjectMethod":
	    case "ObjectProperty":
	    case "ObjectTypeInternalSlot":
	    case "ObjectTypeCallProperty":
	    case "ObjectTypeIndexer":
	    case "ObjectTypeProperty":
	    case "ObjectTypeSpreadProperty":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isMethod(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ObjectMethod":
	    case "ClassMethod":
	    case "ClassPrivateMethod":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isObjectMember(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ObjectMethod":
	    case "ObjectProperty":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isProperty(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ObjectProperty":
	    case "ClassProperty":
	    case "ClassAccessorProperty":
	    case "ClassPrivateProperty":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isUnaryLike(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "UnaryExpression":
	    case "SpreadElement":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPattern(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "AssignmentPattern":
	    case "ArrayPattern":
	    case "ObjectPattern":
	      break;
	    case "Placeholder":
	      if (node.expectedNode === "Pattern") break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isClass(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ClassExpression":
	    case "ClassDeclaration":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isImportOrExportDeclaration(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ExportAllDeclaration":
	    case "ExportDefaultDeclaration":
	    case "ExportNamedDeclaration":
	    case "ImportDeclaration":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isExportDeclaration(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ExportAllDeclaration":
	    case "ExportDefaultDeclaration":
	    case "ExportNamedDeclaration":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isModuleSpecifier(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ExportSpecifier":
	    case "ImportDefaultSpecifier":
	    case "ImportNamespaceSpecifier":
	    case "ImportSpecifier":
	    case "ExportNamespaceSpecifier":
	    case "ExportDefaultSpecifier":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isAccessor(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ClassAccessorProperty":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isPrivate(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "ClassPrivateProperty":
	    case "ClassPrivateMethod":
	    case "PrivateName":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFlow(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "AnyTypeAnnotation":
	    case "ArrayTypeAnnotation":
	    case "BooleanTypeAnnotation":
	    case "BooleanLiteralTypeAnnotation":
	    case "NullLiteralTypeAnnotation":
	    case "ClassImplements":
	    case "DeclareClass":
	    case "DeclareFunction":
	    case "DeclareInterface":
	    case "DeclareModule":
	    case "DeclareModuleExports":
	    case "DeclareTypeAlias":
	    case "DeclareOpaqueType":
	    case "DeclareVariable":
	    case "DeclareExportDeclaration":
	    case "DeclareExportAllDeclaration":
	    case "DeclaredPredicate":
	    case "ExistsTypeAnnotation":
	    case "FunctionTypeAnnotation":
	    case "FunctionTypeParam":
	    case "GenericTypeAnnotation":
	    case "InferredPredicate":
	    case "InterfaceExtends":
	    case "InterfaceDeclaration":
	    case "InterfaceTypeAnnotation":
	    case "IntersectionTypeAnnotation":
	    case "MixedTypeAnnotation":
	    case "EmptyTypeAnnotation":
	    case "NullableTypeAnnotation":
	    case "NumberLiteralTypeAnnotation":
	    case "NumberTypeAnnotation":
	    case "ObjectTypeAnnotation":
	    case "ObjectTypeInternalSlot":
	    case "ObjectTypeCallProperty":
	    case "ObjectTypeIndexer":
	    case "ObjectTypeProperty":
	    case "ObjectTypeSpreadProperty":
	    case "OpaqueType":
	    case "QualifiedTypeIdentifier":
	    case "StringLiteralTypeAnnotation":
	    case "StringTypeAnnotation":
	    case "SymbolTypeAnnotation":
	    case "ThisTypeAnnotation":
	    case "TupleTypeAnnotation":
	    case "TypeofTypeAnnotation":
	    case "TypeAlias":
	    case "TypeAnnotation":
	    case "TypeCastExpression":
	    case "TypeParameter":
	    case "TypeParameterDeclaration":
	    case "TypeParameterInstantiation":
	    case "UnionTypeAnnotation":
	    case "Variance":
	    case "VoidTypeAnnotation":
	    case "EnumDeclaration":
	    case "EnumBooleanBody":
	    case "EnumNumberBody":
	    case "EnumStringBody":
	    case "EnumSymbolBody":
	    case "EnumBooleanMember":
	    case "EnumNumberMember":
	    case "EnumStringMember":
	    case "EnumDefaultedMember":
	    case "IndexedAccessType":
	    case "OptionalIndexedAccessType":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFlowType(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "AnyTypeAnnotation":
	    case "ArrayTypeAnnotation":
	    case "BooleanTypeAnnotation":
	    case "BooleanLiteralTypeAnnotation":
	    case "NullLiteralTypeAnnotation":
	    case "ExistsTypeAnnotation":
	    case "FunctionTypeAnnotation":
	    case "GenericTypeAnnotation":
	    case "InterfaceTypeAnnotation":
	    case "IntersectionTypeAnnotation":
	    case "MixedTypeAnnotation":
	    case "EmptyTypeAnnotation":
	    case "NullableTypeAnnotation":
	    case "NumberLiteralTypeAnnotation":
	    case "NumberTypeAnnotation":
	    case "ObjectTypeAnnotation":
	    case "StringLiteralTypeAnnotation":
	    case "StringTypeAnnotation":
	    case "SymbolTypeAnnotation":
	    case "ThisTypeAnnotation":
	    case "TupleTypeAnnotation":
	    case "TypeofTypeAnnotation":
	    case "UnionTypeAnnotation":
	    case "VoidTypeAnnotation":
	    case "IndexedAccessType":
	    case "OptionalIndexedAccessType":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFlowBaseAnnotation(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "AnyTypeAnnotation":
	    case "BooleanTypeAnnotation":
	    case "NullLiteralTypeAnnotation":
	    case "MixedTypeAnnotation":
	    case "EmptyTypeAnnotation":
	    case "NumberTypeAnnotation":
	    case "StringTypeAnnotation":
	    case "SymbolTypeAnnotation":
	    case "ThisTypeAnnotation":
	    case "VoidTypeAnnotation":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFlowDeclaration(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "DeclareClass":
	    case "DeclareFunction":
	    case "DeclareInterface":
	    case "DeclareModule":
	    case "DeclareModuleExports":
	    case "DeclareTypeAlias":
	    case "DeclareOpaqueType":
	    case "DeclareVariable":
	    case "DeclareExportDeclaration":
	    case "DeclareExportAllDeclaration":
	    case "InterfaceDeclaration":
	    case "OpaqueType":
	    case "TypeAlias":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isFlowPredicate(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "DeclaredPredicate":
	    case "InferredPredicate":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumBody(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "EnumBooleanBody":
	    case "EnumNumberBody":
	    case "EnumStringBody":
	    case "EnumSymbolBody":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isEnumMember(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "EnumBooleanMember":
	    case "EnumNumberMember":
	    case "EnumStringMember":
	    case "EnumDefaultedMember":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isJSX(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "JSXAttribute":
	    case "JSXClosingElement":
	    case "JSXElement":
	    case "JSXEmptyExpression":
	    case "JSXExpressionContainer":
	    case "JSXSpreadChild":
	    case "JSXIdentifier":
	    case "JSXMemberExpression":
	    case "JSXNamespacedName":
	    case "JSXOpeningElement":
	    case "JSXSpreadAttribute":
	    case "JSXText":
	    case "JSXFragment":
	    case "JSXOpeningFragment":
	    case "JSXClosingFragment":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isMiscellaneous(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "Noop":
	    case "Placeholder":
	    case "V8IntrinsicIdentifier":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTypeScript(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "TSParameterProperty":
	    case "TSDeclareFunction":
	    case "TSDeclareMethod":
	    case "TSQualifiedName":
	    case "TSCallSignatureDeclaration":
	    case "TSConstructSignatureDeclaration":
	    case "TSPropertySignature":
	    case "TSMethodSignature":
	    case "TSIndexSignature":
	    case "TSAnyKeyword":
	    case "TSBooleanKeyword":
	    case "TSBigIntKeyword":
	    case "TSIntrinsicKeyword":
	    case "TSNeverKeyword":
	    case "TSNullKeyword":
	    case "TSNumberKeyword":
	    case "TSObjectKeyword":
	    case "TSStringKeyword":
	    case "TSSymbolKeyword":
	    case "TSUndefinedKeyword":
	    case "TSUnknownKeyword":
	    case "TSVoidKeyword":
	    case "TSThisType":
	    case "TSFunctionType":
	    case "TSConstructorType":
	    case "TSTypeReference":
	    case "TSTypePredicate":
	    case "TSTypeQuery":
	    case "TSTypeLiteral":
	    case "TSArrayType":
	    case "TSTupleType":
	    case "TSOptionalType":
	    case "TSRestType":
	    case "TSNamedTupleMember":
	    case "TSUnionType":
	    case "TSIntersectionType":
	    case "TSConditionalType":
	    case "TSInferType":
	    case "TSParenthesizedType":
	    case "TSTypeOperator":
	    case "TSIndexedAccessType":
	    case "TSMappedType":
	    case "TSLiteralType":
	    case "TSExpressionWithTypeArguments":
	    case "TSInterfaceDeclaration":
	    case "TSInterfaceBody":
	    case "TSTypeAliasDeclaration":
	    case "TSInstantiationExpression":
	    case "TSAsExpression":
	    case "TSSatisfiesExpression":
	    case "TSTypeAssertion":
	    case "TSEnumDeclaration":
	    case "TSEnumMember":
	    case "TSModuleDeclaration":
	    case "TSModuleBlock":
	    case "TSImportType":
	    case "TSImportEqualsDeclaration":
	    case "TSExternalModuleReference":
	    case "TSNonNullExpression":
	    case "TSExportAssignment":
	    case "TSNamespaceExportDeclaration":
	    case "TSTypeAnnotation":
	    case "TSTypeParameterInstantiation":
	    case "TSTypeParameterDeclaration":
	    case "TSTypeParameter":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSTypeElement(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "TSCallSignatureDeclaration":
	    case "TSConstructSignatureDeclaration":
	    case "TSPropertySignature":
	    case "TSMethodSignature":
	    case "TSIndexSignature":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSType(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "TSAnyKeyword":
	    case "TSBooleanKeyword":
	    case "TSBigIntKeyword":
	    case "TSIntrinsicKeyword":
	    case "TSNeverKeyword":
	    case "TSNullKeyword":
	    case "TSNumberKeyword":
	    case "TSObjectKeyword":
	    case "TSStringKeyword":
	    case "TSSymbolKeyword":
	    case "TSUndefinedKeyword":
	    case "TSUnknownKeyword":
	    case "TSVoidKeyword":
	    case "TSThisType":
	    case "TSFunctionType":
	    case "TSConstructorType":
	    case "TSTypeReference":
	    case "TSTypePredicate":
	    case "TSTypeQuery":
	    case "TSTypeLiteral":
	    case "TSArrayType":
	    case "TSTupleType":
	    case "TSOptionalType":
	    case "TSRestType":
	    case "TSUnionType":
	    case "TSIntersectionType":
	    case "TSConditionalType":
	    case "TSInferType":
	    case "TSParenthesizedType":
	    case "TSTypeOperator":
	    case "TSIndexedAccessType":
	    case "TSMappedType":
	    case "TSLiteralType":
	    case "TSExpressionWithTypeArguments":
	    case "TSImportType":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isTSBaseType(node, opts) {
	  if (!node) return false;
	  switch (node.type) {
	    case "TSAnyKeyword":
	    case "TSBooleanKeyword":
	    case "TSBigIntKeyword":
	    case "TSIntrinsicKeyword":
	    case "TSNeverKeyword":
	    case "TSNullKeyword":
	    case "TSNumberKeyword":
	    case "TSObjectKeyword":
	    case "TSStringKeyword":
	    case "TSSymbolKeyword":
	    case "TSUndefinedKeyword":
	    case "TSUnknownKeyword":
	    case "TSVoidKeyword":
	    case "TSThisType":
	    case "TSLiteralType":
	      break;
	    default:
	      return false;
	  }
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isNumberLiteral(node, opts) {
	  (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
	  if (!node) return false;
	  if (node.type !== "NumberLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isRegexLiteral(node, opts) {
	  (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
	  if (!node) return false;
	  if (node.type !== "RegexLiteral") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isRestProperty(node, opts) {
	  (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
	  if (!node) return false;
	  if (node.type !== "RestProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isSpreadProperty(node, opts) {
	  (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
	  if (!node) return false;
	  if (node.type !== "SpreadProperty") return false;
	  return opts == null || (0, _shallowEqual.default)(node, opts);
	}
	function isModuleDeclaration(node, opts) {
	  (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
	  return isImportOrExportDeclaration(node, opts);
	}

	
	return generated$3;
}

var hasRequiredMatchesPattern;

function requireMatchesPattern () {
	if (hasRequiredMatchesPattern) return matchesPattern;
	hasRequiredMatchesPattern = 1;

	Object.defineProperty(matchesPattern, "__esModule", {
	  value: true
	});
	matchesPattern.default = matchesPattern$1;
	var _index = requireGenerated$3();
	function matchesPattern$1(member, match, allowPartial) {
	  if (!(0, _index.isMemberExpression)(member)) return false;
	  const parts = Array.isArray(match) ? match : match.split(".");
	  const nodes = [];
	  let node;
	  for (node = member; (0, _index.isMemberExpression)(node); node = node.object) {
	    nodes.push(node.property);
	  }
	  nodes.push(node);
	  if (nodes.length < parts.length) return false;
	  if (!allowPartial && nodes.length > parts.length) return false;
	  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
	    const node = nodes[j];
	    let value;
	    if ((0, _index.isIdentifier)(node)) {
	      value = node.name;
	    } else if ((0, _index.isStringLiteral)(node)) {
	      value = node.value;
	    } else if ((0, _index.isThisExpression)(node)) {
	      value = "this";
	    } else {
	      return false;
	    }
	    if (parts[i] !== value) return false;
	  }
	  return true;
	}

	
	return matchesPattern;
}

var hasRequiredBuildMatchMemberExpression;

function requireBuildMatchMemberExpression () {
	if (hasRequiredBuildMatchMemberExpression) return buildMatchMemberExpression;
	hasRequiredBuildMatchMemberExpression = 1;

	Object.defineProperty(buildMatchMemberExpression, "__esModule", {
	  value: true
	});
	buildMatchMemberExpression.default = buildMatchMemberExpression$1;
	var _matchesPattern = requireMatchesPattern();
	function buildMatchMemberExpression$1(match, allowPartial) {
	  const parts = match.split(".");
	  return member => (0, _matchesPattern.default)(member, parts, allowPartial);
	}

	
	return buildMatchMemberExpression;
}

var hasRequiredIsReactComponent;

function requireIsReactComponent () {
	if (hasRequiredIsReactComponent) return isReactComponent;
	hasRequiredIsReactComponent = 1;

	Object.defineProperty(isReactComponent, "__esModule", {
	  value: true
	});
	isReactComponent.default = void 0;
	var _buildMatchMemberExpression = requireBuildMatchMemberExpression();
	const isReactComponent$1 = (0, _buildMatchMemberExpression.default)("React.Component");
	isReactComponent.default = isReactComponent$1;

	
	return isReactComponent;
}

var isCompatTag = {};

var hasRequiredIsCompatTag;

function requireIsCompatTag () {
	if (hasRequiredIsCompatTag) return isCompatTag;
	hasRequiredIsCompatTag = 1;

	Object.defineProperty(isCompatTag, "__esModule", {
	  value: true
	});
	isCompatTag.default = isCompatTag$1;
	function isCompatTag$1(tagName) {
	  return !!tagName && /^[a-z]/.test(tagName);
	}

	
	return isCompatTag;
}

var buildChildren = {};

var cleanJSXElementLiteralChild = {};

var generated$2 = {};

var validate$1 = {};

var definitions = {};

var core = {};

var is = {};

var isType = {};

var hasRequiredIsType;

function requireIsType () {
	if (hasRequiredIsType) return isType;
	hasRequiredIsType = 1;

	Object.defineProperty(isType, "__esModule", {
	  value: true
	});
	isType.default = isType$1;
	var _index = requireDefinitions();
	function isType$1(nodeType, targetType) {
	  if (nodeType === targetType) return true;
	  if (nodeType == null) return false;
	  if (_index.ALIAS_KEYS[targetType]) return false;
	  const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
	  if (aliases) {
	    if (aliases[0] === nodeType) return true;
	    for (const alias of aliases) {
	      if (nodeType === alias) return true;
	    }
	  }
	  return false;
	}

	
	return isType;
}

var isPlaceholderType = {};

var hasRequiredIsPlaceholderType;

function requireIsPlaceholderType () {
	if (hasRequiredIsPlaceholderType) return isPlaceholderType;
	hasRequiredIsPlaceholderType = 1;

	Object.defineProperty(isPlaceholderType, "__esModule", {
	  value: true
	});
	isPlaceholderType.default = isPlaceholderType$1;
	var _index = requireDefinitions();
	function isPlaceholderType$1(placeholderType, targetType) {
	  if (placeholderType === targetType) return true;
	  const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
	  if (aliases) {
	    for (const alias of aliases) {
	      if (targetType === alias) return true;
	    }
	  }
	  return false;
	}

	
	return isPlaceholderType;
}

var hasRequiredIs;

function requireIs () {
	if (hasRequiredIs) return is;
	hasRequiredIs = 1;

	Object.defineProperty(is, "__esModule", {
	  value: true
	});
	is.default = is$1;
	var _shallowEqual = requireShallowEqual();
	var _isType = requireIsType();
	var _isPlaceholderType = requireIsPlaceholderType();
	var _index = requireDefinitions();
	function is$1(type, node, opts) {
	  if (!node) return false;
	  const matches = (0, _isType.default)(node.type, type);
	  if (!matches) {
	    if (!opts && node.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
	      return (0, _isPlaceholderType.default)(node.expectedNode, type);
	    }
	    return false;
	  }
	  if (opts === undefined) {
	    return true;
	  } else {
	    return (0, _shallowEqual.default)(node, opts);
	  }
	}

	
	return is;
}

var isValidIdentifier = {};

var lib$2 = {};

var identifier = {};

var hasRequiredIdentifier;

function requireIdentifier () {
	if (hasRequiredIdentifier) return identifier;
	hasRequiredIdentifier = 1;

	Object.defineProperty(identifier, "__esModule", {
	  value: true
	});
	identifier.isIdentifierChar = isIdentifierChar;
	identifier.isIdentifierName = isIdentifierName;
	identifier.isIdentifierStart = isIdentifierStart;
	let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
	let nonASCIIidentifierChars = "\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";
	const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
	const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
	const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
	function isInAstralSet(code, set) {
	  let pos = 0x10000;
	  for (let i = 0, length = set.length; i < length; i += 2) {
	    pos += set[i];
	    if (pos > code) return false;
	    pos += set[i + 1];
	    if (pos >= code) return true;
	  }
	  return false;
	}
	function isIdentifierStart(code) {
	  if (code < 65) return code === 36;
	  if (code <= 90) return true;
	  if (code < 97) return code === 95;
	  if (code <= 122) return true;
	  if (code <= 0xffff) {
	    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
	  }
	  return isInAstralSet(code, astralIdentifierStartCodes);
	}
	function isIdentifierChar(code) {
	  if (code < 48) return code === 36;
	  if (code < 58) return true;
	  if (code < 65) return false;
	  if (code <= 90) return true;
	  if (code < 97) return code === 95;
	  if (code <= 122) return true;
	  if (code <= 0xffff) {
	    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
	  }
	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
	}
	function isIdentifierName(name) {
	  let isFirst = true;
	  for (let i = 0; i < name.length; i++) {
	    let cp = name.charCodeAt(i);
	    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
	      const trail = name.charCodeAt(++i);
	      if ((trail & 0xfc00) === 0xdc00) {
	        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
	      }
	    }
	    if (isFirst) {
	      isFirst = false;
	      if (!isIdentifierStart(cp)) {
	        return false;
	      }
	    } else if (!isIdentifierChar(cp)) {
	      return false;
	    }
	  }
	  return !isFirst;
	}

	
	return identifier;
}

var keyword = {};

var hasRequiredKeyword;

function requireKeyword () {
	if (hasRequiredKeyword) return keyword;
	hasRequiredKeyword = 1;

	Object.defineProperty(keyword, "__esModule", {
	  value: true
	});
	keyword.isKeyword = isKeyword;
	keyword.isReservedWord = isReservedWord;
	keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
	keyword.isStrictBindReservedWord = isStrictBindReservedWord;
	keyword.isStrictReservedWord = isStrictReservedWord;
	const reservedWords = {
	  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
	  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
	  strictBind: ["eval", "arguments"]
	};
	const keywords = new Set(reservedWords.keyword);
	const reservedWordsStrictSet = new Set(reservedWords.strict);
	const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
	function isReservedWord(word, inModule) {
	  return inModule && word === "await" || word === "enum";
	}
	function isStrictReservedWord(word, inModule) {
	  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
	}
	function isStrictBindOnlyReservedWord(word) {
	  return reservedWordsStrictBindSet.has(word);
	}
	function isStrictBindReservedWord(word, inModule) {
	  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
	}
	function isKeyword(word) {
	  return keywords.has(word);
	}

	
	return keyword;
}

var hasRequiredLib$3;

function requireLib$3 () {
	if (hasRequiredLib$3) return lib$2;
	hasRequiredLib$3 = 1;
	(function (exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports, "isIdentifierChar", {
		  enumerable: true,
		  get: function () {
		    return _identifier.isIdentifierChar;
		  }
		});
		Object.defineProperty(exports, "isIdentifierName", {
		  enumerable: true,
		  get: function () {
		    return _identifier.isIdentifierName;
		  }
		});
		Object.defineProperty(exports, "isIdentifierStart", {
		  enumerable: true,
		  get: function () {
		    return _identifier.isIdentifierStart;
		  }
		});
		Object.defineProperty(exports, "isKeyword", {
		  enumerable: true,
		  get: function () {
		    return _keyword.isKeyword;
		  }
		});
		Object.defineProperty(exports, "isReservedWord", {
		  enumerable: true,
		  get: function () {
		    return _keyword.isReservedWord;
		  }
		});
		Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
		  enumerable: true,
		  get: function () {
		    return _keyword.isStrictBindOnlyReservedWord;
		  }
		});
		Object.defineProperty(exports, "isStrictBindReservedWord", {
		  enumerable: true,
		  get: function () {
		    return _keyword.isStrictBindReservedWord;
		  }
		});
		Object.defineProperty(exports, "isStrictReservedWord", {
		  enumerable: true,
		  get: function () {
		    return _keyword.isStrictReservedWord;
		  }
		});
		var _identifier = requireIdentifier();
		var _keyword = requireKeyword();

		
} (lib$2));
	return lib$2;
}

var hasRequiredIsValidIdentifier;

function requireIsValidIdentifier () {
	if (hasRequiredIsValidIdentifier) return isValidIdentifier;
	hasRequiredIsValidIdentifier = 1;

	Object.defineProperty(isValidIdentifier, "__esModule", {
	  value: true
	});
	isValidIdentifier.default = isValidIdentifier$1;
	var _helperValidatorIdentifier = requireLib$3();
	function isValidIdentifier$1(name, reserved = true) {
	  if (typeof name !== "string") return false;
	  if (reserved) {
	    if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
	      return false;
	    }
	  }
	  return (0, _helperValidatorIdentifier.isIdentifierName)(name);
	}

	
	return isValidIdentifier;
}

var lib$1 = {};

var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib$1;
	hasRequiredLib$2 = 1;

	Object.defineProperty(lib$1, "__esModule", {
	  value: true
	});
	lib$1.readCodePoint = readCodePoint;
	lib$1.readInt = readInt;
	lib$1.readStringContents = readStringContents;
	var _isDigit = function isDigit(code) {
	  return code >= 48 && code <= 57;
	};
	const forbiddenNumericSeparatorSiblings = {
	  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
	  hex: new Set([46, 88, 95, 120])
	};
	const isAllowedNumericSeparatorSibling = {
	  bin: ch => ch === 48 || ch === 49,
	  oct: ch => ch >= 48 && ch <= 55,
	  dec: ch => ch >= 48 && ch <= 57,
	  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
	};
	function readStringContents(type, input, pos, lineStart, curLine, errors) {
	  const initialPos = pos;
	  const initialLineStart = lineStart;
	  const initialCurLine = curLine;
	  let out = "";
	  let firstInvalidLoc = null;
	  let chunkStart = pos;
	  const {
	    length
	  } = input;
	  for (;;) {
	    if (pos >= length) {
	      errors.unterminated(initialPos, initialLineStart, initialCurLine);
	      out += input.slice(chunkStart, pos);
	      break;
	    }
	    const ch = input.charCodeAt(pos);
	    if (isStringEnd(type, ch, input, pos)) {
	      out += input.slice(chunkStart, pos);
	      break;
	    }
	    if (ch === 92) {
	      out += input.slice(chunkStart, pos);
	      const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
	      if (res.ch === null && !firstInvalidLoc) {
	        firstInvalidLoc = {
	          pos,
	          lineStart,
	          curLine
	        };
	      } else {
	        out += res.ch;
	      }
	      ({
	        pos,
	        lineStart,
	        curLine
	      } = res);
	      chunkStart = pos;
	    } else if (ch === 8232 || ch === 8233) {
	      ++pos;
	      ++curLine;
	      lineStart = pos;
	    } else if (ch === 10 || ch === 13) {
	      if (type === "template") {
	        out += input.slice(chunkStart, pos) + "\n";
	        ++pos;
	        if (ch === 13 && input.charCodeAt(pos) === 10) {
	          ++pos;
	        }
	        ++curLine;
	        chunkStart = lineStart = pos;
	      } else {
	        errors.unterminated(initialPos, initialLineStart, initialCurLine);
	      }
	    } else {
	      ++pos;
	    }
	  }
	  return {
	    pos,
	    str: out,
	    firstInvalidLoc,
	    lineStart,
	    curLine,
	    containsInvalid: !!firstInvalidLoc
	  };
	}
	function isStringEnd(type, ch, input, pos) {
	  if (type === "template") {
	    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
	  }
	  return ch === (type === "double" ? 34 : 39);
	}
	function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
	  const throwOnInvalid = !inTemplate;
	  pos++;
	  const res = ch => ({
	    pos,
	    ch,
	    lineStart,
	    curLine
	  });
	  const ch = input.charCodeAt(pos++);
	  switch (ch) {
	    case 110:
	      return res("\n");
	    case 114:
	      return res("\r");
	    case 120:
	      {
	        let code;
	        ({
	          code,
	          pos
	        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
	        return res(code === null ? null : String.fromCharCode(code));
	      }
	    case 117:
	      {
	        let code;
	        ({
	          code,
	          pos
	        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
	        return res(code === null ? null : String.fromCodePoint(code));
	      }
	    case 116:
	      return res("\t");
	    case 98:
	      return res("\b");
	    case 118:
	      return res("\u000b");
	    case 102:
	      return res("\f");
	    case 13:
	      if (input.charCodeAt(pos) === 10) {
	        ++pos;
	      }
	    case 10:
	      lineStart = pos;
	      ++curLine;
	    case 8232:
	    case 8233:
	      return res("");
	    case 56:
	    case 57:
	      if (inTemplate) {
	        return res(null);
	      } else {
	        errors.strictNumericEscape(pos - 1, lineStart, curLine);
	      }
	    default:
	      if (ch >= 48 && ch <= 55) {
	        const startPos = pos - 1;
	        const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
	        let octalStr = match[0];
	        let octal = parseInt(octalStr, 8);
	        if (octal > 255) {
	          octalStr = octalStr.slice(0, -1);
	          octal = parseInt(octalStr, 8);
	        }
	        pos += octalStr.length - 1;
	        const next = input.charCodeAt(pos);
	        if (octalStr !== "0" || next === 56 || next === 57) {
	          if (inTemplate) {
	            return res(null);
	          } else {
	            errors.strictNumericEscape(startPos, lineStart, curLine);
	          }
	        }
	        return res(String.fromCharCode(octal));
	      }
	      return res(String.fromCharCode(ch));
	  }
	}
	function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
	  const initialPos = pos;
	  let n;
	  ({
	    n,
	    pos
	  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
	  if (n === null) {
	    if (throwOnInvalid) {
	      errors.invalidEscapeSequence(initialPos, lineStart, curLine);
	    } else {
	      pos = initialPos - 1;
	    }
	  }
	  return {
	    code: n,
	    pos
	  };
	}
	function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
	  const start = pos;
	  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
	  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
	  let invalid = false;
	  let total = 0;
	  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	    const code = input.charCodeAt(pos);
	    let val;
	    if (code === 95 && allowNumSeparator !== "bail") {
	      const prev = input.charCodeAt(pos - 1);
	      const next = input.charCodeAt(pos + 1);
	      if (!allowNumSeparator) {
	        if (bailOnError) return {
	          n: null,
	          pos
	        };
	        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
	      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
	        if (bailOnError) return {
	          n: null,
	          pos
	        };
	        errors.unexpectedNumericSeparator(pos, lineStart, curLine);
	      }
	      ++pos;
	      continue;
	    }
	    if (code >= 97) {
	      val = code - 97 + 10;
	    } else if (code >= 65) {
	      val = code - 65 + 10;
	    } else if (_isDigit(code)) {
	      val = code - 48;
	    } else {
	      val = Infinity;
	    }
	    if (val >= radix) {
	      if (val <= 9 && bailOnError) {
	        return {
	          n: null,
	          pos
	        };
	      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
	        val = 0;
	      } else if (forceLen) {
	        val = 0;
	        invalid = true;
	      } else {
	        break;
	      }
	    }
	    ++pos;
	    total = total * radix + val;
	  }
	  if (pos === start || len != null && pos - start !== len || invalid) {
	    return {
	      n: null,
	      pos
	    };
	  }
	  return {
	    n: total,
	    pos
	  };
	}
	function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
	  const ch = input.charCodeAt(pos);
	  let code;
	  if (ch === 123) {
	    ++pos;
	    ({
	      code,
	      pos
	    } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
	    ++pos;
	    if (code !== null && code > 0x10ffff) {
	      if (throwOnInvalid) {
	        errors.invalidCodePoint(pos, lineStart, curLine);
	      } else {
	        return {
	          code: null,
	          pos
	        };
	      }
	    }
	  } else {
	    ({
	      code,
	      pos
	    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
	  }
	  return {
	    code,
	    pos
	  };
	}

	
	return lib$1;
}

var constants = {};

var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	Object.defineProperty(constants, "__esModule", {
	  value: true
	});
	constants.UPDATE_OPERATORS = constants.UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = constants.STATEMENT_OR_BLOCK_KEYS = constants.NUMBER_UNARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = constants.NOT_LOCAL_BINDING = constants.LOGICAL_OPERATORS = constants.INHERIT_KEYS = constants.FOR_INIT_KEYS = constants.FLATTENABLE_KEYS = constants.EQUALITY_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = constants.COMMENT_KEYS = constants.BOOLEAN_UNARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = constants.BLOCK_SCOPED_SYMBOL = constants.BINARY_OPERATORS = constants.ASSIGNMENT_OPERATORS = void 0;
	constants.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
	constants.FLATTENABLE_KEYS = ["body", "expressions"];
	constants.FOR_INIT_KEYS = ["left", "init"];
	constants.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
	const LOGICAL_OPERATORS = constants.LOGICAL_OPERATORS = ["||", "&&", "??"];
	constants.UPDATE_OPERATORS = ["++", "--"];
	const BOOLEAN_NUMBER_BINARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
	const EQUALITY_BINARY_OPERATORS = constants.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
	const COMPARISON_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
	const BOOLEAN_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
	const NUMBER_BINARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
	constants.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
	constants.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map(op => op + "="), ...LOGICAL_OPERATORS.map(op => op + "=")];
	const BOOLEAN_UNARY_OPERATORS = constants.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
	const NUMBER_UNARY_OPERATORS = constants.NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
	const STRING_UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = ["typeof"];
	constants.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
	constants.INHERIT_KEYS = {
	  optional: ["typeAnnotation", "typeParameters", "returnType"],
	  force: ["start", "loc", "end"]
	};
	constants.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
	constants.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");

	
	return constants;
}

var utils = {};

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	Object.defineProperty(utils, "__esModule", {
	  value: true
	});
	utils.VISITOR_KEYS = utils.NODE_PARENT_VALIDATIONS = utils.NODE_FIELDS = utils.FLIPPED_ALIAS_KEYS = utils.DEPRECATED_KEYS = utils.BUILDER_KEYS = utils.ALIAS_KEYS = void 0;
	utils.arrayOf = arrayOf;
	utils.arrayOfType = arrayOfType;
	utils.assertEach = assertEach;
	utils.assertNodeOrValueType = assertNodeOrValueType;
	utils.assertNodeType = assertNodeType;
	utils.assertOneOf = assertOneOf;
	utils.assertOptionalChainStart = assertOptionalChainStart;
	utils.assertShape = assertShape;
	utils.assertValueType = assertValueType;
	utils.chain = chain;
	utils.default = defineType;
	utils.defineAliasedType = defineAliasedType;
	utils.validate = validate;
	utils.validateArrayOfType = validateArrayOfType;
	utils.validateOptional = validateOptional;
	utils.validateOptionalType = validateOptionalType;
	utils.validateType = validateType;
	var _is = requireIs();
	var _validate = requireValidate();
	const VISITOR_KEYS = utils.VISITOR_KEYS = {};
	const ALIAS_KEYS = utils.ALIAS_KEYS = {};
	const FLIPPED_ALIAS_KEYS = utils.FLIPPED_ALIAS_KEYS = {};
	const NODE_FIELDS = utils.NODE_FIELDS = {};
	const BUILDER_KEYS = utils.BUILDER_KEYS = {};
	const DEPRECATED_KEYS = utils.DEPRECATED_KEYS = {};
	const NODE_PARENT_VALIDATIONS = utils.NODE_PARENT_VALIDATIONS = {};
	function getType(val) {
	  if (Array.isArray(val)) {
	    return "array";
	  } else if (val === null) {
	    return "null";
	  } else {
	    return typeof val;
	  }
	}
	function validate(validate) {
	  return {
	    validate
	  };
	}
	function validateType(...typeNames) {
	  return validate(assertNodeType(...typeNames));
	}
	function validateOptional(validate) {
	  return {
	    validate,
	    optional: true
	  };
	}
	function validateOptionalType(...typeNames) {
	  return {
	    validate: assertNodeType(...typeNames),
	    optional: true
	  };
	}
	function arrayOf(elementType) {
	  return chain(assertValueType("array"), assertEach(elementType));
	}
	function arrayOfType(...typeNames) {
	  return arrayOf(assertNodeType(...typeNames));
	}
	function validateArrayOfType(...typeNames) {
	  return validate(arrayOfType(...typeNames));
	}
	function assertEach(callback) {
	  const childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : () => {};
	  function validator(node, key, val) {
	    if (!Array.isArray(val)) return;
	    for (let i = 0; i < val.length; i++) {
	      const subkey = `${key}[${i}]`;
	      const v = val[i];
	      callback(node, subkey, v);
	      childValidator(node, subkey, v);
	    }
	  }
	  validator.each = callback;
	  return validator;
	}
	function assertOneOf(...values) {
	  function validate(node, key, val) {
	    if (!values.includes(val)) {
	      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
	    }
	  }
	  validate.oneOf = values;
	  return validate;
	}
	function assertNodeType(...types) {
	  function validate(node, key, val) {
	    for (const type of types) {
	      if ((0, _is.default)(type, val)) {
	        (0, _validate.validateChild)(node, key, val);
	        return;
	      }
	    }
	    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
	  }
	  validate.oneOfNodeTypes = types;
	  return validate;
	}
	function assertNodeOrValueType(...types) {
	  function validate(node, key, val) {
	    for (const type of types) {
	      if (getType(val) === type || (0, _is.default)(type, val)) {
	        (0, _validate.validateChild)(node, key, val);
	        return;
	      }
	    }
	    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
	  }
	  validate.oneOfNodeOrValueTypes = types;
	  return validate;
	}
	function assertValueType(type) {
	  function validate(node, key, val) {
	    const valid = getType(val) === type;
	    if (!valid) {
	      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
	    }
	  }
	  validate.type = type;
	  return validate;
	}
	function assertShape(shape) {
	  function validate(node, key, val) {
	    const errors = [];
	    for (const property of Object.keys(shape)) {
	      try {
	        (0, _validate.validateField)(node, property, val[property], shape[property]);
	      } catch (error) {
	        if (error instanceof TypeError) {
	          errors.push(error.message);
	          continue;
	        }
	        throw error;
	      }
	    }
	    if (errors.length) {
	      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
	    }
	  }
	  validate.shapeOf = shape;
	  return validate;
	}
	function assertOptionalChainStart() {
	  function validate(node) {
	    var _current;
	    let current = node;
	    while (node) {
	      const {
	        type
	      } = current;
	      if (type === "OptionalCallExpression") {
	        if (current.optional) return;
	        current = current.callee;
	        continue;
	      }
	      if (type === "OptionalMemberExpression") {
	        if (current.optional) return;
	        current = current.object;
	        continue;
	      }
	      break;
	    }
	    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
	  }
	  return validate;
	}
	function chain(...fns) {
	  function validate(...args) {
	    for (const fn of fns) {
	      fn(...args);
	    }
	  }
	  validate.chainOf = fns;
	  if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
	    throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
	  }
	  return validate;
	}
	const validTypeOpts = new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]);
	const validFieldKeys = new Set(["default", "optional", "deprecated", "validate"]);
	const store = {};
	function defineAliasedType(...aliases) {
	  return (type, opts = {}) => {
	    let defined = opts.aliases;
	    if (!defined) {
	      var _store$opts$inherits$, _defined;
	      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
	      (_defined = defined) != null ? _defined : defined = [];
	      opts.aliases = defined;
	    }
	    const additional = aliases.filter(a => !defined.includes(a));
	    defined.unshift(...additional);
	    defineType(type, opts);
	  };
	}
	function defineType(type, opts = {}) {
	  const inherits = opts.inherits && store[opts.inherits] || {};
	  let fields = opts.fields;
	  if (!fields) {
	    fields = {};
	    if (inherits.fields) {
	      const keys = Object.getOwnPropertyNames(inherits.fields);
	      for (const key of keys) {
	        const field = inherits.fields[key];
	        const def = field.default;
	        if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
	          throw new Error("field defaults can only be primitives or empty arrays currently");
	        }
	        fields[key] = {
	          default: Array.isArray(def) ? [] : def,
	          optional: field.optional,
	          deprecated: field.deprecated,
	          validate: field.validate
	        };
	      }
	    }
	  }
	  const visitor = opts.visitor || inherits.visitor || [];
	  const aliases = opts.aliases || inherits.aliases || [];
	  const builder = opts.builder || inherits.builder || opts.visitor || [];
	  for (const k of Object.keys(opts)) {
	    if (!validTypeOpts.has(k)) {
	      throw new Error(`Unknown type option "${k}" on ${type}`);
	    }
	  }
	  if (opts.deprecatedAlias) {
	    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
	  }
	  for (const key of visitor.concat(builder)) {
	    fields[key] = fields[key] || {};
	  }
	  for (const key of Object.keys(fields)) {
	    const field = fields[key];
	    if (field.default !== undefined && !builder.includes(key)) {
	      field.optional = true;
	    }
	    if (field.default === undefined) {
	      field.default = null;
	    } else if (!field.validate && field.default != null) {
	      field.validate = assertValueType(getType(field.default));
	    }
	    for (const k of Object.keys(field)) {
	      if (!validFieldKeys.has(k)) {
	        throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
	      }
	    }
	  }
	  VISITOR_KEYS[type] = opts.visitor = visitor;
	  BUILDER_KEYS[type] = opts.builder = builder;
	  NODE_FIELDS[type] = opts.fields = fields;
	  ALIAS_KEYS[type] = opts.aliases = aliases;
	  aliases.forEach(alias => {
	    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
	    FLIPPED_ALIAS_KEYS[alias].push(type);
	  });
	  if (opts.validate) {
	    NODE_PARENT_VALIDATIONS[type] = opts.validate;
	  }
	  store[type] = opts;
	}

	
	return utils;
}

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;

	Object.defineProperty(core, "__esModule", {
	  value: true
	});
	core.patternLikeCommon = core.importAttributes = core.functionTypeAnnotationCommon = core.functionDeclarationCommon = core.functionCommon = core.classMethodOrPropertyCommon = core.classMethodOrDeclareMethodCommon = void 0;
	var _is = requireIs();
	var _isValidIdentifier = requireIsValidIdentifier();
	var _helperValidatorIdentifier = requireLib$3();
	var _helperStringParser = requireLib$2();
	var _index = requireConstants();
	var _utils = requireUtils();
	const defineType = (0, _utils.defineAliasedType)("Standardized");
	defineType("ArrayExpression", {
	  fields: {
	    elements: {
	      validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
	      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
	    }
	  },
	  visitor: ["elements"],
	  aliases: ["Expression"]
	});
	defineType("AssignmentExpression", {
	  fields: {
	    operator: {
	      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("string") : Object.assign(function () {
	        const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
	        const pattern = (0, _utils.assertOneOf)("=");
	        return function (node, key, val) {
	          const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
	          validator(node, key, val);
	        };
	      }(), {
	        type: "string"
	      })
	    },
	    left: {
	      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  builder: ["operator", "left", "right"],
	  visitor: ["left", "right"],
	  aliases: ["Expression"]
	});
	defineType("BinaryExpression", {
	  builder: ["operator", "left", "right"],
	  fields: {
	    operator: {
	      validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
	    },
	    left: {
	      validate: function () {
	        const expression = (0, _utils.assertNodeType)("Expression");
	        const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
	        const validator = Object.assign(function (node, key, val) {
	          const validator = node.operator === "in" ? inOp : expression;
	          validator(node, key, val);
	        }, {
	          oneOfNodeTypes: ["Expression", "PrivateName"]
	        });
	        return validator;
	      }()
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  visitor: ["left", "right"],
	  aliases: ["Binary", "Expression"]
	});
	defineType("InterpreterDirective", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  }
	});
	defineType("Directive", {
	  visitor: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertNodeType)("DirectiveLiteral")
	    }
	  }
	});
	defineType("DirectiveLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  }
	});
	defineType("BlockStatement", {
	  builder: ["body", "directives"],
	  visitor: ["directives", "body"],
	  fields: {
	    directives: {
	      validate: (0, _utils.arrayOfType)("Directive"),
	      default: []
	    },
	    body: (0, _utils.validateArrayOfType)("Statement")
	  },
	  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
	});
	defineType("BreakStatement", {
	  visitor: ["label"],
	  fields: {
	    label: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    }
	  },
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
	});
	defineType("CallExpression", {
	  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
	  builder: ["callee", "arguments"],
	  aliases: ["Expression"],
	  fields: Object.assign({
	    callee: {
	      validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
	    },
	    arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder")
	  }, !process.env.BABEL_TYPES_8_BREAKING ? {
	    optional: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    }
	  } : {}, {
	    typeArguments: {
	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
	      optional: true
	    },
	    typeParameters: {
	      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
	      optional: true
	    }
	  })
	});
	defineType("CatchClause", {
	  visitor: ["param", "body"],
	  fields: {
	    param: {
	      validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
	      optional: true
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  },
	  aliases: ["Scopable", "BlockParent"]
	});
	defineType("ConditionalExpression", {
	  visitor: ["test", "consequent", "alternate"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    consequent: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    alternate: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  aliases: ["Expression", "Conditional"]
	});
	defineType("ContinueStatement", {
	  visitor: ["label"],
	  fields: {
	    label: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    }
	  },
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
	});
	defineType("DebuggerStatement", {
	  aliases: ["Statement"]
	});
	defineType("DoWhileStatement", {
	  builder: ["test", "body"],
	  visitor: ["body", "test"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  },
	  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
	});
	defineType("EmptyStatement", {
	  aliases: ["Statement"]
	});
	defineType("ExpressionStatement", {
	  visitor: ["expression"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  aliases: ["Statement", "ExpressionWrapper"]
	});
	defineType("File", {
	  builder: ["program", "comments", "tokens"],
	  visitor: ["program"],
	  fields: {
	    program: {
	      validate: (0, _utils.assertNodeType)("Program")
	    },
	    comments: {
	      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {
	        each: {
	          oneOfNodeTypes: ["CommentBlock", "CommentLine"]
	        }
	      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
	      optional: true
	    },
	    tokens: {
	      validate: (0, _utils.assertEach)(Object.assign(() => {}, {
	        type: "any"
	      })),
	      optional: true
	    }
	  }
	});
	defineType("ForInStatement", {
	  visitor: ["left", "right", "body"],
	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
	  fields: {
	    left: {
	      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	defineType("ForStatement", {
	  visitor: ["init", "test", "update", "body"],
	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
	  fields: {
	    init: {
	      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
	      optional: true
	    },
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    update: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	const functionCommon = () => ({
	  params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
	  generator: {
	    default: false
	  },
	  async: {
	    default: false
	  }
	});
	core.functionCommon = functionCommon;
	const functionTypeAnnotationCommon = () => ({
	  returnType: {
	    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	    optional: true
	  },
	  typeParameters: {
	    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
	    optional: true
	  }
	});
	core.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
	const functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
	  declare: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    optional: true
	  },
	  id: {
	    validate: (0, _utils.assertNodeType)("Identifier"),
	    optional: true
	  }
	});
	core.functionDeclarationCommon = functionDeclarationCommon;
	defineType("FunctionDeclaration", {
	  builder: ["id", "params", "body", "generator", "async"],
	  visitor: ["id", "typeParameters", "params", "returnType", "body"],
	  fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    },
	    predicate: {
	      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
	      optional: true
	    }
	  }),
	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
	  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
	    const identifier = (0, _utils.assertNodeType)("Identifier");
	    return function (parent, key, node) {
	      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
	        identifier(node, "id", node.id);
	      }
	    };
	  }()
	});
	defineType("FunctionExpression", {
	  inherits: "FunctionDeclaration",
	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
	  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
	    id: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    },
	    predicate: {
	      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
	      optional: true
	    }
	  })
	});
	const patternLikeCommon = () => ({
	  typeAnnotation: {
	    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	    optional: true
	  },
	  optional: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    optional: true
	  },
	  decorators: {
	    validate: (0, _utils.arrayOfType)("Decorator"),
	    optional: true
	  }
	});
	core.patternLikeCommon = patternLikeCommon;
	defineType("Identifier", {
	  builder: ["name"],
	  visitor: ["typeAnnotation", "decorators"],
	  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
	  fields: Object.assign({}, patternLikeCommon(), {
	    name: {
	      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
	        if (!(0, _isValidIdentifier.default)(val, false)) {
	          throw new TypeError(`"${val}" is not a valid identifier name`);
	        }
	      }, {
	        type: "string"
	      })) : (0, _utils.assertValueType)("string")
	    }
	  }),
	  validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key, node) {
	    const match = /\.(\w+)$/.exec(key);
	    if (!match) return;
	    const [, parentKey] = match;
	    const nonComp = {
	      computed: false
	    };
	    if (parentKey === "property") {
	      if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
	      if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
	    } else if (parentKey === "key") {
	      if ((0, _is.default)("Property", parent, nonComp)) return;
	      if ((0, _is.default)("Method", parent, nonComp)) return;
	    } else if (parentKey === "exported") {
	      if ((0, _is.default)("ExportSpecifier", parent)) return;
	    } else if (parentKey === "imported") {
	      if ((0, _is.default)("ImportSpecifier", parent, {
	        imported: node
	      })) return;
	    } else if (parentKey === "meta") {
	      if ((0, _is.default)("MetaProperty", parent, {
	        meta: node
	      })) return;
	    }
	    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
	      throw new TypeError(`"${node.name}" is not a valid identifier`);
	    }
	  } : undefined
	});
	defineType("IfStatement", {
	  visitor: ["test", "consequent", "alternate"],
	  aliases: ["Statement", "Conditional"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    consequent: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    },
	    alternate: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	defineType("LabeledStatement", {
	  visitor: ["label", "body"],
	  aliases: ["Statement"],
	  fields: {
	    label: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	defineType("StringLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	defineType("NumericLiteral", {
	  builder: ["value"],
	  deprecatedAlias: "NumberLiteral",
	  fields: {
	    value: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function (node, key, val) {
	      }, {
	        type: "number"
	      }))
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	defineType("NullLiteral", {
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	defineType("BooleanLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("boolean")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	defineType("RegExpLiteral", {
	  builder: ["pattern", "flags"],
	  deprecatedAlias: "RegexLiteral",
	  aliases: ["Expression", "Pureish", "Literal"],
	  fields: {
	    pattern: {
	      validate: (0, _utils.assertValueType)("string")
	    },
	    flags: {
	      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
	        const invalid = /[^gimsuy]/.exec(val);
	        if (invalid) {
	          throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
	        }
	      }, {
	        type: "string"
	      })) : (0, _utils.assertValueType)("string"),
	      default: ""
	    }
	  }
	});
	defineType("LogicalExpression", {
	  builder: ["operator", "left", "right"],
	  visitor: ["left", "right"],
	  aliases: ["Binary", "Expression"],
	  fields: {
	    operator: {
	      validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
	    },
	    left: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	defineType("MemberExpression", {
	  builder: ["object", "property", "computed", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : [])],
	  visitor: ["object", "property"],
	  aliases: ["Expression", "LVal"],
	  fields: Object.assign({
	    object: {
	      validate: (0, _utils.assertNodeType)("Expression", "Super")
	    },
	    property: {
	      validate: function () {
	        const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
	        const computed = (0, _utils.assertNodeType)("Expression");
	        const validator = function (node, key, val) {
	          const validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };
	        validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
	        return validator;
	      }()
	    },
	    computed: {
	      default: false
	    }
	  }, !process.env.BABEL_TYPES_8_BREAKING ? {
	    optional: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    }
	  } : {})
	});
	defineType("NewExpression", {
	  inherits: "CallExpression"
	});
	defineType("Program", {
	  visitor: ["directives", "body"],
	  builder: ["body", "directives", "sourceType", "interpreter"],
	  fields: {
	    sourceType: {
	      validate: (0, _utils.assertOneOf)("script", "module"),
	      default: "script"
	    },
	    interpreter: {
	      validate: (0, _utils.assertNodeType)("InterpreterDirective"),
	      default: null,
	      optional: true
	    },
	    directives: {
	      validate: (0, _utils.arrayOfType)("Directive"),
	      default: []
	    },
	    body: (0, _utils.validateArrayOfType)("Statement")
	  },
	  aliases: ["Scopable", "BlockParent", "Block"]
	});
	defineType("ObjectExpression", {
	  visitor: ["properties"],
	  aliases: ["Expression"],
	  fields: {
	    properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
	  }
	});
	defineType("ObjectMethod", {
	  builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
	  visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
	  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
	    kind: Object.assign({
	      validate: (0, _utils.assertOneOf)("method", "get", "set")
	    }, !process.env.BABEL_TYPES_8_BREAKING ? {
	      default: "method"
	    } : {}),
	    computed: {
	      default: false
	    },
	    key: {
	      validate: function () {
	        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
	        const computed = (0, _utils.assertNodeType)("Expression");
	        const validator = function (node, key, val) {
	          const validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };
	        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
	        return validator;
	      }()
	    },
	    decorators: {
	      validate: (0, _utils.arrayOfType)("Decorator"),
	      optional: true
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  }),
	  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
	});
	defineType("ObjectProperty", {
	  builder: ["key", "value", "computed", "shorthand", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])],
	  fields: {
	    computed: {
	      default: false
	    },
	    key: {
	      validate: function () {
	        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
	        const computed = (0, _utils.assertNodeType)("Expression");
	        const validator = Object.assign(function (node, key, val) {
	          const validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        }, {
	          oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
	        });
	        return validator;
	      }()
	    },
	    value: {
	      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
	    },
	    shorthand: {
	      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, shorthand) {
	        if (!shorthand) return;
	        if (node.computed) {
	          throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
	        }
	        if (!(0, _is.default)("Identifier", node.key)) {
	          throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
	        }
	      }, {
	        type: "boolean"
	      })) : (0, _utils.assertValueType)("boolean"),
	      default: false
	    },
	    decorators: {
	      validate: (0, _utils.arrayOfType)("Decorator"),
	      optional: true
	    }
	  },
	  visitor: ["key", "value", "decorators"],
	  aliases: ["UserWhitespacable", "Property", "ObjectMember"],
	  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
	    const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
	    const expression = (0, _utils.assertNodeType)("Expression");
	    return function (parent, key, node) {
	      const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
	      validator(node, "value", node.value);
	    };
	  }()
	});
	defineType("RestElement", {
	  visitor: ["argument", "typeAnnotation"],
	  builder: ["argument"],
	  aliases: ["LVal", "PatternLike"],
	  deprecatedAlias: "RestProperty",
	  fields: Object.assign({}, patternLikeCommon(), {
	    argument: {
	      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
	    }
	  }),
	  validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key) {
	    const match = /(\w+)\[(\d+)\]/.exec(key);
	    if (!match) throw new Error("Internal Babel error: malformed key.");
	    const [, listKey, index] = match;
	    if (parent[listKey].length > +index + 1) {
	      throw new TypeError(`RestElement must be last element of ${listKey}`);
	    }
	  } : undefined
	});
	defineType("ReturnStatement", {
	  visitor: ["argument"],
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    }
	  }
	});
	defineType("SequenceExpression", {
	  visitor: ["expressions"],
	  fields: {
	    expressions: (0, _utils.validateArrayOfType)("Expression")
	  },
	  aliases: ["Expression"]
	});
	defineType("ParenthesizedExpression", {
	  visitor: ["expression"],
	  aliases: ["Expression", "ExpressionWrapper"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	defineType("SwitchCase", {
	  visitor: ["test", "consequent"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    consequent: (0, _utils.validateArrayOfType)("Statement")
	  }
	});
	defineType("SwitchStatement", {
	  visitor: ["discriminant", "cases"],
	  aliases: ["Statement", "BlockParent", "Scopable"],
	  fields: {
	    discriminant: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    cases: (0, _utils.validateArrayOfType)("SwitchCase")
	  }
	});
	defineType("ThisExpression", {
	  aliases: ["Expression"]
	});
	defineType("ThrowStatement", {
	  visitor: ["argument"],
	  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	defineType("TryStatement", {
	  visitor: ["block", "handler", "finalizer"],
	  aliases: ["Statement"],
	  fields: {
	    block: {
	      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function (node) {
	        if (!node.handler && !node.finalizer) {
	          throw new TypeError("TryStatement expects either a handler or finalizer, or both");
	        }
	      }, {
	        oneOfNodeTypes: ["BlockStatement"]
	      })) : (0, _utils.assertNodeType)("BlockStatement")
	    },
	    handler: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("CatchClause")
	    },
	    finalizer: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  }
	});
	defineType("UnaryExpression", {
	  builder: ["operator", "argument", "prefix"],
	  fields: {
	    prefix: {
	      default: true
	    },
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    operator: {
	      validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
	    }
	  },
	  visitor: ["argument"],
	  aliases: ["UnaryLike", "Expression"]
	});
	defineType("UpdateExpression", {
	  builder: ["operator", "argument", "prefix"],
	  fields: {
	    prefix: {
	      default: false
	    },
	    argument: {
	      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
	    },
	    operator: {
	      validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
	    }
	  },
	  visitor: ["argument"],
	  aliases: ["Expression"]
	});
	defineType("VariableDeclaration", {
	  builder: ["kind", "declarations"],
	  visitor: ["declarations"],
	  aliases: ["Statement", "Declaration"],
	  fields: {
	    declare: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    kind: {
	      validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
	    },
	    declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")
	  },
	  validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
	    const withoutInit = (0, _utils.assertNodeType)("Identifier");
	    return function (parent, key, node) {
	      if ((0, _is.default)("ForXStatement", parent, {
	        left: node
	      })) {
	        if (node.declarations.length !== 1) {
	          throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
	        }
	      } else {
	        node.declarations.forEach(decl => {
	          if (!decl.init) withoutInit(decl, "id", decl.id);
	        });
	      }
	    };
	  })() : undefined
	});
	defineType("VariableDeclarator", {
	  visitor: ["id", "init"],
	  fields: {
	    id: {
	      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern")
	    },
	    definite: {
	      optional: true,
	      validate: (0, _utils.assertValueType)("boolean")
	    },
	    init: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	defineType("WhileStatement", {
	  visitor: ["test", "body"],
	  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
	  fields: {
	    test: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	defineType("WithStatement", {
	  visitor: ["object", "body"],
	  aliases: ["Statement"],
	  fields: {
	    object: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    }
	  }
	});
	defineType("AssignmentPattern", {
	  visitor: ["left", "right", "decorators"],
	  builder: ["left", "right"],
	  aliases: ["Pattern", "PatternLike", "LVal"],
	  fields: Object.assign({}, patternLikeCommon(), {
	    left: {
	      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    decorators: {
	      validate: (0, _utils.arrayOfType)("Decorator"),
	      optional: true
	    }
	  })
	});
	defineType("ArrayPattern", {
	  visitor: ["elements", "typeAnnotation"],
	  builder: ["elements"],
	  aliases: ["Pattern", "PatternLike", "LVal"],
	  fields: Object.assign({}, patternLikeCommon(), {
	    elements: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
	    }
	  })
	});
	defineType("ArrowFunctionExpression", {
	  builder: ["params", "body", "async"],
	  visitor: ["typeParameters", "params", "returnType", "body"],
	  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
	  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
	    expression: {
	      validate: (0, _utils.assertValueType)("boolean")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
	    },
	    predicate: {
	      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
	      optional: true
	    }
	  })
	});
	defineType("ClassBody", {
	  visitor: ["body"],
	  fields: {
	    body: (0, _utils.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
	  }
	});
	defineType("ClassExpression", {
	  builder: ["id", "superClass", "body", "decorators"],
	  visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
	  aliases: ["Scopable", "Class", "Expression"],
	  fields: {
	    id: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    },
	    typeParameters: {
	      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
	      optional: true
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("ClassBody")
	    },
	    superClass: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    superTypeParameters: {
	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	      optional: true
	    },
	    implements: {
	      validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
	      optional: true
	    },
	    decorators: {
	      validate: (0, _utils.arrayOfType)("Decorator"),
	      optional: true
	    },
	    mixins: {
	      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
	      optional: true
	    }
	  }
	});
	defineType("ClassDeclaration", {
	  inherits: "ClassExpression",
	  aliases: ["Scopable", "Class", "Statement", "Declaration"],
	  fields: {
	    id: {
	      validate: (0, _utils.assertNodeType)("Identifier"),
	      optional: true
	    },
	    typeParameters: {
	      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
	      optional: true
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("ClassBody")
	    },
	    superClass: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    superTypeParameters: {
	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	      optional: true
	    },
	    implements: {
	      validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
	      optional: true
	    },
	    decorators: {
	      validate: (0, _utils.arrayOfType)("Decorator"),
	      optional: true
	    },
	    mixins: {
	      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
	      optional: true
	    },
	    declare: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    abstract: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    }
	  },
	  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
	    const identifier = (0, _utils.assertNodeType)("Identifier");
	    return function (parent, key, node) {
	      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
	        identifier(node, "id", node.id);
	      }
	    };
	  }()
	});
	const importAttributes = core.importAttributes = {
	  attributes: {
	    optional: true,
	    validate: (0, _utils.arrayOfType)("ImportAttribute")
	  },
	  assertions: {
	    deprecated: true,
	    optional: true,
	    validate: (0, _utils.arrayOfType)("ImportAttribute")
	  }
	};
	defineType("ExportAllDeclaration", {
	  builder: ["source"],
	  visitor: ["source", "attributes", "assertions"],
	  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
	  fields: Object.assign({
	    source: {
	      validate: (0, _utils.assertNodeType)("StringLiteral")
	    },
	    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
	  }, importAttributes)
	});
	defineType("ExportDefaultDeclaration", {
	  visitor: ["declaration"],
	  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
	  fields: {
	    declaration: (0, _utils.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
	    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
	  }
	});
	defineType("ExportNamedDeclaration", {
	  builder: ["declaration", "specifiers", "source"],
	  visitor: process.env ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "assertions"],
	  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
	  fields: Object.assign({
	    declaration: {
	      optional: true,
	      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function (node, key, val) {
	        if (val && node.specifiers.length) {
	          throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
	        }
	        if (val && node.source) {
	          throw new TypeError("Cannot export a declaration from a source");
	        }
	      }, {
	        oneOfNodeTypes: ["Declaration"]
	      })) : (0, _utils.assertNodeType)("Declaration")
	    }
	  }, importAttributes, {
	    specifiers: {
	      default: [],
	      validate: (0, _utils.arrayOf)(function () {
	        const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
	        const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
	        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
	        return Object.assign(function (node, key, val) {
	          const validator = node.source ? sourced : sourceless;
	          validator(node, key, val);
	        }, {
	          oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
	        });
	      }())
	    },
	    source: {
	      validate: (0, _utils.assertNodeType)("StringLiteral"),
	      optional: true
	    },
	    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
	  })
	});
	defineType("ExportSpecifier", {
	  visitor: ["local", "exported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    exported: {
	      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
	    },
	    exportKind: {
	      validate: (0, _utils.assertOneOf)("type", "value"),
	      optional: true
	    }
	  }
	});
	defineType("ForOfStatement", {
	  visitor: ["left", "right", "body"],
	  builder: ["left", "right", "body", "await"],
	  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
	  fields: {
	    left: {
	      validate: function () {
	        if (!process.env.BABEL_TYPES_8_BREAKING) {
	          return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
	        }
	        const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
	        const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
	        return Object.assign(function (node, key, val) {
	          if ((0, _is.default)("VariableDeclaration", val)) {
	            declaration(node, key, val);
	          } else {
	            lval(node, key, val);
	          }
	        }, {
	          oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
	        });
	      }()
	    },
	    right: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("Statement")
	    },
	    await: {
	      default: false
	    }
	  }
	});
	defineType("ImportDeclaration", {
	  builder: ["specifiers", "source"],
	  visitor: ["specifiers", "source", "attributes", "assertions"],
	  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
	  fields: Object.assign({}, importAttributes, {
	    module: {
	      optional: true,
	      validate: (0, _utils.assertValueType)("boolean")
	    },
	    phase: {
	      default: null,
	      validate: (0, _utils.assertOneOf)("source", "defer")
	    },
	    specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
	    source: {
	      validate: (0, _utils.assertNodeType)("StringLiteral")
	    },
	    importKind: {
	      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
	      optional: true
	    }
	  })
	});
	defineType("ImportDefaultSpecifier", {
	  visitor: ["local"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	defineType("ImportNamespaceSpecifier", {
	  visitor: ["local"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	defineType("ImportSpecifier", {
	  visitor: ["imported", "local"],
	  builder: ["local", "imported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    local: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    imported: {
	      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
	    },
	    importKind: {
	      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
	      optional: true
	    }
	  }
	});
	defineType("ImportExpression", {
	  visitor: ["source", "options"],
	  aliases: ["Expression"],
	  fields: {
	    phase: {
	      default: null,
	      validate: (0, _utils.assertOneOf)("source", "defer")
	    },
	    source: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    options: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    }
	  }
	});
	defineType("MetaProperty", {
	  visitor: ["meta", "property"],
	  aliases: ["Expression"],
	  fields: {
	    meta: {
	      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function (node, key, val) {
	        let property;
	        switch (val.name) {
	          case "function":
	            property = "sent";
	            break;
	          case "new":
	            property = "target";
	            break;
	          case "import":
	            property = "meta";
	            break;
	        }
	        if (!(0, _is.default)("Identifier", node.property, {
	          name: property
	        })) {
	          throw new TypeError("Unrecognised MetaProperty");
	        }
	      }, {
	        oneOfNodeTypes: ["Identifier"]
	      })) : (0, _utils.assertNodeType)("Identifier")
	    },
	    property: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	const classMethodOrPropertyCommon = () => ({
	  abstract: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    optional: true
	  },
	  accessibility: {
	    validate: (0, _utils.assertOneOf)("public", "private", "protected"),
	    optional: true
	  },
	  static: {
	    default: false
	  },
	  override: {
	    default: false
	  },
	  computed: {
	    default: false
	  },
	  optional: {
	    validate: (0, _utils.assertValueType)("boolean"),
	    optional: true
	  },
	  key: {
	    validate: (0, _utils.chain)(function () {
	      const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
	      const computed = (0, _utils.assertNodeType)("Expression");
	      return function (node, key, val) {
	        const validator = node.computed ? computed : normal;
	        validator(node, key, val);
	      };
	    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
	  }
	});
	core.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
	const classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
	  params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
	  kind: {
	    validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
	    default: "method"
	  },
	  access: {
	    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
	    optional: true
	  },
	  decorators: {
	    validate: (0, _utils.arrayOfType)("Decorator"),
	    optional: true
	  }
	});
	core.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
	defineType("ClassMethod", {
	  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
	  builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
	  visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
	  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  })
	});
	defineType("ObjectPattern", {
	  visitor: ["properties", "typeAnnotation", "decorators"],
	  builder: ["properties"],
	  aliases: ["Pattern", "PatternLike", "LVal"],
	  fields: Object.assign({}, patternLikeCommon(), {
	    properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")
	  })
	});
	defineType("SpreadElement", {
	  visitor: ["argument"],
	  aliases: ["UnaryLike"],
	  deprecatedAlias: "SpreadProperty",
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	defineType("Super", {
	  aliases: ["Expression"]
	});
	defineType("TaggedTemplateExpression", {
	  visitor: ["tag", "typeParameters", "quasi"],
	  builder: ["tag", "quasi"],
	  aliases: ["Expression"],
	  fields: {
	    tag: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    quasi: {
	      validate: (0, _utils.assertNodeType)("TemplateLiteral")
	    },
	    typeParameters: {
	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	      optional: true
	    }
	  }
	});
	defineType("TemplateElement", {
	  builder: ["value", "tail"],
	  fields: {
	    value: {
	      validate: (0, _utils.chain)((0, _utils.assertShape)({
	        raw: {
	          validate: (0, _utils.assertValueType)("string")
	        },
	        cooked: {
	          validate: (0, _utils.assertValueType)("string"),
	          optional: true
	        }
	      }), function templateElementCookedValidator(node) {
	        const raw = node.value.raw;
	        let unterminatedCalled = false;
	        const error = () => {
	          throw new Error("Internal @babel/types error.");
	        };
	        const {
	          str,
	          firstInvalidLoc
	        } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
	          unterminated() {
	            unterminatedCalled = true;
	          },
	          strictNumericEscape: error,
	          invalidEscapeSequence: error,
	          numericSeparatorInEscapeSequence: error,
	          unexpectedNumericSeparator: error,
	          invalidDigit: error,
	          invalidCodePoint: error
	        });
	        if (!unterminatedCalled) throw new Error("Invalid raw");
	        node.value.cooked = firstInvalidLoc ? null : str;
	      })
	    },
	    tail: {
	      default: false
	    }
	  }
	});
	defineType("TemplateLiteral", {
	  visitor: ["quasis", "expressions"],
	  aliases: ["Expression", "Literal"],
	  fields: {
	    quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
	    expressions: {
	      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function (node, key, val) {
	        if (node.quasis.length !== val.length + 1) {
	          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
	        }
	      })
	    }
	  }
	});
	defineType("YieldExpression", {
	  builder: ["argument", "delegate"],
	  visitor: ["argument"],
	  aliases: ["Expression", "Terminatorless"],
	  fields: {
	    delegate: {
	      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {
	        if (val && !node.argument) {
	          throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
	        }
	      }, {
	        type: "boolean"
	      })) : (0, _utils.assertValueType)("boolean"),
	      default: false
	    },
	    argument: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	defineType("AwaitExpression", {
	  builder: ["argument"],
	  visitor: ["argument"],
	  aliases: ["Expression", "Terminatorless"],
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	defineType("Import", {
	  aliases: ["Expression"]
	});
	defineType("BigIntLiteral", {
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  },
	  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	});
	defineType("ExportNamespaceSpecifier", {
	  visitor: ["exported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    exported: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	defineType("OptionalMemberExpression", {
	  builder: ["object", "property", "computed", "optional"],
	  visitor: ["object", "property"],
	  aliases: ["Expression"],
	  fields: {
	    object: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    property: {
	      validate: function () {
	        const normal = (0, _utils.assertNodeType)("Identifier");
	        const computed = (0, _utils.assertNodeType)("Expression");
	        const validator = Object.assign(function (node, key, val) {
	          const validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        }, {
	          oneOfNodeTypes: ["Expression", "Identifier"]
	        });
	        return validator;
	      }()
	    },
	    computed: {
	      default: false
	    },
	    optional: {
	      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
	    }
	  }
	});
	defineType("OptionalCallExpression", {
	  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
	  builder: ["callee", "arguments", "optional"],
	  aliases: ["Expression"],
	  fields: {
	    callee: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
	    optional: {
	      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
	    },
	    typeArguments: {
	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
	      optional: true
	    },
	    typeParameters: {
	      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
	      optional: true
	    }
	  }
	});
	defineType("ClassProperty", {
	  visitor: ["decorators", "key", "typeAnnotation", "value"],
	  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
	  aliases: ["Property"],
	  fields: Object.assign({}, classMethodOrPropertyCommon(), {
	    value: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    definite: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    typeAnnotation: {
	      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	      optional: true
	    },
	    decorators: {
	      validate: (0, _utils.arrayOfType)("Decorator"),
	      optional: true
	    },
	    readonly: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    declare: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    variance: {
	      validate: (0, _utils.assertNodeType)("Variance"),
	      optional: true
	    }
	  })
	});
	defineType("ClassAccessorProperty", {
	  visitor: ["decorators", "key", "typeAnnotation", "value"],
	  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
	  aliases: ["Property", "Accessor"],
	  fields: Object.assign({}, classMethodOrPropertyCommon(), {
	    key: {
	      validate: (0, _utils.chain)(function () {
	        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
	        const computed = (0, _utils.assertNodeType)("Expression");
	        return function (node, key, val) {
	          const validator = node.computed ? computed : normal;
	          validator(node, key, val);
	        };
	      }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
	    },
	    value: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    definite: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    typeAnnotation: {
	      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	      optional: true
	    },
	    decorators: {
	      validate: (0, _utils.arrayOfType)("Decorator"),
	      optional: true
	    },
	    readonly: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    declare: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    variance: {
	      validate: (0, _utils.assertNodeType)("Variance"),
	      optional: true
	    }
	  })
	});
	defineType("ClassPrivateProperty", {
	  visitor: ["decorators", "key", "typeAnnotation", "value"],
	  builder: ["key", "value", "decorators", "static"],
	  aliases: ["Property", "Private"],
	  fields: {
	    key: {
	      validate: (0, _utils.assertNodeType)("PrivateName")
	    },
	    value: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    },
	    typeAnnotation: {
	      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
	      optional: true
	    },
	    decorators: {
	      validate: (0, _utils.arrayOfType)("Decorator"),
	      optional: true
	    },
	    static: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    },
	    readonly: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    definite: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    variance: {
	      validate: (0, _utils.assertNodeType)("Variance"),
	      optional: true
	    }
	  }
	});
	defineType("ClassPrivateMethod", {
	  builder: ["kind", "key", "params", "body", "static"],
	  visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
	  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
	  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
	    kind: {
	      validate: (0, _utils.assertOneOf)("get", "set", "method"),
	      default: "method"
	    },
	    key: {
	      validate: (0, _utils.assertNodeType)("PrivateName")
	    },
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    }
	  })
	});
	defineType("PrivateName", {
	  visitor: ["id"],
	  aliases: ["Private"],
	  fields: {
	    id: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	defineType("StaticBlock", {
	  visitor: ["body"],
	  fields: {
	    body: (0, _utils.validateArrayOfType)("Statement")
	  },
	  aliases: ["Scopable", "BlockParent", "FunctionParent"]
	});

	
	return core;
}

var flow = {};

var hasRequiredFlow;

function requireFlow () {
	if (hasRequiredFlow) return flow;
	hasRequiredFlow = 1;

	var _core = requireCore();
	var _utils = requireUtils();
	const defineType = (0, _utils.defineAliasedType)("Flow");
	const defineInterfaceishType = name => {
	  const isDeclareClass = name === "DeclareClass";
	  defineType(name, {
	    builder: ["id", "typeParameters", "extends", "body"],
	    visitor: ["id", "typeParameters", "extends", ...(isDeclareClass ? ["mixins", "implements"] : []), "body"],
	    aliases: ["FlowDeclaration", "Statement", "Declaration"],
	    fields: Object.assign({
	      id: (0, _utils.validateType)("Identifier"),
	      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
	    }, isDeclareClass ? {
	      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
	      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
	    } : {}, {
	      body: (0, _utils.validateType)("ObjectTypeAnnotation")
	    })
	  });
	};
	defineType("AnyTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType("ArrayTypeAnnotation", {
	  visitor: ["elementType"],
	  aliases: ["FlowType"],
	  fields: {
	    elementType: (0, _utils.validateType)("FlowType")
	  }
	});
	defineType("BooleanTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType("BooleanLiteralTypeAnnotation", {
	  builder: ["value"],
	  aliases: ["FlowType"],
	  fields: {
	    value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	defineType("NullLiteralTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType("ClassImplements", {
	  visitor: ["id", "typeParameters"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
	  }
	});
	defineInterfaceishType("DeclareClass");
	defineType("DeclareFunction", {
	  visitor: ["id"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
	  }
	});
	defineInterfaceishType("DeclareInterface");
	defineType("DeclareModule", {
	  builder: ["id", "body", "kind"],
	  visitor: ["id", "body"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier", "StringLiteral"),
	    body: (0, _utils.validateType)("BlockStatement"),
	    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
	  }
	});
	defineType("DeclareModuleExports", {
	  visitor: ["typeAnnotation"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
	  }
	});
	defineType("DeclareTypeAlias", {
	  visitor: ["id", "typeParameters", "right"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    right: (0, _utils.validateType)("FlowType")
	  }
	});
	defineType("DeclareOpaqueType", {
	  visitor: ["id", "typeParameters", "supertype"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    supertype: (0, _utils.validateOptionalType)("FlowType"),
	    impltype: (0, _utils.validateOptionalType)("FlowType")
	  }
	});
	defineType("DeclareVariable", {
	  visitor: ["id"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier")
	  }
	});
	defineType("DeclareExportDeclaration", {
	  visitor: ["declaration", "specifiers", "source", "attributes"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: Object.assign({
	    declaration: (0, _utils.validateOptionalType)("Flow"),
	    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
	    source: (0, _utils.validateOptionalType)("StringLiteral"),
	    default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
	  }, _core.importAttributes)
	});
	defineType("DeclareExportAllDeclaration", {
	  visitor: ["source", "attributes"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: Object.assign({
	    source: (0, _utils.validateType)("StringLiteral"),
	    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
	  }, _core.importAttributes)
	});
	defineType("DeclaredPredicate", {
	  visitor: ["value"],
	  aliases: ["FlowPredicate"],
	  fields: {
	    value: (0, _utils.validateType)("Flow")
	  }
	});
	defineType("ExistsTypeAnnotation", {
	  aliases: ["FlowType"]
	});
	defineType("FunctionTypeAnnotation", {
	  visitor: ["typeParameters", "params", "rest", "returnType"],
	  aliases: ["FlowType"],
	  fields: {
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    params: (0, _utils.validateArrayOfType)("FunctionTypeParam"),
	    rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
	    this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
	    returnType: (0, _utils.validateType)("FlowType")
	  }
	});
	defineType("FunctionTypeParam", {
	  visitor: ["name", "typeAnnotation"],
	  fields: {
	    name: (0, _utils.validateOptionalType)("Identifier"),
	    typeAnnotation: (0, _utils.validateType)("FlowType"),
	    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
	  }
	});
	defineType("GenericTypeAnnotation", {
	  visitor: ["id", "typeParameters"],
	  aliases: ["FlowType"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
	  }
	});
	defineType("InferredPredicate", {
	  aliases: ["FlowPredicate"]
	});
	defineType("InterfaceExtends", {
	  visitor: ["id", "typeParameters"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
	  }
	});
	defineInterfaceishType("InterfaceDeclaration");
	defineType("InterfaceTypeAnnotation", {
	  visitor: ["extends", "body"],
	  aliases: ["FlowType"],
	  fields: {
	    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
	    body: (0, _utils.validateType)("ObjectTypeAnnotation")
	  }
	});
	defineType("IntersectionTypeAnnotation", {
	  visitor: ["types"],
	  aliases: ["FlowType"],
	  fields: {
	    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
	  }
	});
	defineType("MixedTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType("EmptyTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType("NullableTypeAnnotation", {
	  visitor: ["typeAnnotation"],
	  aliases: ["FlowType"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("FlowType")
	  }
	});
	defineType("NumberLiteralTypeAnnotation", {
	  builder: ["value"],
	  aliases: ["FlowType"],
	  fields: {
	    value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
	  }
	});
	defineType("NumberTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType("ObjectTypeAnnotation", {
	  visitor: ["properties", "indexers", "callProperties", "internalSlots"],
	  aliases: ["FlowType"],
	  builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
	  fields: {
	    properties: (0, _utils.validate)((0, _utils.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
	    indexers: {
	      validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
	      optional: true,
	      default: []
	    },
	    callProperties: {
	      validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
	      optional: true,
	      default: []
	    },
	    internalSlots: {
	      validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
	      optional: true,
	      default: []
	    },
	    exact: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    },
	    inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
	  }
	});
	defineType("ObjectTypeInternalSlot", {
	  visitor: ["id", "value"],
	  builder: ["id", "value", "optional", "static", "method"],
	  aliases: ["UserWhitespacable"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    value: (0, _utils.validateType)("FlowType"),
	    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	defineType("ObjectTypeCallProperty", {
	  visitor: ["value"],
	  aliases: ["UserWhitespacable"],
	  fields: {
	    value: (0, _utils.validateType)("FlowType"),
	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	defineType("ObjectTypeIndexer", {
	  visitor: ["variance", "id", "key", "value"],
	  builder: ["id", "key", "value", "variance"],
	  aliases: ["UserWhitespacable"],
	  fields: {
	    id: (0, _utils.validateOptionalType)("Identifier"),
	    key: (0, _utils.validateType)("FlowType"),
	    value: (0, _utils.validateType)("FlowType"),
	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    variance: (0, _utils.validateOptionalType)("Variance")
	  }
	});
	defineType("ObjectTypeProperty", {
	  visitor: ["key", "value", "variance"],
	  aliases: ["UserWhitespacable"],
	  fields: {
	    key: (0, _utils.validateType)("Identifier", "StringLiteral"),
	    value: (0, _utils.validateType)("FlowType"),
	    kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
	    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    variance: (0, _utils.validateOptionalType)("Variance"),
	    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	defineType("ObjectTypeSpreadProperty", {
	  visitor: ["argument"],
	  aliases: ["UserWhitespacable"],
	  fields: {
	    argument: (0, _utils.validateType)("FlowType")
	  }
	});
	defineType("OpaqueType", {
	  visitor: ["id", "typeParameters", "supertype", "impltype"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    supertype: (0, _utils.validateOptionalType)("FlowType"),
	    impltype: (0, _utils.validateType)("FlowType")
	  }
	});
	defineType("QualifiedTypeIdentifier", {
	  visitor: ["qualification", "id"],
	  builder: ["id", "qualification"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    qualification: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier")
	  }
	});
	defineType("StringLiteralTypeAnnotation", {
	  builder: ["value"],
	  aliases: ["FlowType"],
	  fields: {
	    value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
	  }
	});
	defineType("StringTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType("SymbolTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType("ThisTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType("TupleTypeAnnotation", {
	  visitor: ["types"],
	  aliases: ["FlowType"],
	  fields: {
	    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
	  }
	});
	defineType("TypeofTypeAnnotation", {
	  visitor: ["argument"],
	  aliases: ["FlowType"],
	  fields: {
	    argument: (0, _utils.validateType)("FlowType")
	  }
	});
	defineType("TypeAlias", {
	  visitor: ["id", "typeParameters", "right"],
	  aliases: ["FlowDeclaration", "Statement", "Declaration"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
	    right: (0, _utils.validateType)("FlowType")
	  }
	});
	defineType("TypeAnnotation", {
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("FlowType")
	  }
	});
	defineType("TypeCastExpression", {
	  visitor: ["expression", "typeAnnotation"],
	  aliases: ["ExpressionWrapper", "Expression"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression"),
	    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
	  }
	});
	defineType("TypeParameter", {
	  visitor: ["bound", "default", "variance"],
	  fields: {
	    name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
	    bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
	    default: (0, _utils.validateOptionalType)("FlowType"),
	    variance: (0, _utils.validateOptionalType)("Variance")
	  }
	});
	defineType("TypeParameterDeclaration", {
	  visitor: ["params"],
	  fields: {
	    params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
	  }
	});
	defineType("TypeParameterInstantiation", {
	  visitor: ["params"],
	  fields: {
	    params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
	  }
	});
	defineType("UnionTypeAnnotation", {
	  visitor: ["types"],
	  aliases: ["FlowType"],
	  fields: {
	    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
	  }
	});
	defineType("Variance", {
	  builder: ["kind"],
	  fields: {
	    kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
	  }
	});
	defineType("VoidTypeAnnotation", {
	  aliases: ["FlowType", "FlowBaseAnnotation"]
	});
	defineType("EnumDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "body"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    body: (0, _utils.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
	  }
	});
	defineType("EnumBooleanBody", {
	  aliases: ["EnumBody"],
	  visitor: ["members"],
	  fields: {
	    explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
	    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	defineType("EnumNumberBody", {
	  aliases: ["EnumBody"],
	  visitor: ["members"],
	  fields: {
	    explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
	    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	defineType("EnumStringBody", {
	  aliases: ["EnumBody"],
	  visitor: ["members"],
	  fields: {
	    explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
	    members: (0, _utils.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
	    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	defineType("EnumSymbolBody", {
	  aliases: ["EnumBody"],
	  visitor: ["members"],
	  fields: {
	    members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
	    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});
	defineType("EnumBooleanMember", {
	  aliases: ["EnumMember"],
	  visitor: ["id"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    init: (0, _utils.validateType)("BooleanLiteral")
	  }
	});
	defineType("EnumNumberMember", {
	  aliases: ["EnumMember"],
	  visitor: ["id", "init"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    init: (0, _utils.validateType)("NumericLiteral")
	  }
	});
	defineType("EnumStringMember", {
	  aliases: ["EnumMember"],
	  visitor: ["id", "init"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier"),
	    init: (0, _utils.validateType)("StringLiteral")
	  }
	});
	defineType("EnumDefaultedMember", {
	  aliases: ["EnumMember"],
	  visitor: ["id"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier")
	  }
	});
	defineType("IndexedAccessType", {
	  visitor: ["objectType", "indexType"],
	  aliases: ["FlowType"],
	  fields: {
	    objectType: (0, _utils.validateType)("FlowType"),
	    indexType: (0, _utils.validateType)("FlowType")
	  }
	});
	defineType("OptionalIndexedAccessType", {
	  visitor: ["objectType", "indexType"],
	  aliases: ["FlowType"],
	  fields: {
	    objectType: (0, _utils.validateType)("FlowType"),
	    indexType: (0, _utils.validateType)("FlowType"),
	    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
	  }
	});

	
	return flow;
}

var jsx = {};

var hasRequiredJsx;

function requireJsx () {
	if (hasRequiredJsx) return jsx;
	hasRequiredJsx = 1;

	var _utils = requireUtils();
	const defineType = (0, _utils.defineAliasedType)("JSX");
	defineType("JSXAttribute", {
	  visitor: ["name", "value"],
	  aliases: ["Immutable"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
	    },
	    value: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
	    }
	  }
	});
	defineType("JSXClosingElement", {
	  visitor: ["name"],
	  aliases: ["Immutable"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
	    }
	  }
	});
	defineType("JSXElement", {
	  builder: ["openingElement", "closingElement", "children", "selfClosing"],
	  visitor: ["openingElement", "children", "closingElement"],
	  aliases: ["Immutable", "Expression"],
	  fields: Object.assign({
	    openingElement: {
	      validate: (0, _utils.assertNodeType)("JSXOpeningElement")
	    },
	    closingElement: {
	      optional: true,
	      validate: (0, _utils.assertNodeType)("JSXClosingElement")
	    },
	    children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
	  }, {
	    selfClosing: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    }
	  })
	});
	defineType("JSXEmptyExpression", {});
	defineType("JSXExpressionContainer", {
	  visitor: ["expression"],
	  aliases: ["Immutable"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
	    }
	  }
	});
	defineType("JSXSpreadChild", {
	  visitor: ["expression"],
	  aliases: ["Immutable"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	defineType("JSXIdentifier", {
	  builder: ["name"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  }
	});
	defineType("JSXMemberExpression", {
	  visitor: ["object", "property"],
	  fields: {
	    object: {
	      validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
	    },
	    property: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier")
	    }
	  }
	});
	defineType("JSXNamespacedName", {
	  visitor: ["namespace", "name"],
	  fields: {
	    namespace: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier")
	    },
	    name: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier")
	    }
	  }
	});
	defineType("JSXOpeningElement", {
	  builder: ["name", "attributes", "selfClosing"],
	  visitor: ["name", "attributes"],
	  aliases: ["Immutable"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
	    },
	    selfClosing: {
	      default: false
	    },
	    attributes: (0, _utils.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
	    typeParameters: {
	      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
	      optional: true
	    }
	  }
	});
	defineType("JSXSpreadAttribute", {
	  visitor: ["argument"],
	  fields: {
	    argument: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	defineType("JSXText", {
	  aliases: ["Immutable"],
	  builder: ["value"],
	  fields: {
	    value: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  }
	});
	defineType("JSXFragment", {
	  builder: ["openingFragment", "closingFragment", "children"],
	  visitor: ["openingFragment", "children", "closingFragment"],
	  aliases: ["Immutable", "Expression"],
	  fields: {
	    openingFragment: {
	      validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
	    },
	    closingFragment: {
	      validate: (0, _utils.assertNodeType)("JSXClosingFragment")
	    },
	    children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
	  }
	});
	defineType("JSXOpeningFragment", {
	  aliases: ["Immutable"]
	});
	defineType("JSXClosingFragment", {
	  aliases: ["Immutable"]
	});

	
	return jsx;
}

var misc = {};

var placeholders = {};

var hasRequiredPlaceholders;

function requirePlaceholders () {
	if (hasRequiredPlaceholders) return placeholders;
	hasRequiredPlaceholders = 1;

	Object.defineProperty(placeholders, "__esModule", {
	  value: true
	});
	placeholders.PLACEHOLDERS_FLIPPED_ALIAS = placeholders.PLACEHOLDERS_ALIAS = placeholders.PLACEHOLDERS = void 0;
	var _utils = requireUtils();
	const PLACEHOLDERS = placeholders.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
	const PLACEHOLDERS_ALIAS = placeholders.PLACEHOLDERS_ALIAS = {
	  Declaration: ["Statement"],
	  Pattern: ["PatternLike", "LVal"]
	};
	for (const type of PLACEHOLDERS) {
	  const alias = _utils.ALIAS_KEYS[type];
	  if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
	}
	const PLACEHOLDERS_FLIPPED_ALIAS = placeholders.PLACEHOLDERS_FLIPPED_ALIAS = {};
	Object.keys(PLACEHOLDERS_ALIAS).forEach(type => {
	  PLACEHOLDERS_ALIAS[type].forEach(alias => {
	    if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
	      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
	    }
	    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
	  });
	});

	
	return placeholders;
}

var hasRequiredMisc;

function requireMisc () {
	if (hasRequiredMisc) return misc;
	hasRequiredMisc = 1;

	var _utils = requireUtils();
	var _placeholders = requirePlaceholders();
	var _core = requireCore();
	const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
	{
	  defineType("Noop", {
	    visitor: []
	  });
	}
	defineType("Placeholder", {
	  visitor: [],
	  builder: ["expectedNode", "name"],
	  fields: Object.assign({
	    name: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    },
	    expectedNode: {
	      validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
	    }
	  }, (0, _core.patternLikeCommon)())
	});
	defineType("V8IntrinsicIdentifier", {
	  builder: ["name"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertValueType)("string")
	    }
	  }
	});

	
	return misc;
}

var experimental = {};

var hasRequiredExperimental;

function requireExperimental () {
	if (hasRequiredExperimental) return experimental;
	hasRequiredExperimental = 1;

	var _utils = requireUtils();
	(0, _utils.default)("ArgumentPlaceholder", {});
	(0, _utils.default)("BindExpression", {
	  visitor: ["object", "callee"],
	  aliases: ["Expression"],
	  fields: !process.env.BABEL_TYPES_8_BREAKING ? {
	    object: {
	      validate: Object.assign(() => {}, {
	        oneOfNodeTypes: ["Expression"]
	      })
	    },
	    callee: {
	      validate: Object.assign(() => {}, {
	        oneOfNodeTypes: ["Expression"]
	      })
	    }
	  } : {
	    object: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    },
	    callee: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("ImportAttribute", {
	  visitor: ["key", "value"],
	  fields: {
	    key: {
	      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
	    },
	    value: {
	      validate: (0, _utils.assertNodeType)("StringLiteral")
	    }
	  }
	});
	(0, _utils.default)("Decorator", {
	  visitor: ["expression"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  }
	});
	(0, _utils.default)("DoExpression", {
	  visitor: ["body"],
	  builder: ["body", "async"],
	  aliases: ["Expression"],
	  fields: {
	    body: {
	      validate: (0, _utils.assertNodeType)("BlockStatement")
	    },
	    async: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      default: false
	    }
	  }
	});
	(0, _utils.default)("ExportDefaultSpecifier", {
	  visitor: ["exported"],
	  aliases: ["ModuleSpecifier"],
	  fields: {
	    exported: {
	      validate: (0, _utils.assertNodeType)("Identifier")
	    }
	  }
	});
	(0, _utils.default)("RecordExpression", {
	  visitor: ["properties"],
	  aliases: ["Expression"],
	  fields: {
	    properties: (0, _utils.validateArrayOfType)("ObjectProperty", "SpreadElement")
	  }
	});
	(0, _utils.default)("TupleExpression", {
	  fields: {
	    elements: {
	      validate: (0, _utils.arrayOfType)("Expression", "SpreadElement"),
	      default: []
	    }
	  },
	  visitor: ["elements"],
	  aliases: ["Expression"]
	});
	{
	  (0, _utils.default)("DecimalLiteral", {
	    builder: ["value"],
	    fields: {
	      value: {
	        validate: (0, _utils.assertValueType)("string")
	      }
	    },
	    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
	  });
	}
	(0, _utils.default)("ModuleExpression", {
	  visitor: ["body"],
	  fields: {
	    body: {
	      validate: (0, _utils.assertNodeType)("Program")
	    }
	  },
	  aliases: ["Expression"]
	});
	(0, _utils.default)("TopicReference", {
	  aliases: ["Expression"]
	});
	(0, _utils.default)("PipelineTopicExpression", {
	  builder: ["expression"],
	  visitor: ["expression"],
	  fields: {
	    expression: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  aliases: ["Expression"]
	});
	(0, _utils.default)("PipelineBareFunction", {
	  builder: ["callee"],
	  visitor: ["callee"],
	  fields: {
	    callee: {
	      validate: (0, _utils.assertNodeType)("Expression")
	    }
	  },
	  aliases: ["Expression"]
	});
	(0, _utils.default)("PipelinePrimaryTopicReference", {
	  aliases: ["Expression"]
	});

	
	return experimental;
}

var typescript = {};

var hasRequiredTypescript;

function requireTypescript () {
	if (hasRequiredTypescript) return typescript;
	hasRequiredTypescript = 1;

	var _utils = requireUtils();
	var _core = requireCore();
	var _is = requireIs();
	const defineType = (0, _utils.defineAliasedType)("TypeScript");
	const bool = (0, _utils.assertValueType)("boolean");
	const tSFunctionTypeAnnotationCommon = () => ({
	  returnType: {
	    validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
	    optional: true
	  },
	  typeParameters: {
	    validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
	    optional: true
	  }
	});
	defineType("TSParameterProperty", {
	  aliases: ["LVal"],
	  visitor: ["parameter"],
	  fields: {
	    accessibility: {
	      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
	      optional: true
	    },
	    readonly: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    parameter: {
	      validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
	    },
	    override: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    decorators: {
	      validate: (0, _utils.arrayOfType)("Decorator"),
	      optional: true
	    }
	  }
	});
	defineType("TSDeclareFunction", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "typeParameters", "params", "returnType"],
	  fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
	});
	defineType("TSDeclareMethod", {
	  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
	  fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
	});
	defineType("TSQualifiedName", {
	  aliases: ["TSEntityName"],
	  visitor: ["left", "right"],
	  fields: {
	    left: (0, _utils.validateType)("TSEntityName"),
	    right: (0, _utils.validateType)("Identifier")
	  }
	});
	const signatureDeclarationCommon = () => ({
	  typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
	  ["parameters"]: (0, _utils.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
	  ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
	});
	const callConstructSignatureDeclaration = {
	  aliases: ["TSTypeElement"],
	  visitor: ["typeParameters", "parameters", "typeAnnotation"],
	  fields: signatureDeclarationCommon()
	};
	defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
	defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
	const namedTypeElementCommon = () => ({
	  key: (0, _utils.validateType)("Expression"),
	  computed: {
	    default: false
	  },
	  optional: (0, _utils.validateOptional)(bool)
	});
	defineType("TSPropertySignature", {
	  aliases: ["TSTypeElement"],
	  visitor: ["key", "typeAnnotation"],
	  fields: Object.assign({}, namedTypeElementCommon(), {
	    readonly: (0, _utils.validateOptional)(bool),
	    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
	    kind: {
	      validate: (0, _utils.assertOneOf)("get", "set")
	    }
	  })
	});
	defineType("TSMethodSignature", {
	  aliases: ["TSTypeElement"],
	  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
	  fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
	    kind: {
	      validate: (0, _utils.assertOneOf)("method", "get", "set")
	    }
	  })
	});
	defineType("TSIndexSignature", {
	  aliases: ["TSTypeElement"],
	  visitor: ["parameters", "typeAnnotation"],
	  fields: {
	    readonly: (0, _utils.validateOptional)(bool),
	    static: (0, _utils.validateOptional)(bool),
	    parameters: (0, _utils.validateArrayOfType)("Identifier"),
	    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
	  }
	});
	const tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
	for (const type of tsKeywordTypes) {
	  defineType(type, {
	    aliases: ["TSType", "TSBaseType"],
	    visitor: [],
	    fields: {}
	  });
	}
	defineType("TSThisType", {
	  aliases: ["TSType", "TSBaseType"],
	  visitor: [],
	  fields: {}
	});
	const fnOrCtrBase = {
	  aliases: ["TSType"],
	  visitor: ["typeParameters", "parameters", "typeAnnotation"]
	};
	defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
	  fields: signatureDeclarationCommon()
	}));
	defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
	  fields: Object.assign({}, signatureDeclarationCommon(), {
	    abstract: (0, _utils.validateOptional)(bool)
	  })
	}));
	defineType("TSTypeReference", {
	  aliases: ["TSType"],
	  visitor: ["typeName", "typeParameters"],
	  fields: {
	    typeName: (0, _utils.validateType)("TSEntityName"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
	  }
	});
	defineType("TSTypePredicate", {
	  aliases: ["TSType"],
	  visitor: ["parameterName", "typeAnnotation"],
	  builder: ["parameterName", "typeAnnotation", "asserts"],
	  fields: {
	    parameterName: (0, _utils.validateType)("Identifier", "TSThisType"),
	    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
	    asserts: (0, _utils.validateOptional)(bool)
	  }
	});
	defineType("TSTypeQuery", {
	  aliases: ["TSType"],
	  visitor: ["exprName", "typeParameters"],
	  fields: {
	    exprName: (0, _utils.validateType)("TSEntityName", "TSImportType"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
	  }
	});
	defineType("TSTypeLiteral", {
	  aliases: ["TSType"],
	  visitor: ["members"],
	  fields: {
	    members: (0, _utils.validateArrayOfType)("TSTypeElement")
	  }
	});
	defineType("TSArrayType", {
	  aliases: ["TSType"],
	  visitor: ["elementType"],
	  fields: {
	    elementType: (0, _utils.validateType)("TSType")
	  }
	});
	defineType("TSTupleType", {
	  aliases: ["TSType"],
	  visitor: ["elementTypes"],
	  fields: {
	    elementTypes: (0, _utils.validateArrayOfType)("TSType", "TSNamedTupleMember")
	  }
	});
	defineType("TSOptionalType", {
	  aliases: ["TSType"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	defineType("TSRestType", {
	  aliases: ["TSType"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	defineType("TSNamedTupleMember", {
	  visitor: ["label", "elementType"],
	  builder: ["label", "elementType", "optional"],
	  fields: {
	    label: (0, _utils.validateType)("Identifier"),
	    optional: {
	      validate: bool,
	      default: false
	    },
	    elementType: (0, _utils.validateType)("TSType")
	  }
	});
	const unionOrIntersection = {
	  aliases: ["TSType"],
	  visitor: ["types"],
	  fields: {
	    types: (0, _utils.validateArrayOfType)("TSType")
	  }
	};
	defineType("TSUnionType", unionOrIntersection);
	defineType("TSIntersectionType", unionOrIntersection);
	defineType("TSConditionalType", {
	  aliases: ["TSType"],
	  visitor: ["checkType", "extendsType", "trueType", "falseType"],
	  fields: {
	    checkType: (0, _utils.validateType)("TSType"),
	    extendsType: (0, _utils.validateType)("TSType"),
	    trueType: (0, _utils.validateType)("TSType"),
	    falseType: (0, _utils.validateType)("TSType")
	  }
	});
	defineType("TSInferType", {
	  aliases: ["TSType"],
	  visitor: ["typeParameter"],
	  fields: {
	    typeParameter: (0, _utils.validateType)("TSTypeParameter")
	  }
	});
	defineType("TSParenthesizedType", {
	  aliases: ["TSType"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	defineType("TSTypeOperator", {
	  aliases: ["TSType"],
	  visitor: ["typeAnnotation"],
	  fields: {
	    operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	defineType("TSIndexedAccessType", {
	  aliases: ["TSType"],
	  visitor: ["objectType", "indexType"],
	  fields: {
	    objectType: (0, _utils.validateType)("TSType"),
	    indexType: (0, _utils.validateType)("TSType")
	  }
	});
	defineType("TSMappedType", {
	  aliases: ["TSType"],
	  visitor: ["typeParameter", "nameType", "typeAnnotation"],
	  builder: ["typeParameter", "typeAnnotation", "nameType"],
	  fields: Object.assign({}, {
	    typeParameter: (0, _utils.validateType)("TSTypeParameter")
	  }, {
	    readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
	    optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
	    typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
	    nameType: (0, _utils.validateOptionalType)("TSType")
	  })
	});
	defineType("TSLiteralType", {
	  aliases: ["TSType", "TSBaseType"],
	  visitor: ["literal"],
	  fields: {
	    literal: {
	      validate: function () {
	        const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
	        const unaryOperator = (0, _utils.assertOneOf)("-");
	        const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
	        function validator(parent, key, node) {
	          if ((0, _is.default)("UnaryExpression", node)) {
	            unaryOperator(node, "operator", node.operator);
	            unaryExpression(node, "argument", node.argument);
	          } else {
	            literal(parent, key, node);
	          }
	        }
	        validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
	        return validator;
	      }()
	    }
	  }
	});
	const expressionWithTypeArguments = {
	  aliases: ["TSType"],
	  visitor: ["expression", "typeParameters"],
	  fields: {
	    expression: (0, _utils.validateType)("TSEntityName"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
	  }
	};
	{
	  defineType("TSExpressionWithTypeArguments", expressionWithTypeArguments);
	}
	defineType("TSInterfaceDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "typeParameters", "extends", "body"],
	  fields: {
	    declare: (0, _utils.validateOptional)(bool),
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
	    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
	    body: (0, _utils.validateType)("TSInterfaceBody")
	  }
	});
	defineType("TSInterfaceBody", {
	  visitor: ["body"],
	  fields: {
	    body: (0, _utils.validateArrayOfType)("TSTypeElement")
	  }
	});
	defineType("TSTypeAliasDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "typeParameters", "typeAnnotation"],
	  fields: {
	    declare: (0, _utils.validateOptional)(bool),
	    id: (0, _utils.validateType)("Identifier"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	});
	defineType("TSInstantiationExpression", {
	  aliases: ["Expression"],
	  visitor: ["expression", "typeParameters"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
	  }
	});
	const TSTypeExpression = {
	  aliases: ["Expression", "LVal", "PatternLike"],
	  visitor: ["expression", "typeAnnotation"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression"),
	    typeAnnotation: (0, _utils.validateType)("TSType")
	  }
	};
	defineType("TSAsExpression", TSTypeExpression);
	defineType("TSSatisfiesExpression", TSTypeExpression);
	defineType("TSTypeAssertion", {
	  aliases: ["Expression", "LVal", "PatternLike"],
	  visitor: ["typeAnnotation", "expression"],
	  fields: {
	    typeAnnotation: (0, _utils.validateType)("TSType"),
	    expression: (0, _utils.validateType)("Expression")
	  }
	});
	defineType("TSEnumDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "members"],
	  fields: {
	    declare: (0, _utils.validateOptional)(bool),
	    const: (0, _utils.validateOptional)(bool),
	    id: (0, _utils.validateType)("Identifier"),
	    members: (0, _utils.validateArrayOfType)("TSEnumMember"),
	    initializer: (0, _utils.validateOptionalType)("Expression")
	  }
	});
	defineType("TSEnumMember", {
	  visitor: ["id", "initializer"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier", "StringLiteral"),
	    initializer: (0, _utils.validateOptionalType)("Expression")
	  }
	});
	defineType("TSModuleDeclaration", {
	  aliases: ["Statement", "Declaration"],
	  visitor: ["id", "body"],
	  fields: Object.assign({
	    kind: {
	      validate: (0, _utils.assertOneOf)("global", "module", "namespace")
	    },
	    declare: (0, _utils.validateOptional)(bool)
	  }, {
	    global: (0, _utils.validateOptional)(bool)
	  }, {
	    id: (0, _utils.validateType)("Identifier", "StringLiteral"),
	    body: (0, _utils.validateType)("TSModuleBlock", "TSModuleDeclaration")
	  })
	});
	defineType("TSModuleBlock", {
	  aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
	  visitor: ["body"],
	  fields: {
	    body: (0, _utils.validateArrayOfType)("Statement")
	  }
	});
	defineType("TSImportType", {
	  aliases: ["TSType"],
	  visitor: ["argument", "qualifier", "typeParameters"],
	  fields: {
	    argument: (0, _utils.validateType)("StringLiteral"),
	    qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
	    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation"),
	    options: {
	      validate: (0, _utils.assertNodeType)("Expression"),
	      optional: true
	    }
	  }
	});
	defineType("TSImportEqualsDeclaration", {
	  aliases: ["Statement"],
	  visitor: ["id", "moduleReference"],
	  fields: {
	    isExport: (0, _utils.validate)(bool),
	    id: (0, _utils.validateType)("Identifier"),
	    moduleReference: (0, _utils.validateType)("TSEntityName", "TSExternalModuleReference"),
	    importKind: {
	      validate: (0, _utils.assertOneOf)("type", "value"),
	      optional: true
	    }
	  }
	});
	defineType("TSExternalModuleReference", {
	  visitor: ["expression"],
	  fields: {
	    expression: (0, _utils.validateType)("StringLiteral")
	  }
	});
	defineType("TSNonNullExpression", {
	  aliases: ["Expression", "LVal", "PatternLike"],
	  visitor: ["expression"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression")
	  }
	});
	defineType("TSExportAssignment", {
	  aliases: ["Statement"],
	  visitor: ["expression"],
	  fields: {
	    expression: (0, _utils.validateType)("Expression")
	  }
	});
	defineType("TSNamespaceExportDeclaration", {
	  aliases: ["Statement"],
	  visitor: ["id"],
	  fields: {
	    id: (0, _utils.validateType)("Identifier")
	  }
	});
	defineType("TSTypeAnnotation", {
	  visitor: ["typeAnnotation"],
	  fields: {
	    typeAnnotation: {
	      validate: (0, _utils.assertNodeType)("TSType")
	    }
	  }
	});
	defineType("TSTypeParameterInstantiation", {
	  visitor: ["params"],
	  fields: {
	    params: (0, _utils.validateArrayOfType)("TSType")
	  }
	});
	defineType("TSTypeParameterDeclaration", {
	  visitor: ["params"],
	  fields: {
	    params: (0, _utils.validateArrayOfType)("TSTypeParameter")
	  }
	});
	defineType("TSTypeParameter", {
	  builder: ["constraint", "default", "name"],
	  visitor: ["constraint", "default"],
	  fields: {
	    name: {
	      validate: (0, _utils.assertValueType)("string")
	    },
	    in: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    out: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    const: {
	      validate: (0, _utils.assertValueType)("boolean"),
	      optional: true
	    },
	    constraint: {
	      validate: (0, _utils.assertNodeType)("TSType"),
	      optional: true
	    },
	    default: {
	      validate: (0, _utils.assertNodeType)("TSType"),
	      optional: true
	    }
	  }
	});

	
	return typescript;
}

var deprecatedAliases = {};

var hasRequiredDeprecatedAliases;

function requireDeprecatedAliases () {
	if (hasRequiredDeprecatedAliases) return deprecatedAliases;
	hasRequiredDeprecatedAliases = 1;

	Object.defineProperty(deprecatedAliases, "__esModule", {
	  value: true
	});
	deprecatedAliases.DEPRECATED_ALIASES = void 0;
	deprecatedAliases.DEPRECATED_ALIASES = {
	  ModuleDeclaration: "ImportOrExportDeclaration"
	};

	
	return deprecatedAliases;
}

var hasRequiredDefinitions;

function requireDefinitions () {
	if (hasRequiredDefinitions) return definitions;
	hasRequiredDefinitions = 1;
	(function (exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports, "ALIAS_KEYS", {
		  enumerable: true,
		  get: function () {
		    return _utils.ALIAS_KEYS;
		  }
		});
		Object.defineProperty(exports, "BUILDER_KEYS", {
		  enumerable: true,
		  get: function () {
		    return _utils.BUILDER_KEYS;
		  }
		});
		Object.defineProperty(exports, "DEPRECATED_ALIASES", {
		  enumerable: true,
		  get: function () {
		    return _deprecatedAliases.DEPRECATED_ALIASES;
		  }
		});
		Object.defineProperty(exports, "DEPRECATED_KEYS", {
		  enumerable: true,
		  get: function () {
		    return _utils.DEPRECATED_KEYS;
		  }
		});
		Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
		  enumerable: true,
		  get: function () {
		    return _utils.FLIPPED_ALIAS_KEYS;
		  }
		});
		Object.defineProperty(exports, "NODE_FIELDS", {
		  enumerable: true,
		  get: function () {
		    return _utils.NODE_FIELDS;
		  }
		});
		Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
		  enumerable: true,
		  get: function () {
		    return _utils.NODE_PARENT_VALIDATIONS;
		  }
		});
		Object.defineProperty(exports, "PLACEHOLDERS", {
		  enumerable: true,
		  get: function () {
		    return _placeholders.PLACEHOLDERS;
		  }
		});
		Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
		  enumerable: true,
		  get: function () {
		    return _placeholders.PLACEHOLDERS_ALIAS;
		  }
		});
		Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
		  enumerable: true,
		  get: function () {
		    return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
		  }
		});
		exports.TYPES = void 0;
		Object.defineProperty(exports, "VISITOR_KEYS", {
		  enumerable: true,
		  get: function () {
		    return _utils.VISITOR_KEYS;
		  }
		});
		requireCore();
		requireFlow();
		requireJsx();
		requireMisc();
		requireExperimental();
		requireTypescript();
		var _utils = requireUtils();
		var _placeholders = requirePlaceholders();
		var _deprecatedAliases = requireDeprecatedAliases();
		Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach(deprecatedAlias => {
		  _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
		});
		exports.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));

		
} (definitions));
	return definitions;
}

var hasRequiredValidate;

function requireValidate () {
	if (hasRequiredValidate) return validate$1;
	hasRequiredValidate = 1;

	Object.defineProperty(validate$1, "__esModule", {
	  value: true
	});
	validate$1.default = validate;
	validate$1.validateChild = validateChild;
	validate$1.validateField = validateField;
	validate$1.validateInternal = validateInternal;
	var _index = requireDefinitions();
	function validate(node, key, val) {
	  if (!node) return;
	  const fields = _index.NODE_FIELDS[node.type];
	  if (!fields) return;
	  const field = fields[key];
	  validateField(node, key, val, field);
	  validateChild(node, key, val);
	}
	function validateInternal(field, node, key, val, maybeNode) {
	  if (!(field != null && field.validate)) return;
	  if (field.optional && val == null) return;
	  field.validate(node, key, val);
	  if (maybeNode) {
	    var _NODE_PARENT_VALIDATI;
	    const type = val.type;
	    if (type == null) return;
	    (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);
	  }
	}
	function validateField(node, key, val, field) {
	  if (!(field != null && field.validate)) return;
	  if (field.optional && val == null) return;
	  field.validate(node, key, val);
	}
	function validateChild(node, key, val) {
	  var _NODE_PARENT_VALIDATI2;
	  const type = val == null ? void 0 : val.type;
	  if (type == null) return;
	  (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);
	}

	
	return validate$1;
}

var hasRequiredGenerated$2;

function requireGenerated$2 () {
	if (hasRequiredGenerated$2) return generated$2;
	hasRequiredGenerated$2 = 1;

	Object.defineProperty(generated$2, "__esModule", {
	  value: true
	});
	generated$2.anyTypeAnnotation = anyTypeAnnotation;
	generated$2.argumentPlaceholder = argumentPlaceholder;
	generated$2.arrayExpression = arrayExpression;
	generated$2.arrayPattern = arrayPattern;
	generated$2.arrayTypeAnnotation = arrayTypeAnnotation;
	generated$2.arrowFunctionExpression = arrowFunctionExpression;
	generated$2.assignmentExpression = assignmentExpression;
	generated$2.assignmentPattern = assignmentPattern;
	generated$2.awaitExpression = awaitExpression;
	generated$2.bigIntLiteral = bigIntLiteral;
	generated$2.binaryExpression = binaryExpression;
	generated$2.bindExpression = bindExpression;
	generated$2.blockStatement = blockStatement;
	generated$2.booleanLiteral = booleanLiteral;
	generated$2.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
	generated$2.booleanTypeAnnotation = booleanTypeAnnotation;
	generated$2.breakStatement = breakStatement;
	generated$2.callExpression = callExpression;
	generated$2.catchClause = catchClause;
	generated$2.classAccessorProperty = classAccessorProperty;
	generated$2.classBody = classBody;
	generated$2.classDeclaration = classDeclaration;
	generated$2.classExpression = classExpression;
	generated$2.classImplements = classImplements;
	generated$2.classMethod = classMethod;
	generated$2.classPrivateMethod = classPrivateMethod;
	generated$2.classPrivateProperty = classPrivateProperty;
	generated$2.classProperty = classProperty;
	generated$2.conditionalExpression = conditionalExpression;
	generated$2.continueStatement = continueStatement;
	generated$2.debuggerStatement = debuggerStatement;
	generated$2.decimalLiteral = decimalLiteral;
	generated$2.declareClass = declareClass;
	generated$2.declareExportAllDeclaration = declareExportAllDeclaration;
	generated$2.declareExportDeclaration = declareExportDeclaration;
	generated$2.declareFunction = declareFunction;
	generated$2.declareInterface = declareInterface;
	generated$2.declareModule = declareModule;
	generated$2.declareModuleExports = declareModuleExports;
	generated$2.declareOpaqueType = declareOpaqueType;
	generated$2.declareTypeAlias = declareTypeAlias;
	generated$2.declareVariable = declareVariable;
	generated$2.declaredPredicate = declaredPredicate;
	generated$2.decorator = decorator;
	generated$2.directive = directive;
	generated$2.directiveLiteral = directiveLiteral;
	generated$2.doExpression = doExpression;
	generated$2.doWhileStatement = doWhileStatement;
	generated$2.emptyStatement = emptyStatement;
	generated$2.emptyTypeAnnotation = emptyTypeAnnotation;
	generated$2.enumBooleanBody = enumBooleanBody;
	generated$2.enumBooleanMember = enumBooleanMember;
	generated$2.enumDeclaration = enumDeclaration;
	generated$2.enumDefaultedMember = enumDefaultedMember;
	generated$2.enumNumberBody = enumNumberBody;
	generated$2.enumNumberMember = enumNumberMember;
	generated$2.enumStringBody = enumStringBody;
	generated$2.enumStringMember = enumStringMember;
	generated$2.enumSymbolBody = enumSymbolBody;
	generated$2.existsTypeAnnotation = existsTypeAnnotation;
	generated$2.exportAllDeclaration = exportAllDeclaration;
	generated$2.exportDefaultDeclaration = exportDefaultDeclaration;
	generated$2.exportDefaultSpecifier = exportDefaultSpecifier;
	generated$2.exportNamedDeclaration = exportNamedDeclaration;
	generated$2.exportNamespaceSpecifier = exportNamespaceSpecifier;
	generated$2.exportSpecifier = exportSpecifier;
	generated$2.expressionStatement = expressionStatement;
	generated$2.file = file;
	generated$2.forInStatement = forInStatement;
	generated$2.forOfStatement = forOfStatement;
	generated$2.forStatement = forStatement;
	generated$2.functionDeclaration = functionDeclaration;
	generated$2.functionExpression = functionExpression;
	generated$2.functionTypeAnnotation = functionTypeAnnotation;
	generated$2.functionTypeParam = functionTypeParam;
	generated$2.genericTypeAnnotation = genericTypeAnnotation;
	generated$2.identifier = identifier;
	generated$2.ifStatement = ifStatement;
	generated$2.import = _import;
	generated$2.importAttribute = importAttribute;
	generated$2.importDeclaration = importDeclaration;
	generated$2.importDefaultSpecifier = importDefaultSpecifier;
	generated$2.importExpression = importExpression;
	generated$2.importNamespaceSpecifier = importNamespaceSpecifier;
	generated$2.importSpecifier = importSpecifier;
	generated$2.indexedAccessType = indexedAccessType;
	generated$2.inferredPredicate = inferredPredicate;
	generated$2.interfaceDeclaration = interfaceDeclaration;
	generated$2.interfaceExtends = interfaceExtends;
	generated$2.interfaceTypeAnnotation = interfaceTypeAnnotation;
	generated$2.interpreterDirective = interpreterDirective;
	generated$2.intersectionTypeAnnotation = intersectionTypeAnnotation;
	generated$2.jSXAttribute = generated$2.jsxAttribute = jsxAttribute;
	generated$2.jSXClosingElement = generated$2.jsxClosingElement = jsxClosingElement;
	generated$2.jSXClosingFragment = generated$2.jsxClosingFragment = jsxClosingFragment;
	generated$2.jSXElement = generated$2.jsxElement = jsxElement;
	generated$2.jSXEmptyExpression = generated$2.jsxEmptyExpression = jsxEmptyExpression;
	generated$2.jSXExpressionContainer = generated$2.jsxExpressionContainer = jsxExpressionContainer;
	generated$2.jSXFragment = generated$2.jsxFragment = jsxFragment;
	generated$2.jSXIdentifier = generated$2.jsxIdentifier = jsxIdentifier;
	generated$2.jSXMemberExpression = generated$2.jsxMemberExpression = jsxMemberExpression;
	generated$2.jSXNamespacedName = generated$2.jsxNamespacedName = jsxNamespacedName;
	generated$2.jSXOpeningElement = generated$2.jsxOpeningElement = jsxOpeningElement;
	generated$2.jSXOpeningFragment = generated$2.jsxOpeningFragment = jsxOpeningFragment;
	generated$2.jSXSpreadAttribute = generated$2.jsxSpreadAttribute = jsxSpreadAttribute;
	generated$2.jSXSpreadChild = generated$2.jsxSpreadChild = jsxSpreadChild;
	generated$2.jSXText = generated$2.jsxText = jsxText;
	generated$2.labeledStatement = labeledStatement;
	generated$2.logicalExpression = logicalExpression;
	generated$2.memberExpression = memberExpression;
	generated$2.metaProperty = metaProperty;
	generated$2.mixedTypeAnnotation = mixedTypeAnnotation;
	generated$2.moduleExpression = moduleExpression;
	generated$2.newExpression = newExpression;
	generated$2.noop = noop;
	generated$2.nullLiteral = nullLiteral;
	generated$2.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
	generated$2.nullableTypeAnnotation = nullableTypeAnnotation;
	generated$2.numberLiteral = NumberLiteral;
	generated$2.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
	generated$2.numberTypeAnnotation = numberTypeAnnotation;
	generated$2.numericLiteral = numericLiteral;
	generated$2.objectExpression = objectExpression;
	generated$2.objectMethod = objectMethod;
	generated$2.objectPattern = objectPattern;
	generated$2.objectProperty = objectProperty;
	generated$2.objectTypeAnnotation = objectTypeAnnotation;
	generated$2.objectTypeCallProperty = objectTypeCallProperty;
	generated$2.objectTypeIndexer = objectTypeIndexer;
	generated$2.objectTypeInternalSlot = objectTypeInternalSlot;
	generated$2.objectTypeProperty = objectTypeProperty;
	generated$2.objectTypeSpreadProperty = objectTypeSpreadProperty;
	generated$2.opaqueType = opaqueType;
	generated$2.optionalCallExpression = optionalCallExpression;
	generated$2.optionalIndexedAccessType = optionalIndexedAccessType;
	generated$2.optionalMemberExpression = optionalMemberExpression;
	generated$2.parenthesizedExpression = parenthesizedExpression;
	generated$2.pipelineBareFunction = pipelineBareFunction;
	generated$2.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
	generated$2.pipelineTopicExpression = pipelineTopicExpression;
	generated$2.placeholder = placeholder;
	generated$2.privateName = privateName;
	generated$2.program = program;
	generated$2.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
	generated$2.recordExpression = recordExpression;
	generated$2.regExpLiteral = regExpLiteral;
	generated$2.regexLiteral = RegexLiteral;
	generated$2.restElement = restElement;
	generated$2.restProperty = RestProperty;
	generated$2.returnStatement = returnStatement;
	generated$2.sequenceExpression = sequenceExpression;
	generated$2.spreadElement = spreadElement;
	generated$2.spreadProperty = SpreadProperty;
	generated$2.staticBlock = staticBlock;
	generated$2.stringLiteral = stringLiteral;
	generated$2.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
	generated$2.stringTypeAnnotation = stringTypeAnnotation;
	generated$2.super = _super;
	generated$2.switchCase = switchCase;
	generated$2.switchStatement = switchStatement;
	generated$2.symbolTypeAnnotation = symbolTypeAnnotation;
	generated$2.taggedTemplateExpression = taggedTemplateExpression;
	generated$2.templateElement = templateElement;
	generated$2.templateLiteral = templateLiteral;
	generated$2.thisExpression = thisExpression;
	generated$2.thisTypeAnnotation = thisTypeAnnotation;
	generated$2.throwStatement = throwStatement;
	generated$2.topicReference = topicReference;
	generated$2.tryStatement = tryStatement;
	generated$2.tSAnyKeyword = generated$2.tsAnyKeyword = tsAnyKeyword;
	generated$2.tSArrayType = generated$2.tsArrayType = tsArrayType;
	generated$2.tSAsExpression = generated$2.tsAsExpression = tsAsExpression;
	generated$2.tSBigIntKeyword = generated$2.tsBigIntKeyword = tsBigIntKeyword;
	generated$2.tSBooleanKeyword = generated$2.tsBooleanKeyword = tsBooleanKeyword;
	generated$2.tSCallSignatureDeclaration = generated$2.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
	generated$2.tSConditionalType = generated$2.tsConditionalType = tsConditionalType;
	generated$2.tSConstructSignatureDeclaration = generated$2.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
	generated$2.tSConstructorType = generated$2.tsConstructorType = tsConstructorType;
	generated$2.tSDeclareFunction = generated$2.tsDeclareFunction = tsDeclareFunction;
	generated$2.tSDeclareMethod = generated$2.tsDeclareMethod = tsDeclareMethod;
	generated$2.tSEnumDeclaration = generated$2.tsEnumDeclaration = tsEnumDeclaration;
	generated$2.tSEnumMember = generated$2.tsEnumMember = tsEnumMember;
	generated$2.tSExportAssignment = generated$2.tsExportAssignment = tsExportAssignment;
	generated$2.tSExpressionWithTypeArguments = generated$2.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
	generated$2.tSExternalModuleReference = generated$2.tsExternalModuleReference = tsExternalModuleReference;
	generated$2.tSFunctionType = generated$2.tsFunctionType = tsFunctionType;
	generated$2.tSImportEqualsDeclaration = generated$2.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
	generated$2.tSImportType = generated$2.tsImportType = tsImportType;
	generated$2.tSIndexSignature = generated$2.tsIndexSignature = tsIndexSignature;
	generated$2.tSIndexedAccessType = generated$2.tsIndexedAccessType = tsIndexedAccessType;
	generated$2.tSInferType = generated$2.tsInferType = tsInferType;
	generated$2.tSInstantiationExpression = generated$2.tsInstantiationExpression = tsInstantiationExpression;
	generated$2.tSInterfaceBody = generated$2.tsInterfaceBody = tsInterfaceBody;
	generated$2.tSInterfaceDeclaration = generated$2.tsInterfaceDeclaration = tsInterfaceDeclaration;
	generated$2.tSIntersectionType = generated$2.tsIntersectionType = tsIntersectionType;
	generated$2.tSIntrinsicKeyword = generated$2.tsIntrinsicKeyword = tsIntrinsicKeyword;
	generated$2.tSLiteralType = generated$2.tsLiteralType = tsLiteralType;
	generated$2.tSMappedType = generated$2.tsMappedType = tsMappedType;
	generated$2.tSMethodSignature = generated$2.tsMethodSignature = tsMethodSignature;
	generated$2.tSModuleBlock = generated$2.tsModuleBlock = tsModuleBlock;
	generated$2.tSModuleDeclaration = generated$2.tsModuleDeclaration = tsModuleDeclaration;
	generated$2.tSNamedTupleMember = generated$2.tsNamedTupleMember = tsNamedTupleMember;
	generated$2.tSNamespaceExportDeclaration = generated$2.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
	generated$2.tSNeverKeyword = generated$2.tsNeverKeyword = tsNeverKeyword;
	generated$2.tSNonNullExpression = generated$2.tsNonNullExpression = tsNonNullExpression;
	generated$2.tSNullKeyword = generated$2.tsNullKeyword = tsNullKeyword;
	generated$2.tSNumberKeyword = generated$2.tsNumberKeyword = tsNumberKeyword;
	generated$2.tSObjectKeyword = generated$2.tsObjectKeyword = tsObjectKeyword;
	generated$2.tSOptionalType = generated$2.tsOptionalType = tsOptionalType;
	generated$2.tSParameterProperty = generated$2.tsParameterProperty = tsParameterProperty;
	generated$2.tSParenthesizedType = generated$2.tsParenthesizedType = tsParenthesizedType;
	generated$2.tSPropertySignature = generated$2.tsPropertySignature = tsPropertySignature;
	generated$2.tSQualifiedName = generated$2.tsQualifiedName = tsQualifiedName;
	generated$2.tSRestType = generated$2.tsRestType = tsRestType;
	generated$2.tSSatisfiesExpression = generated$2.tsSatisfiesExpression = tsSatisfiesExpression;
	generated$2.tSStringKeyword = generated$2.tsStringKeyword = tsStringKeyword;
	generated$2.tSSymbolKeyword = generated$2.tsSymbolKeyword = tsSymbolKeyword;
	generated$2.tSThisType = generated$2.tsThisType = tsThisType;
	generated$2.tSTupleType = generated$2.tsTupleType = tsTupleType;
	generated$2.tSTypeAliasDeclaration = generated$2.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
	generated$2.tSTypeAnnotation = generated$2.tsTypeAnnotation = tsTypeAnnotation;
	generated$2.tSTypeAssertion = generated$2.tsTypeAssertion = tsTypeAssertion;
	generated$2.tSTypeLiteral = generated$2.tsTypeLiteral = tsTypeLiteral;
	generated$2.tSTypeOperator = generated$2.tsTypeOperator = tsTypeOperator;
	generated$2.tSTypeParameter = generated$2.tsTypeParameter = tsTypeParameter;
	generated$2.tSTypeParameterDeclaration = generated$2.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
	generated$2.tSTypeParameterInstantiation = generated$2.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
	generated$2.tSTypePredicate = generated$2.tsTypePredicate = tsTypePredicate;
	generated$2.tSTypeQuery = generated$2.tsTypeQuery = tsTypeQuery;
	generated$2.tSTypeReference = generated$2.tsTypeReference = tsTypeReference;
	generated$2.tSUndefinedKeyword = generated$2.tsUndefinedKeyword = tsUndefinedKeyword;
	generated$2.tSUnionType = generated$2.tsUnionType = tsUnionType;
	generated$2.tSUnknownKeyword = generated$2.tsUnknownKeyword = tsUnknownKeyword;
	generated$2.tSVoidKeyword = generated$2.tsVoidKeyword = tsVoidKeyword;
	generated$2.tupleExpression = tupleExpression;
	generated$2.tupleTypeAnnotation = tupleTypeAnnotation;
	generated$2.typeAlias = typeAlias;
	generated$2.typeAnnotation = typeAnnotation;
	generated$2.typeCastExpression = typeCastExpression;
	generated$2.typeParameter = typeParameter;
	generated$2.typeParameterDeclaration = typeParameterDeclaration;
	generated$2.typeParameterInstantiation = typeParameterInstantiation;
	generated$2.typeofTypeAnnotation = typeofTypeAnnotation;
	generated$2.unaryExpression = unaryExpression;
	generated$2.unionTypeAnnotation = unionTypeAnnotation;
	generated$2.updateExpression = updateExpression;
	generated$2.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
	generated$2.variableDeclaration = variableDeclaration;
	generated$2.variableDeclarator = variableDeclarator;
	generated$2.variance = variance;
	generated$2.voidTypeAnnotation = voidTypeAnnotation;
	generated$2.whileStatement = whileStatement;
	generated$2.withStatement = withStatement;
	generated$2.yieldExpression = yieldExpression;
	var _validate = requireValidate();
	var _deprecationWarning = requireDeprecationWarning();
	var utils = requireUtils();
	const {
	  validateInternal: validate
	} = _validate;
	const {
	  NODE_FIELDS
	} = utils;
	function arrayExpression(elements = []) {
	  const node = {
	    type: "ArrayExpression",
	    elements
	  };
	  const defs = NODE_FIELDS.ArrayExpression;
	  validate(defs.elements, node, "elements", elements, 1);
	  return node;
	}
	function assignmentExpression(operator, left, right) {
	  const node = {
	    type: "AssignmentExpression",
	    operator,
	    left,
	    right
	  };
	  const defs = NODE_FIELDS.AssignmentExpression;
	  validate(defs.operator, node, "operator", operator);
	  validate(defs.left, node, "left", left, 1);
	  validate(defs.right, node, "right", right, 1);
	  return node;
	}
	function binaryExpression(operator, left, right) {
	  const node = {
	    type: "BinaryExpression",
	    operator,
	    left,
	    right
	  };
	  const defs = NODE_FIELDS.BinaryExpression;
	  validate(defs.operator, node, "operator", operator);
	  validate(defs.left, node, "left", left, 1);
	  validate(defs.right, node, "right", right, 1);
	  return node;
	}
	function interpreterDirective(value) {
	  const node = {
	    type: "InterpreterDirective",
	    value
	  };
	  const defs = NODE_FIELDS.InterpreterDirective;
	  validate(defs.value, node, "value", value);
	  return node;
	}
	function directive(value) {
	  const node = {
	    type: "Directive",
	    value
	  };
	  const defs = NODE_FIELDS.Directive;
	  validate(defs.value, node, "value", value, 1);
	  return node;
	}
	function directiveLiteral(value) {
	  const node = {
	    type: "DirectiveLiteral",
	    value
	  };
	  const defs = NODE_FIELDS.DirectiveLiteral;
	  validate(defs.value, node, "value", value);
	  return node;
	}
	function blockStatement(body, directives = []) {
	  const node = {
	    type: "BlockStatement",
	    body,
	    directives
	  };
	  const defs = NODE_FIELDS.BlockStatement;
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.directives, node, "directives", directives, 1);
	  return node;
	}
	function breakStatement(label = null) {
	  const node = {
	    type: "BreakStatement",
	    label
	  };
	  const defs = NODE_FIELDS.BreakStatement;
	  validate(defs.label, node, "label", label, 1);
	  return node;
	}
	function callExpression(callee, _arguments) {
	  const node = {
	    type: "CallExpression",
	    callee,
	    arguments: _arguments
	  };
	  const defs = NODE_FIELDS.CallExpression;
	  validate(defs.callee, node, "callee", callee, 1);
	  validate(defs.arguments, node, "arguments", _arguments, 1);
	  return node;
	}
	function catchClause(param = null, body) {
	  const node = {
	    type: "CatchClause",
	    param,
	    body
	  };
	  const defs = NODE_FIELDS.CatchClause;
	  validate(defs.param, node, "param", param, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function conditionalExpression(test, consequent, alternate) {
	  const node = {
	    type: "ConditionalExpression",
	    test,
	    consequent,
	    alternate
	  };
	  const defs = NODE_FIELDS.ConditionalExpression;
	  validate(defs.test, node, "test", test, 1);
	  validate(defs.consequent, node, "consequent", consequent, 1);
	  validate(defs.alternate, node, "alternate", alternate, 1);
	  return node;
	}
	function continueStatement(label = null) {
	  const node = {
	    type: "ContinueStatement",
	    label
	  };
	  const defs = NODE_FIELDS.ContinueStatement;
	  validate(defs.label, node, "label", label, 1);
	  return node;
	}
	function debuggerStatement() {
	  return {
	    type: "DebuggerStatement"
	  };
	}
	function doWhileStatement(test, body) {
	  const node = {
	    type: "DoWhileStatement",
	    test,
	    body
	  };
	  const defs = NODE_FIELDS.DoWhileStatement;
	  validate(defs.test, node, "test", test, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function emptyStatement() {
	  return {
	    type: "EmptyStatement"
	  };
	}
	function expressionStatement(expression) {
	  const node = {
	    type: "ExpressionStatement",
	    expression
	  };
	  const defs = NODE_FIELDS.ExpressionStatement;
	  validate(defs.expression, node, "expression", expression, 1);
	  return node;
	}
	function file(program, comments = null, tokens = null) {
	  const node = {
	    type: "File",
	    program,
	    comments,
	    tokens
	  };
	  const defs = NODE_FIELDS.File;
	  validate(defs.program, node, "program", program, 1);
	  validate(defs.comments, node, "comments", comments, 1);
	  validate(defs.tokens, node, "tokens", tokens);
	  return node;
	}
	function forInStatement(left, right, body) {
	  const node = {
	    type: "ForInStatement",
	    left,
	    right,
	    body
	  };
	  const defs = NODE_FIELDS.ForInStatement;
	  validate(defs.left, node, "left", left, 1);
	  validate(defs.right, node, "right", right, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function forStatement(init = null, test = null, update = null, body) {
	  const node = {
	    type: "ForStatement",
	    init,
	    test,
	    update,
	    body
	  };
	  const defs = NODE_FIELDS.ForStatement;
	  validate(defs.init, node, "init", init, 1);
	  validate(defs.test, node, "test", test, 1);
	  validate(defs.update, node, "update", update, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function functionDeclaration(id = null, params, body, generator = false, async = false) {
	  const node = {
	    type: "FunctionDeclaration",
	    id,
	    params,
	    body,
	    generator,
	    async
	  };
	  const defs = NODE_FIELDS.FunctionDeclaration;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.params, node, "params", params, 1);
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.generator, node, "generator", generator);
	  validate(defs.async, node, "async", async);
	  return node;
	}
	function functionExpression(id = null, params, body, generator = false, async = false) {
	  const node = {
	    type: "FunctionExpression",
	    id,
	    params,
	    body,
	    generator,
	    async
	  };
	  const defs = NODE_FIELDS.FunctionExpression;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.params, node, "params", params, 1);
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.generator, node, "generator", generator);
	  validate(defs.async, node, "async", async);
	  return node;
	}
	function identifier(name) {
	  const node = {
	    type: "Identifier",
	    name
	  };
	  const defs = NODE_FIELDS.Identifier;
	  validate(defs.name, node, "name", name);
	  return node;
	}
	function ifStatement(test, consequent, alternate = null) {
	  const node = {
	    type: "IfStatement",
	    test,
	    consequent,
	    alternate
	  };
	  const defs = NODE_FIELDS.IfStatement;
	  validate(defs.test, node, "test", test, 1);
	  validate(defs.consequent, node, "consequent", consequent, 1);
	  validate(defs.alternate, node, "alternate", alternate, 1);
	  return node;
	}
	function labeledStatement(label, body) {
	  const node = {
	    type: "LabeledStatement",
	    label,
	    body
	  };
	  const defs = NODE_FIELDS.LabeledStatement;
	  validate(defs.label, node, "label", label, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function stringLiteral(value) {
	  const node = {
	    type: "StringLiteral",
	    value
	  };
	  const defs = NODE_FIELDS.StringLiteral;
	  validate(defs.value, node, "value", value);
	  return node;
	}
	function numericLiteral(value) {
	  const node = {
	    type: "NumericLiteral",
	    value
	  };
	  const defs = NODE_FIELDS.NumericLiteral;
	  validate(defs.value, node, "value", value);
	  return node;
	}
	function nullLiteral() {
	  return {
	    type: "NullLiteral"
	  };
	}
	function booleanLiteral(value) {
	  const node = {
	    type: "BooleanLiteral",
	    value
	  };
	  const defs = NODE_FIELDS.BooleanLiteral;
	  validate(defs.value, node, "value", value);
	  return node;
	}
	function regExpLiteral(pattern, flags = "") {
	  const node = {
	    type: "RegExpLiteral",
	    pattern,
	    flags
	  };
	  const defs = NODE_FIELDS.RegExpLiteral;
	  validate(defs.pattern, node, "pattern", pattern);
	  validate(defs.flags, node, "flags", flags);
	  return node;
	}
	function logicalExpression(operator, left, right) {
	  const node = {
	    type: "LogicalExpression",
	    operator,
	    left,
	    right
	  };
	  const defs = NODE_FIELDS.LogicalExpression;
	  validate(defs.operator, node, "operator", operator);
	  validate(defs.left, node, "left", left, 1);
	  validate(defs.right, node, "right", right, 1);
	  return node;
	}
	function memberExpression(object, property, computed = false, optional = null) {
	  const node = {
	    type: "MemberExpression",
	    object,
	    property,
	    computed,
	    optional
	  };
	  const defs = NODE_FIELDS.MemberExpression;
	  validate(defs.object, node, "object", object, 1);
	  validate(defs.property, node, "property", property, 1);
	  validate(defs.computed, node, "computed", computed);
	  validate(defs.optional, node, "optional", optional);
	  return node;
	}
	function newExpression(callee, _arguments) {
	  const node = {
	    type: "NewExpression",
	    callee,
	    arguments: _arguments
	  };
	  const defs = NODE_FIELDS.NewExpression;
	  validate(defs.callee, node, "callee", callee, 1);
	  validate(defs.arguments, node, "arguments", _arguments, 1);
	  return node;
	}
	function program(body, directives = [], sourceType = "script", interpreter = null) {
	  const node = {
	    type: "Program",
	    body,
	    directives,
	    sourceType,
	    interpreter
	  };
	  const defs = NODE_FIELDS.Program;
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.directives, node, "directives", directives, 1);
	  validate(defs.sourceType, node, "sourceType", sourceType);
	  validate(defs.interpreter, node, "interpreter", interpreter, 1);
	  return node;
	}
	function objectExpression(properties) {
	  const node = {
	    type: "ObjectExpression",
	    properties
	  };
	  const defs = NODE_FIELDS.ObjectExpression;
	  validate(defs.properties, node, "properties", properties, 1);
	  return node;
	}
	function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {
	  const node = {
	    type: "ObjectMethod",
	    kind,
	    key,
	    params,
	    body,
	    computed,
	    generator,
	    async
	  };
	  const defs = NODE_FIELDS.ObjectMethod;
	  validate(defs.kind, node, "kind", kind);
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.params, node, "params", params, 1);
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.computed, node, "computed", computed);
	  validate(defs.generator, node, "generator", generator);
	  validate(defs.async, node, "async", async);
	  return node;
	}
	function objectProperty(key, value, computed = false, shorthand = false, decorators = null) {
	  const node = {
	    type: "ObjectProperty",
	    key,
	    value,
	    computed,
	    shorthand,
	    decorators
	  };
	  const defs = NODE_FIELDS.ObjectProperty;
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.value, node, "value", value, 1);
	  validate(defs.computed, node, "computed", computed);
	  validate(defs.shorthand, node, "shorthand", shorthand);
	  validate(defs.decorators, node, "decorators", decorators, 1);
	  return node;
	}
	function restElement(argument) {
	  const node = {
	    type: "RestElement",
	    argument
	  };
	  const defs = NODE_FIELDS.RestElement;
	  validate(defs.argument, node, "argument", argument, 1);
	  return node;
	}
	function returnStatement(argument = null) {
	  const node = {
	    type: "ReturnStatement",
	    argument
	  };
	  const defs = NODE_FIELDS.ReturnStatement;
	  validate(defs.argument, node, "argument", argument, 1);
	  return node;
	}
	function sequenceExpression(expressions) {
	  const node = {
	    type: "SequenceExpression",
	    expressions
	  };
	  const defs = NODE_FIELDS.SequenceExpression;
	  validate(defs.expressions, node, "expressions", expressions, 1);
	  return node;
	}
	function parenthesizedExpression(expression) {
	  const node = {
	    type: "ParenthesizedExpression",
	    expression
	  };
	  const defs = NODE_FIELDS.ParenthesizedExpression;
	  validate(defs.expression, node, "expression", expression, 1);
	  return node;
	}
	function switchCase(test = null, consequent) {
	  const node = {
	    type: "SwitchCase",
	    test,
	    consequent
	  };
	  const defs = NODE_FIELDS.SwitchCase;
	  validate(defs.test, node, "test", test, 1);
	  validate(defs.consequent, node, "consequent", consequent, 1);
	  return node;
	}
	function switchStatement(discriminant, cases) {
	  const node = {
	    type: "SwitchStatement",
	    discriminant,
	    cases
	  };
	  const defs = NODE_FIELDS.SwitchStatement;
	  validate(defs.discriminant, node, "discriminant", discriminant, 1);
	  validate(defs.cases, node, "cases", cases, 1);
	  return node;
	}
	function thisExpression() {
	  return {
	    type: "ThisExpression"
	  };
	}
	function throwStatement(argument) {
	  const node = {
	    type: "ThrowStatement",
	    argument
	  };
	  const defs = NODE_FIELDS.ThrowStatement;
	  validate(defs.argument, node, "argument", argument, 1);
	  return node;
	}
	function tryStatement(block, handler = null, finalizer = null) {
	  const node = {
	    type: "TryStatement",
	    block,
	    handler,
	    finalizer
	  };
	  const defs = NODE_FIELDS.TryStatement;
	  validate(defs.block, node, "block", block, 1);
	  validate(defs.handler, node, "handler", handler, 1);
	  validate(defs.finalizer, node, "finalizer", finalizer, 1);
	  return node;
	}
	function unaryExpression(operator, argument, prefix = true) {
	  const node = {
	    type: "UnaryExpression",
	    operator,
	    argument,
	    prefix
	  };
	  const defs = NODE_FIELDS.UnaryExpression;
	  validate(defs.operator, node, "operator", operator);
	  validate(defs.argument, node, "argument", argument, 1);
	  validate(defs.prefix, node, "prefix", prefix);
	  return node;
	}
	function updateExpression(operator, argument, prefix = false) {
	  const node = {
	    type: "UpdateExpression",
	    operator,
	    argument,
	    prefix
	  };
	  const defs = NODE_FIELDS.UpdateExpression;
	  validate(defs.operator, node, "operator", operator);
	  validate(defs.argument, node, "argument", argument, 1);
	  validate(defs.prefix, node, "prefix", prefix);
	  return node;
	}
	function variableDeclaration(kind, declarations) {
	  const node = {
	    type: "VariableDeclaration",
	    kind,
	    declarations
	  };
	  const defs = NODE_FIELDS.VariableDeclaration;
	  validate(defs.kind, node, "kind", kind);
	  validate(defs.declarations, node, "declarations", declarations, 1);
	  return node;
	}
	function variableDeclarator(id, init = null) {
	  const node = {
	    type: "VariableDeclarator",
	    id,
	    init
	  };
	  const defs = NODE_FIELDS.VariableDeclarator;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.init, node, "init", init, 1);
	  return node;
	}
	function whileStatement(test, body) {
	  const node = {
	    type: "WhileStatement",
	    test,
	    body
	  };
	  const defs = NODE_FIELDS.WhileStatement;
	  validate(defs.test, node, "test", test, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function withStatement(object, body) {
	  const node = {
	    type: "WithStatement",
	    object,
	    body
	  };
	  const defs = NODE_FIELDS.WithStatement;
	  validate(defs.object, node, "object", object, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function assignmentPattern(left, right) {
	  const node = {
	    type: "AssignmentPattern",
	    left,
	    right
	  };
	  const defs = NODE_FIELDS.AssignmentPattern;
	  validate(defs.left, node, "left", left, 1);
	  validate(defs.right, node, "right", right, 1);
	  return node;
	}
	function arrayPattern(elements) {
	  const node = {
	    type: "ArrayPattern",
	    elements
	  };
	  const defs = NODE_FIELDS.ArrayPattern;
	  validate(defs.elements, node, "elements", elements, 1);
	  return node;
	}
	function arrowFunctionExpression(params, body, async = false) {
	  const node = {
	    type: "ArrowFunctionExpression",
	    params,
	    body,
	    async,
	    expression: null
	  };
	  const defs = NODE_FIELDS.ArrowFunctionExpression;
	  validate(defs.params, node, "params", params, 1);
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.async, node, "async", async);
	  return node;
	}
	function classBody(body) {
	  const node = {
	    type: "ClassBody",
	    body
	  };
	  const defs = NODE_FIELDS.ClassBody;
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function classExpression(id = null, superClass = null, body, decorators = null) {
	  const node = {
	    type: "ClassExpression",
	    id,
	    superClass,
	    body,
	    decorators
	  };
	  const defs = NODE_FIELDS.ClassExpression;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.superClass, node, "superClass", superClass, 1);
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.decorators, node, "decorators", decorators, 1);
	  return node;
	}
	function classDeclaration(id = null, superClass = null, body, decorators = null) {
	  const node = {
	    type: "ClassDeclaration",
	    id,
	    superClass,
	    body,
	    decorators
	  };
	  const defs = NODE_FIELDS.ClassDeclaration;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.superClass, node, "superClass", superClass, 1);
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.decorators, node, "decorators", decorators, 1);
	  return node;
	}
	function exportAllDeclaration(source) {
	  const node = {
	    type: "ExportAllDeclaration",
	    source
	  };
	  const defs = NODE_FIELDS.ExportAllDeclaration;
	  validate(defs.source, node, "source", source, 1);
	  return node;
	}
	function exportDefaultDeclaration(declaration) {
	  const node = {
	    type: "ExportDefaultDeclaration",
	    declaration
	  };
	  const defs = NODE_FIELDS.ExportDefaultDeclaration;
	  validate(defs.declaration, node, "declaration", declaration, 1);
	  return node;
	}
	function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
	  const node = {
	    type: "ExportNamedDeclaration",
	    declaration,
	    specifiers,
	    source
	  };
	  const defs = NODE_FIELDS.ExportNamedDeclaration;
	  validate(defs.declaration, node, "declaration", declaration, 1);
	  validate(defs.specifiers, node, "specifiers", specifiers, 1);
	  validate(defs.source, node, "source", source, 1);
	  return node;
	}
	function exportSpecifier(local, exported) {
	  const node = {
	    type: "ExportSpecifier",
	    local,
	    exported
	  };
	  const defs = NODE_FIELDS.ExportSpecifier;
	  validate(defs.local, node, "local", local, 1);
	  validate(defs.exported, node, "exported", exported, 1);
	  return node;
	}
	function forOfStatement(left, right, body, _await = false) {
	  const node = {
	    type: "ForOfStatement",
	    left,
	    right,
	    body,
	    await: _await
	  };
	  const defs = NODE_FIELDS.ForOfStatement;
	  validate(defs.left, node, "left", left, 1);
	  validate(defs.right, node, "right", right, 1);
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.await, node, "await", _await);
	  return node;
	}
	function importDeclaration(specifiers, source) {
	  const node = {
	    type: "ImportDeclaration",
	    specifiers,
	    source
	  };
	  const defs = NODE_FIELDS.ImportDeclaration;
	  validate(defs.specifiers, node, "specifiers", specifiers, 1);
	  validate(defs.source, node, "source", source, 1);
	  return node;
	}
	function importDefaultSpecifier(local) {
	  const node = {
	    type: "ImportDefaultSpecifier",
	    local
	  };
	  const defs = NODE_FIELDS.ImportDefaultSpecifier;
	  validate(defs.local, node, "local", local, 1);
	  return node;
	}
	function importNamespaceSpecifier(local) {
	  const node = {
	    type: "ImportNamespaceSpecifier",
	    local
	  };
	  const defs = NODE_FIELDS.ImportNamespaceSpecifier;
	  validate(defs.local, node, "local", local, 1);
	  return node;
	}
	function importSpecifier(local, imported) {
	  const node = {
	    type: "ImportSpecifier",
	    local,
	    imported
	  };
	  const defs = NODE_FIELDS.ImportSpecifier;
	  validate(defs.local, node, "local", local, 1);
	  validate(defs.imported, node, "imported", imported, 1);
	  return node;
	}
	function importExpression(source, options = null) {
	  const node = {
	    type: "ImportExpression",
	    source,
	    options
	  };
	  const defs = NODE_FIELDS.ImportExpression;
	  validate(defs.source, node, "source", source, 1);
	  validate(defs.options, node, "options", options, 1);
	  return node;
	}
	function metaProperty(meta, property) {
	  const node = {
	    type: "MetaProperty",
	    meta,
	    property
	  };
	  const defs = NODE_FIELDS.MetaProperty;
	  validate(defs.meta, node, "meta", meta, 1);
	  validate(defs.property, node, "property", property, 1);
	  return node;
	}
	function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {
	  const node = {
	    type: "ClassMethod",
	    kind,
	    key,
	    params,
	    body,
	    computed,
	    static: _static,
	    generator,
	    async
	  };
	  const defs = NODE_FIELDS.ClassMethod;
	  validate(defs.kind, node, "kind", kind);
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.params, node, "params", params, 1);
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.computed, node, "computed", computed);
	  validate(defs.static, node, "static", _static);
	  validate(defs.generator, node, "generator", generator);
	  validate(defs.async, node, "async", async);
	  return node;
	}
	function objectPattern(properties) {
	  const node = {
	    type: "ObjectPattern",
	    properties
	  };
	  const defs = NODE_FIELDS.ObjectPattern;
	  validate(defs.properties, node, "properties", properties, 1);
	  return node;
	}
	function spreadElement(argument) {
	  const node = {
	    type: "SpreadElement",
	    argument
	  };
	  const defs = NODE_FIELDS.SpreadElement;
	  validate(defs.argument, node, "argument", argument, 1);
	  return node;
	}
	function _super() {
	  return {
	    type: "Super"
	  };
	}
	function taggedTemplateExpression(tag, quasi) {
	  const node = {
	    type: "TaggedTemplateExpression",
	    tag,
	    quasi
	  };
	  const defs = NODE_FIELDS.TaggedTemplateExpression;
	  validate(defs.tag, node, "tag", tag, 1);
	  validate(defs.quasi, node, "quasi", quasi, 1);
	  return node;
	}
	function templateElement(value, tail = false) {
	  const node = {
	    type: "TemplateElement",
	    value,
	    tail
	  };
	  const defs = NODE_FIELDS.TemplateElement;
	  validate(defs.value, node, "value", value);
	  validate(defs.tail, node, "tail", tail);
	  return node;
	}
	function templateLiteral(quasis, expressions) {
	  const node = {
	    type: "TemplateLiteral",
	    quasis,
	    expressions
	  };
	  const defs = NODE_FIELDS.TemplateLiteral;
	  validate(defs.quasis, node, "quasis", quasis, 1);
	  validate(defs.expressions, node, "expressions", expressions, 1);
	  return node;
	}
	function yieldExpression(argument = null, delegate = false) {
	  const node = {
	    type: "YieldExpression",
	    argument,
	    delegate
	  };
	  const defs = NODE_FIELDS.YieldExpression;
	  validate(defs.argument, node, "argument", argument, 1);
	  validate(defs.delegate, node, "delegate", delegate);
	  return node;
	}
	function awaitExpression(argument) {
	  const node = {
	    type: "AwaitExpression",
	    argument
	  };
	  const defs = NODE_FIELDS.AwaitExpression;
	  validate(defs.argument, node, "argument", argument, 1);
	  return node;
	}
	function _import() {
	  return {
	    type: "Import"
	  };
	}
	function bigIntLiteral(value) {
	  const node = {
	    type: "BigIntLiteral",
	    value
	  };
	  const defs = NODE_FIELDS.BigIntLiteral;
	  validate(defs.value, node, "value", value);
	  return node;
	}
	function exportNamespaceSpecifier(exported) {
	  const node = {
	    type: "ExportNamespaceSpecifier",
	    exported
	  };
	  const defs = NODE_FIELDS.ExportNamespaceSpecifier;
	  validate(defs.exported, node, "exported", exported, 1);
	  return node;
	}
	function optionalMemberExpression(object, property, computed = false, optional) {
	  const node = {
	    type: "OptionalMemberExpression",
	    object,
	    property,
	    computed,
	    optional
	  };
	  const defs = NODE_FIELDS.OptionalMemberExpression;
	  validate(defs.object, node, "object", object, 1);
	  validate(defs.property, node, "property", property, 1);
	  validate(defs.computed, node, "computed", computed);
	  validate(defs.optional, node, "optional", optional);
	  return node;
	}
	function optionalCallExpression(callee, _arguments, optional) {
	  const node = {
	    type: "OptionalCallExpression",
	    callee,
	    arguments: _arguments,
	    optional
	  };
	  const defs = NODE_FIELDS.OptionalCallExpression;
	  validate(defs.callee, node, "callee", callee, 1);
	  validate(defs.arguments, node, "arguments", _arguments, 1);
	  validate(defs.optional, node, "optional", optional);
	  return node;
	}
	function classProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
	  const node = {
	    type: "ClassProperty",
	    key,
	    value,
	    typeAnnotation,
	    decorators,
	    computed,
	    static: _static
	  };
	  const defs = NODE_FIELDS.ClassProperty;
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.value, node, "value", value, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  validate(defs.decorators, node, "decorators", decorators, 1);
	  validate(defs.computed, node, "computed", computed);
	  validate(defs.static, node, "static", _static);
	  return node;
	}
	function classAccessorProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {
	  const node = {
	    type: "ClassAccessorProperty",
	    key,
	    value,
	    typeAnnotation,
	    decorators,
	    computed,
	    static: _static
	  };
	  const defs = NODE_FIELDS.ClassAccessorProperty;
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.value, node, "value", value, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  validate(defs.decorators, node, "decorators", decorators, 1);
	  validate(defs.computed, node, "computed", computed);
	  validate(defs.static, node, "static", _static);
	  return node;
	}
	function classPrivateProperty(key, value = null, decorators = null, _static = false) {
	  const node = {
	    type: "ClassPrivateProperty",
	    key,
	    value,
	    decorators,
	    static: _static
	  };
	  const defs = NODE_FIELDS.ClassPrivateProperty;
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.value, node, "value", value, 1);
	  validate(defs.decorators, node, "decorators", decorators, 1);
	  validate(defs.static, node, "static", _static);
	  return node;
	}
	function classPrivateMethod(kind = "method", key, params, body, _static = false) {
	  const node = {
	    type: "ClassPrivateMethod",
	    kind,
	    key,
	    params,
	    body,
	    static: _static
	  };
	  const defs = NODE_FIELDS.ClassPrivateMethod;
	  validate(defs.kind, node, "kind", kind);
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.params, node, "params", params, 1);
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.static, node, "static", _static);
	  return node;
	}
	function privateName(id) {
	  const node = {
	    type: "PrivateName",
	    id
	  };
	  const defs = NODE_FIELDS.PrivateName;
	  validate(defs.id, node, "id", id, 1);
	  return node;
	}
	function staticBlock(body) {
	  const node = {
	    type: "StaticBlock",
	    body
	  };
	  const defs = NODE_FIELDS.StaticBlock;
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function anyTypeAnnotation() {
	  return {
	    type: "AnyTypeAnnotation"
	  };
	}
	function arrayTypeAnnotation(elementType) {
	  const node = {
	    type: "ArrayTypeAnnotation",
	    elementType
	  };
	  const defs = NODE_FIELDS.ArrayTypeAnnotation;
	  validate(defs.elementType, node, "elementType", elementType, 1);
	  return node;
	}
	function booleanTypeAnnotation() {
	  return {
	    type: "BooleanTypeAnnotation"
	  };
	}
	function booleanLiteralTypeAnnotation(value) {
	  const node = {
	    type: "BooleanLiteralTypeAnnotation",
	    value
	  };
	  const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
	  validate(defs.value, node, "value", value);
	  return node;
	}
	function nullLiteralTypeAnnotation() {
	  return {
	    type: "NullLiteralTypeAnnotation"
	  };
	}
	function classImplements(id, typeParameters = null) {
	  const node = {
	    type: "ClassImplements",
	    id,
	    typeParameters
	  };
	  const defs = NODE_FIELDS.ClassImplements;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  return node;
	}
	function declareClass(id, typeParameters = null, _extends = null, body) {
	  const node = {
	    type: "DeclareClass",
	    id,
	    typeParameters,
	    extends: _extends,
	    body
	  };
	  const defs = NODE_FIELDS.DeclareClass;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.extends, node, "extends", _extends, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function declareFunction(id) {
	  const node = {
	    type: "DeclareFunction",
	    id
	  };
	  const defs = NODE_FIELDS.DeclareFunction;
	  validate(defs.id, node, "id", id, 1);
	  return node;
	}
	function declareInterface(id, typeParameters = null, _extends = null, body) {
	  const node = {
	    type: "DeclareInterface",
	    id,
	    typeParameters,
	    extends: _extends,
	    body
	  };
	  const defs = NODE_FIELDS.DeclareInterface;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.extends, node, "extends", _extends, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function declareModule(id, body, kind = null) {
	  const node = {
	    type: "DeclareModule",
	    id,
	    body,
	    kind
	  };
	  const defs = NODE_FIELDS.DeclareModule;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.kind, node, "kind", kind);
	  return node;
	}
	function declareModuleExports(typeAnnotation) {
	  const node = {
	    type: "DeclareModuleExports",
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.DeclareModuleExports;
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function declareTypeAlias(id, typeParameters = null, right) {
	  const node = {
	    type: "DeclareTypeAlias",
	    id,
	    typeParameters,
	    right
	  };
	  const defs = NODE_FIELDS.DeclareTypeAlias;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.right, node, "right", right, 1);
	  return node;
	}
	function declareOpaqueType(id, typeParameters = null, supertype = null) {
	  const node = {
	    type: "DeclareOpaqueType",
	    id,
	    typeParameters,
	    supertype
	  };
	  const defs = NODE_FIELDS.DeclareOpaqueType;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.supertype, node, "supertype", supertype, 1);
	  return node;
	}
	function declareVariable(id) {
	  const node = {
	    type: "DeclareVariable",
	    id
	  };
	  const defs = NODE_FIELDS.DeclareVariable;
	  validate(defs.id, node, "id", id, 1);
	  return node;
	}
	function declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {
	  const node = {
	    type: "DeclareExportDeclaration",
	    declaration,
	    specifiers,
	    source,
	    attributes
	  };
	  const defs = NODE_FIELDS.DeclareExportDeclaration;
	  validate(defs.declaration, node, "declaration", declaration, 1);
	  validate(defs.specifiers, node, "specifiers", specifiers, 1);
	  validate(defs.source, node, "source", source, 1);
	  validate(defs.attributes, node, "attributes", attributes, 1);
	  return node;
	}
	function declareExportAllDeclaration(source, attributes = null) {
	  const node = {
	    type: "DeclareExportAllDeclaration",
	    source,
	    attributes
	  };
	  const defs = NODE_FIELDS.DeclareExportAllDeclaration;
	  validate(defs.source, node, "source", source, 1);
	  validate(defs.attributes, node, "attributes", attributes, 1);
	  return node;
	}
	function declaredPredicate(value) {
	  const node = {
	    type: "DeclaredPredicate",
	    value
	  };
	  const defs = NODE_FIELDS.DeclaredPredicate;
	  validate(defs.value, node, "value", value, 1);
	  return node;
	}
	function existsTypeAnnotation() {
	  return {
	    type: "ExistsTypeAnnotation"
	  };
	}
	function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
	  const node = {
	    type: "FunctionTypeAnnotation",
	    typeParameters,
	    params,
	    rest,
	    returnType
	  };
	  const defs = NODE_FIELDS.FunctionTypeAnnotation;
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.params, node, "params", params, 1);
	  validate(defs.rest, node, "rest", rest, 1);
	  validate(defs.returnType, node, "returnType", returnType, 1);
	  return node;
	}
	function functionTypeParam(name = null, typeAnnotation) {
	  const node = {
	    type: "FunctionTypeParam",
	    name,
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.FunctionTypeParam;
	  validate(defs.name, node, "name", name, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function genericTypeAnnotation(id, typeParameters = null) {
	  const node = {
	    type: "GenericTypeAnnotation",
	    id,
	    typeParameters
	  };
	  const defs = NODE_FIELDS.GenericTypeAnnotation;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  return node;
	}
	function inferredPredicate() {
	  return {
	    type: "InferredPredicate"
	  };
	}
	function interfaceExtends(id, typeParameters = null) {
	  const node = {
	    type: "InterfaceExtends",
	    id,
	    typeParameters
	  };
	  const defs = NODE_FIELDS.InterfaceExtends;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  return node;
	}
	function interfaceDeclaration(id, typeParameters = null, _extends = null, body) {
	  const node = {
	    type: "InterfaceDeclaration",
	    id,
	    typeParameters,
	    extends: _extends,
	    body
	  };
	  const defs = NODE_FIELDS.InterfaceDeclaration;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.extends, node, "extends", _extends, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function interfaceTypeAnnotation(_extends = null, body) {
	  const node = {
	    type: "InterfaceTypeAnnotation",
	    extends: _extends,
	    body
	  };
	  const defs = NODE_FIELDS.InterfaceTypeAnnotation;
	  validate(defs.extends, node, "extends", _extends, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function intersectionTypeAnnotation(types) {
	  const node = {
	    type: "IntersectionTypeAnnotation",
	    types
	  };
	  const defs = NODE_FIELDS.IntersectionTypeAnnotation;
	  validate(defs.types, node, "types", types, 1);
	  return node;
	}
	function mixedTypeAnnotation() {
	  return {
	    type: "MixedTypeAnnotation"
	  };
	}
	function emptyTypeAnnotation() {
	  return {
	    type: "EmptyTypeAnnotation"
	  };
	}
	function nullableTypeAnnotation(typeAnnotation) {
	  const node = {
	    type: "NullableTypeAnnotation",
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.NullableTypeAnnotation;
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function numberLiteralTypeAnnotation(value) {
	  const node = {
	    type: "NumberLiteralTypeAnnotation",
	    value
	  };
	  const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
	  validate(defs.value, node, "value", value);
	  return node;
	}
	function numberTypeAnnotation() {
	  return {
	    type: "NumberTypeAnnotation"
	  };
	}
	function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
	  const node = {
	    type: "ObjectTypeAnnotation",
	    properties,
	    indexers,
	    callProperties,
	    internalSlots,
	    exact
	  };
	  const defs = NODE_FIELDS.ObjectTypeAnnotation;
	  validate(defs.properties, node, "properties", properties, 1);
	  validate(defs.indexers, node, "indexers", indexers, 1);
	  validate(defs.callProperties, node, "callProperties", callProperties, 1);
	  validate(defs.internalSlots, node, "internalSlots", internalSlots, 1);
	  validate(defs.exact, node, "exact", exact);
	  return node;
	}
	function objectTypeInternalSlot(id, value, optional, _static, method) {
	  const node = {
	    type: "ObjectTypeInternalSlot",
	    id,
	    value,
	    optional,
	    static: _static,
	    method
	  };
	  const defs = NODE_FIELDS.ObjectTypeInternalSlot;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.value, node, "value", value, 1);
	  validate(defs.optional, node, "optional", optional);
	  validate(defs.static, node, "static", _static);
	  validate(defs.method, node, "method", method);
	  return node;
	}
	function objectTypeCallProperty(value) {
	  const node = {
	    type: "ObjectTypeCallProperty",
	    value,
	    static: null
	  };
	  const defs = NODE_FIELDS.ObjectTypeCallProperty;
	  validate(defs.value, node, "value", value, 1);
	  return node;
	}
	function objectTypeIndexer(id = null, key, value, variance = null) {
	  const node = {
	    type: "ObjectTypeIndexer",
	    id,
	    key,
	    value,
	    variance,
	    static: null
	  };
	  const defs = NODE_FIELDS.ObjectTypeIndexer;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.value, node, "value", value, 1);
	  validate(defs.variance, node, "variance", variance, 1);
	  return node;
	}
	function objectTypeProperty(key, value, variance = null) {
	  const node = {
	    type: "ObjectTypeProperty",
	    key,
	    value,
	    variance,
	    kind: null,
	    method: null,
	    optional: null,
	    proto: null,
	    static: null
	  };
	  const defs = NODE_FIELDS.ObjectTypeProperty;
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.value, node, "value", value, 1);
	  validate(defs.variance, node, "variance", variance, 1);
	  return node;
	}
	function objectTypeSpreadProperty(argument) {
	  const node = {
	    type: "ObjectTypeSpreadProperty",
	    argument
	  };
	  const defs = NODE_FIELDS.ObjectTypeSpreadProperty;
	  validate(defs.argument, node, "argument", argument, 1);
	  return node;
	}
	function opaqueType(id, typeParameters = null, supertype = null, impltype) {
	  const node = {
	    type: "OpaqueType",
	    id,
	    typeParameters,
	    supertype,
	    impltype
	  };
	  const defs = NODE_FIELDS.OpaqueType;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.supertype, node, "supertype", supertype, 1);
	  validate(defs.impltype, node, "impltype", impltype, 1);
	  return node;
	}
	function qualifiedTypeIdentifier(id, qualification) {
	  const node = {
	    type: "QualifiedTypeIdentifier",
	    id,
	    qualification
	  };
	  const defs = NODE_FIELDS.QualifiedTypeIdentifier;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.qualification, node, "qualification", qualification, 1);
	  return node;
	}
	function stringLiteralTypeAnnotation(value) {
	  const node = {
	    type: "StringLiteralTypeAnnotation",
	    value
	  };
	  const defs = NODE_FIELDS.StringLiteralTypeAnnotation;
	  validate(defs.value, node, "value", value);
	  return node;
	}
	function stringTypeAnnotation() {
	  return {
	    type: "StringTypeAnnotation"
	  };
	}
	function symbolTypeAnnotation() {
	  return {
	    type: "SymbolTypeAnnotation"
	  };
	}
	function thisTypeAnnotation() {
	  return {
	    type: "ThisTypeAnnotation"
	  };
	}
	function tupleTypeAnnotation(types) {
	  const node = {
	    type: "TupleTypeAnnotation",
	    types
	  };
	  const defs = NODE_FIELDS.TupleTypeAnnotation;
	  validate(defs.types, node, "types", types, 1);
	  return node;
	}
	function typeofTypeAnnotation(argument) {
	  const node = {
	    type: "TypeofTypeAnnotation",
	    argument
	  };
	  const defs = NODE_FIELDS.TypeofTypeAnnotation;
	  validate(defs.argument, node, "argument", argument, 1);
	  return node;
	}
	function typeAlias(id, typeParameters = null, right) {
	  const node = {
	    type: "TypeAlias",
	    id,
	    typeParameters,
	    right
	  };
	  const defs = NODE_FIELDS.TypeAlias;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.right, node, "right", right, 1);
	  return node;
	}
	function typeAnnotation(typeAnnotation) {
	  const node = {
	    type: "TypeAnnotation",
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TypeAnnotation;
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function typeCastExpression(expression, typeAnnotation) {
	  const node = {
	    type: "TypeCastExpression",
	    expression,
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TypeCastExpression;
	  validate(defs.expression, node, "expression", expression, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function typeParameter(bound = null, _default = null, variance = null) {
	  const node = {
	    type: "TypeParameter",
	    bound,
	    default: _default,
	    variance,
	    name: null
	  };
	  const defs = NODE_FIELDS.TypeParameter;
	  validate(defs.bound, node, "bound", bound, 1);
	  validate(defs.default, node, "default", _default, 1);
	  validate(defs.variance, node, "variance", variance, 1);
	  return node;
	}
	function typeParameterDeclaration(params) {
	  const node = {
	    type: "TypeParameterDeclaration",
	    params
	  };
	  const defs = NODE_FIELDS.TypeParameterDeclaration;
	  validate(defs.params, node, "params", params, 1);
	  return node;
	}
	function typeParameterInstantiation(params) {
	  const node = {
	    type: "TypeParameterInstantiation",
	    params
	  };
	  const defs = NODE_FIELDS.TypeParameterInstantiation;
	  validate(defs.params, node, "params", params, 1);
	  return node;
	}
	function unionTypeAnnotation(types) {
	  const node = {
	    type: "UnionTypeAnnotation",
	    types
	  };
	  const defs = NODE_FIELDS.UnionTypeAnnotation;
	  validate(defs.types, node, "types", types, 1);
	  return node;
	}
	function variance(kind) {
	  const node = {
	    type: "Variance",
	    kind
	  };
	  const defs = NODE_FIELDS.Variance;
	  validate(defs.kind, node, "kind", kind);
	  return node;
	}
	function voidTypeAnnotation() {
	  return {
	    type: "VoidTypeAnnotation"
	  };
	}
	function enumDeclaration(id, body) {
	  const node = {
	    type: "EnumDeclaration",
	    id,
	    body
	  };
	  const defs = NODE_FIELDS.EnumDeclaration;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function enumBooleanBody(members) {
	  const node = {
	    type: "EnumBooleanBody",
	    members,
	    explicitType: null,
	    hasUnknownMembers: null
	  };
	  const defs = NODE_FIELDS.EnumBooleanBody;
	  validate(defs.members, node, "members", members, 1);
	  return node;
	}
	function enumNumberBody(members) {
	  const node = {
	    type: "EnumNumberBody",
	    members,
	    explicitType: null,
	    hasUnknownMembers: null
	  };
	  const defs = NODE_FIELDS.EnumNumberBody;
	  validate(defs.members, node, "members", members, 1);
	  return node;
	}
	function enumStringBody(members) {
	  const node = {
	    type: "EnumStringBody",
	    members,
	    explicitType: null,
	    hasUnknownMembers: null
	  };
	  const defs = NODE_FIELDS.EnumStringBody;
	  validate(defs.members, node, "members", members, 1);
	  return node;
	}
	function enumSymbolBody(members) {
	  const node = {
	    type: "EnumSymbolBody",
	    members,
	    hasUnknownMembers: null
	  };
	  const defs = NODE_FIELDS.EnumSymbolBody;
	  validate(defs.members, node, "members", members, 1);
	  return node;
	}
	function enumBooleanMember(id) {
	  const node = {
	    type: "EnumBooleanMember",
	    id,
	    init: null
	  };
	  const defs = NODE_FIELDS.EnumBooleanMember;
	  validate(defs.id, node, "id", id, 1);
	  return node;
	}
	function enumNumberMember(id, init) {
	  const node = {
	    type: "EnumNumberMember",
	    id,
	    init
	  };
	  const defs = NODE_FIELDS.EnumNumberMember;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.init, node, "init", init, 1);
	  return node;
	}
	function enumStringMember(id, init) {
	  const node = {
	    type: "EnumStringMember",
	    id,
	    init
	  };
	  const defs = NODE_FIELDS.EnumStringMember;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.init, node, "init", init, 1);
	  return node;
	}
	function enumDefaultedMember(id) {
	  const node = {
	    type: "EnumDefaultedMember",
	    id
	  };
	  const defs = NODE_FIELDS.EnumDefaultedMember;
	  validate(defs.id, node, "id", id, 1);
	  return node;
	}
	function indexedAccessType(objectType, indexType) {
	  const node = {
	    type: "IndexedAccessType",
	    objectType,
	    indexType
	  };
	  const defs = NODE_FIELDS.IndexedAccessType;
	  validate(defs.objectType, node, "objectType", objectType, 1);
	  validate(defs.indexType, node, "indexType", indexType, 1);
	  return node;
	}
	function optionalIndexedAccessType(objectType, indexType) {
	  const node = {
	    type: "OptionalIndexedAccessType",
	    objectType,
	    indexType,
	    optional: null
	  };
	  const defs = NODE_FIELDS.OptionalIndexedAccessType;
	  validate(defs.objectType, node, "objectType", objectType, 1);
	  validate(defs.indexType, node, "indexType", indexType, 1);
	  return node;
	}
	function jsxAttribute(name, value = null) {
	  const node = {
	    type: "JSXAttribute",
	    name,
	    value
	  };
	  const defs = NODE_FIELDS.JSXAttribute;
	  validate(defs.name, node, "name", name, 1);
	  validate(defs.value, node, "value", value, 1);
	  return node;
	}
	function jsxClosingElement(name) {
	  const node = {
	    type: "JSXClosingElement",
	    name
	  };
	  const defs = NODE_FIELDS.JSXClosingElement;
	  validate(defs.name, node, "name", name, 1);
	  return node;
	}
	function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
	  const node = {
	    type: "JSXElement",
	    openingElement,
	    closingElement,
	    children,
	    selfClosing
	  };
	  const defs = NODE_FIELDS.JSXElement;
	  validate(defs.openingElement, node, "openingElement", openingElement, 1);
	  validate(defs.closingElement, node, "closingElement", closingElement, 1);
	  validate(defs.children, node, "children", children, 1);
	  validate(defs.selfClosing, node, "selfClosing", selfClosing);
	  return node;
	}
	function jsxEmptyExpression() {
	  return {
	    type: "JSXEmptyExpression"
	  };
	}
	function jsxExpressionContainer(expression) {
	  const node = {
	    type: "JSXExpressionContainer",
	    expression
	  };
	  const defs = NODE_FIELDS.JSXExpressionContainer;
	  validate(defs.expression, node, "expression", expression, 1);
	  return node;
	}
	function jsxSpreadChild(expression) {
	  const node = {
	    type: "JSXSpreadChild",
	    expression
	  };
	  const defs = NODE_FIELDS.JSXSpreadChild;
	  validate(defs.expression, node, "expression", expression, 1);
	  return node;
	}
	function jsxIdentifier(name) {
	  const node = {
	    type: "JSXIdentifier",
	    name
	  };
	  const defs = NODE_FIELDS.JSXIdentifier;
	  validate(defs.name, node, "name", name);
	  return node;
	}
	function jsxMemberExpression(object, property) {
	  const node = {
	    type: "JSXMemberExpression",
	    object,
	    property
	  };
	  const defs = NODE_FIELDS.JSXMemberExpression;
	  validate(defs.object, node, "object", object, 1);
	  validate(defs.property, node, "property", property, 1);
	  return node;
	}
	function jsxNamespacedName(namespace, name) {
	  const node = {
	    type: "JSXNamespacedName",
	    namespace,
	    name
	  };
	  const defs = NODE_FIELDS.JSXNamespacedName;
	  validate(defs.namespace, node, "namespace", namespace, 1);
	  validate(defs.name, node, "name", name, 1);
	  return node;
	}
	function jsxOpeningElement(name, attributes, selfClosing = false) {
	  const node = {
	    type: "JSXOpeningElement",
	    name,
	    attributes,
	    selfClosing
	  };
	  const defs = NODE_FIELDS.JSXOpeningElement;
	  validate(defs.name, node, "name", name, 1);
	  validate(defs.attributes, node, "attributes", attributes, 1);
	  validate(defs.selfClosing, node, "selfClosing", selfClosing);
	  return node;
	}
	function jsxSpreadAttribute(argument) {
	  const node = {
	    type: "JSXSpreadAttribute",
	    argument
	  };
	  const defs = NODE_FIELDS.JSXSpreadAttribute;
	  validate(defs.argument, node, "argument", argument, 1);
	  return node;
	}
	function jsxText(value) {
	  const node = {
	    type: "JSXText",
	    value
	  };
	  const defs = NODE_FIELDS.JSXText;
	  validate(defs.value, node, "value", value);
	  return node;
	}
	function jsxFragment(openingFragment, closingFragment, children) {
	  const node = {
	    type: "JSXFragment",
	    openingFragment,
	    closingFragment,
	    children
	  };
	  const defs = NODE_FIELDS.JSXFragment;
	  validate(defs.openingFragment, node, "openingFragment", openingFragment, 1);
	  validate(defs.closingFragment, node, "closingFragment", closingFragment, 1);
	  validate(defs.children, node, "children", children, 1);
	  return node;
	}
	function jsxOpeningFragment() {
	  return {
	    type: "JSXOpeningFragment"
	  };
	}
	function jsxClosingFragment() {
	  return {
	    type: "JSXClosingFragment"
	  };
	}
	function noop() {
	  return {
	    type: "Noop"
	  };
	}
	function placeholder(expectedNode, name) {
	  const node = {
	    type: "Placeholder",
	    expectedNode,
	    name
	  };
	  const defs = NODE_FIELDS.Placeholder;
	  validate(defs.expectedNode, node, "expectedNode", expectedNode);
	  validate(defs.name, node, "name", name, 1);
	  return node;
	}
	function v8IntrinsicIdentifier(name) {
	  const node = {
	    type: "V8IntrinsicIdentifier",
	    name
	  };
	  const defs = NODE_FIELDS.V8IntrinsicIdentifier;
	  validate(defs.name, node, "name", name);
	  return node;
	}
	function argumentPlaceholder() {
	  return {
	    type: "ArgumentPlaceholder"
	  };
	}
	function bindExpression(object, callee) {
	  const node = {
	    type: "BindExpression",
	    object,
	    callee
	  };
	  const defs = NODE_FIELDS.BindExpression;
	  validate(defs.object, node, "object", object, 1);
	  validate(defs.callee, node, "callee", callee, 1);
	  return node;
	}
	function importAttribute(key, value) {
	  const node = {
	    type: "ImportAttribute",
	    key,
	    value
	  };
	  const defs = NODE_FIELDS.ImportAttribute;
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.value, node, "value", value, 1);
	  return node;
	}
	function decorator(expression) {
	  const node = {
	    type: "Decorator",
	    expression
	  };
	  const defs = NODE_FIELDS.Decorator;
	  validate(defs.expression, node, "expression", expression, 1);
	  return node;
	}
	function doExpression(body, async = false) {
	  const node = {
	    type: "DoExpression",
	    body,
	    async
	  };
	  const defs = NODE_FIELDS.DoExpression;
	  validate(defs.body, node, "body", body, 1);
	  validate(defs.async, node, "async", async);
	  return node;
	}
	function exportDefaultSpecifier(exported) {
	  const node = {
	    type: "ExportDefaultSpecifier",
	    exported
	  };
	  const defs = NODE_FIELDS.ExportDefaultSpecifier;
	  validate(defs.exported, node, "exported", exported, 1);
	  return node;
	}
	function recordExpression(properties) {
	  const node = {
	    type: "RecordExpression",
	    properties
	  };
	  const defs = NODE_FIELDS.RecordExpression;
	  validate(defs.properties, node, "properties", properties, 1);
	  return node;
	}
	function tupleExpression(elements = []) {
	  const node = {
	    type: "TupleExpression",
	    elements
	  };
	  const defs = NODE_FIELDS.TupleExpression;
	  validate(defs.elements, node, "elements", elements, 1);
	  return node;
	}
	function decimalLiteral(value) {
	  const node = {
	    type: "DecimalLiteral",
	    value
	  };
	  const defs = NODE_FIELDS.DecimalLiteral;
	  validate(defs.value, node, "value", value);
	  return node;
	}
	function moduleExpression(body) {
	  const node = {
	    type: "ModuleExpression",
	    body
	  };
	  const defs = NODE_FIELDS.ModuleExpression;
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function topicReference() {
	  return {
	    type: "TopicReference"
	  };
	}
	function pipelineTopicExpression(expression) {
	  const node = {
	    type: "PipelineTopicExpression",
	    expression
	  };
	  const defs = NODE_FIELDS.PipelineTopicExpression;
	  validate(defs.expression, node, "expression", expression, 1);
	  return node;
	}
	function pipelineBareFunction(callee) {
	  const node = {
	    type: "PipelineBareFunction",
	    callee
	  };
	  const defs = NODE_FIELDS.PipelineBareFunction;
	  validate(defs.callee, node, "callee", callee, 1);
	  return node;
	}
	function pipelinePrimaryTopicReference() {
	  return {
	    type: "PipelinePrimaryTopicReference"
	  };
	}
	function tsParameterProperty(parameter) {
	  const node = {
	    type: "TSParameterProperty",
	    parameter
	  };
	  const defs = NODE_FIELDS.TSParameterProperty;
	  validate(defs.parameter, node, "parameter", parameter, 1);
	  return node;
	}
	function tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {
	  const node = {
	    type: "TSDeclareFunction",
	    id,
	    typeParameters,
	    params,
	    returnType
	  };
	  const defs = NODE_FIELDS.TSDeclareFunction;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.params, node, "params", params, 1);
	  validate(defs.returnType, node, "returnType", returnType, 1);
	  return node;
	}
	function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
	  const node = {
	    type: "TSDeclareMethod",
	    decorators,
	    key,
	    typeParameters,
	    params,
	    returnType
	  };
	  const defs = NODE_FIELDS.TSDeclareMethod;
	  validate(defs.decorators, node, "decorators", decorators, 1);
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.params, node, "params", params, 1);
	  validate(defs.returnType, node, "returnType", returnType, 1);
	  return node;
	}
	function tsQualifiedName(left, right) {
	  const node = {
	    type: "TSQualifiedName",
	    left,
	    right
	  };
	  const defs = NODE_FIELDS.TSQualifiedName;
	  validate(defs.left, node, "left", left, 1);
	  validate(defs.right, node, "right", right, 1);
	  return node;
	}
	function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
	  const node = {
	    type: "TSCallSignatureDeclaration",
	    typeParameters,
	    parameters,
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TSCallSignatureDeclaration;
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.parameters, node, "parameters", parameters, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {
	  const node = {
	    type: "TSConstructSignatureDeclaration",
	    typeParameters,
	    parameters,
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TSConstructSignatureDeclaration;
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.parameters, node, "parameters", parameters, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsPropertySignature(key, typeAnnotation = null) {
	  const node = {
	    type: "TSPropertySignature",
	    key,
	    typeAnnotation,
	    kind: null
	  };
	  const defs = NODE_FIELDS.TSPropertySignature;
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null) {
	  const node = {
	    type: "TSMethodSignature",
	    key,
	    typeParameters,
	    parameters,
	    typeAnnotation,
	    kind: null
	  };
	  const defs = NODE_FIELDS.TSMethodSignature;
	  validate(defs.key, node, "key", key, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.parameters, node, "parameters", parameters, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsIndexSignature(parameters, typeAnnotation = null) {
	  const node = {
	    type: "TSIndexSignature",
	    parameters,
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TSIndexSignature;
	  validate(defs.parameters, node, "parameters", parameters, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsAnyKeyword() {
	  return {
	    type: "TSAnyKeyword"
	  };
	}
	function tsBooleanKeyword() {
	  return {
	    type: "TSBooleanKeyword"
	  };
	}
	function tsBigIntKeyword() {
	  return {
	    type: "TSBigIntKeyword"
	  };
	}
	function tsIntrinsicKeyword() {
	  return {
	    type: "TSIntrinsicKeyword"
	  };
	}
	function tsNeverKeyword() {
	  return {
	    type: "TSNeverKeyword"
	  };
	}
	function tsNullKeyword() {
	  return {
	    type: "TSNullKeyword"
	  };
	}
	function tsNumberKeyword() {
	  return {
	    type: "TSNumberKeyword"
	  };
	}
	function tsObjectKeyword() {
	  return {
	    type: "TSObjectKeyword"
	  };
	}
	function tsStringKeyword() {
	  return {
	    type: "TSStringKeyword"
	  };
	}
	function tsSymbolKeyword() {
	  return {
	    type: "TSSymbolKeyword"
	  };
	}
	function tsUndefinedKeyword() {
	  return {
	    type: "TSUndefinedKeyword"
	  };
	}
	function tsUnknownKeyword() {
	  return {
	    type: "TSUnknownKeyword"
	  };
	}
	function tsVoidKeyword() {
	  return {
	    type: "TSVoidKeyword"
	  };
	}
	function tsThisType() {
	  return {
	    type: "TSThisType"
	  };
	}
	function tsFunctionType(typeParameters = null, parameters, typeAnnotation = null) {
	  const node = {
	    type: "TSFunctionType",
	    typeParameters,
	    parameters,
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TSFunctionType;
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.parameters, node, "parameters", parameters, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsConstructorType(typeParameters = null, parameters, typeAnnotation = null) {
	  const node = {
	    type: "TSConstructorType",
	    typeParameters,
	    parameters,
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TSConstructorType;
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.parameters, node, "parameters", parameters, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsTypeReference(typeName, typeParameters = null) {
	  const node = {
	    type: "TSTypeReference",
	    typeName,
	    typeParameters
	  };
	  const defs = NODE_FIELDS.TSTypeReference;
	  validate(defs.typeName, node, "typeName", typeName, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  return node;
	}
	function tsTypePredicate(parameterName, typeAnnotation = null, asserts = null) {
	  const node = {
	    type: "TSTypePredicate",
	    parameterName,
	    typeAnnotation,
	    asserts
	  };
	  const defs = NODE_FIELDS.TSTypePredicate;
	  validate(defs.parameterName, node, "parameterName", parameterName, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  validate(defs.asserts, node, "asserts", asserts);
	  return node;
	}
	function tsTypeQuery(exprName, typeParameters = null) {
	  const node = {
	    type: "TSTypeQuery",
	    exprName,
	    typeParameters
	  };
	  const defs = NODE_FIELDS.TSTypeQuery;
	  validate(defs.exprName, node, "exprName", exprName, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  return node;
	}
	function tsTypeLiteral(members) {
	  const node = {
	    type: "TSTypeLiteral",
	    members
	  };
	  const defs = NODE_FIELDS.TSTypeLiteral;
	  validate(defs.members, node, "members", members, 1);
	  return node;
	}
	function tsArrayType(elementType) {
	  const node = {
	    type: "TSArrayType",
	    elementType
	  };
	  const defs = NODE_FIELDS.TSArrayType;
	  validate(defs.elementType, node, "elementType", elementType, 1);
	  return node;
	}
	function tsTupleType(elementTypes) {
	  const node = {
	    type: "TSTupleType",
	    elementTypes
	  };
	  const defs = NODE_FIELDS.TSTupleType;
	  validate(defs.elementTypes, node, "elementTypes", elementTypes, 1);
	  return node;
	}
	function tsOptionalType(typeAnnotation) {
	  const node = {
	    type: "TSOptionalType",
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TSOptionalType;
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsRestType(typeAnnotation) {
	  const node = {
	    type: "TSRestType",
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TSRestType;
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsNamedTupleMember(label, elementType, optional = false) {
	  const node = {
	    type: "TSNamedTupleMember",
	    label,
	    elementType,
	    optional
	  };
	  const defs = NODE_FIELDS.TSNamedTupleMember;
	  validate(defs.label, node, "label", label, 1);
	  validate(defs.elementType, node, "elementType", elementType, 1);
	  validate(defs.optional, node, "optional", optional);
	  return node;
	}
	function tsUnionType(types) {
	  const node = {
	    type: "TSUnionType",
	    types
	  };
	  const defs = NODE_FIELDS.TSUnionType;
	  validate(defs.types, node, "types", types, 1);
	  return node;
	}
	function tsIntersectionType(types) {
	  const node = {
	    type: "TSIntersectionType",
	    types
	  };
	  const defs = NODE_FIELDS.TSIntersectionType;
	  validate(defs.types, node, "types", types, 1);
	  return node;
	}
	function tsConditionalType(checkType, extendsType, trueType, falseType) {
	  const node = {
	    type: "TSConditionalType",
	    checkType,
	    extendsType,
	    trueType,
	    falseType
	  };
	  const defs = NODE_FIELDS.TSConditionalType;
	  validate(defs.checkType, node, "checkType", checkType, 1);
	  validate(defs.extendsType, node, "extendsType", extendsType, 1);
	  validate(defs.trueType, node, "trueType", trueType, 1);
	  validate(defs.falseType, node, "falseType", falseType, 1);
	  return node;
	}
	function tsInferType(typeParameter) {
	  const node = {
	    type: "TSInferType",
	    typeParameter
	  };
	  const defs = NODE_FIELDS.TSInferType;
	  validate(defs.typeParameter, node, "typeParameter", typeParameter, 1);
	  return node;
	}
	function tsParenthesizedType(typeAnnotation) {
	  const node = {
	    type: "TSParenthesizedType",
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TSParenthesizedType;
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsTypeOperator(typeAnnotation) {
	  const node = {
	    type: "TSTypeOperator",
	    typeAnnotation,
	    operator: null
	  };
	  const defs = NODE_FIELDS.TSTypeOperator;
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsIndexedAccessType(objectType, indexType) {
	  const node = {
	    type: "TSIndexedAccessType",
	    objectType,
	    indexType
	  };
	  const defs = NODE_FIELDS.TSIndexedAccessType;
	  validate(defs.objectType, node, "objectType", objectType, 1);
	  validate(defs.indexType, node, "indexType", indexType, 1);
	  return node;
	}
	function tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {
	  const node = {
	    type: "TSMappedType",
	    typeParameter,
	    typeAnnotation,
	    nameType
	  };
	  const defs = NODE_FIELDS.TSMappedType;
	  validate(defs.typeParameter, node, "typeParameter", typeParameter, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  validate(defs.nameType, node, "nameType", nameType, 1);
	  return node;
	}
	function tsLiteralType(literal) {
	  const node = {
	    type: "TSLiteralType",
	    literal
	  };
	  const defs = NODE_FIELDS.TSLiteralType;
	  validate(defs.literal, node, "literal", literal, 1);
	  return node;
	}
	function tsExpressionWithTypeArguments(expression, typeParameters = null) {
	  const node = {
	    type: "TSExpressionWithTypeArguments",
	    expression,
	    typeParameters
	  };
	  const defs = NODE_FIELDS.TSExpressionWithTypeArguments;
	  validate(defs.expression, node, "expression", expression, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  return node;
	}
	function tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {
	  const node = {
	    type: "TSInterfaceDeclaration",
	    id,
	    typeParameters,
	    extends: _extends,
	    body
	  };
	  const defs = NODE_FIELDS.TSInterfaceDeclaration;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.extends, node, "extends", _extends, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function tsInterfaceBody(body) {
	  const node = {
	    type: "TSInterfaceBody",
	    body
	  };
	  const defs = NODE_FIELDS.TSInterfaceBody;
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {
	  const node = {
	    type: "TSTypeAliasDeclaration",
	    id,
	    typeParameters,
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TSTypeAliasDeclaration;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsInstantiationExpression(expression, typeParameters = null) {
	  const node = {
	    type: "TSInstantiationExpression",
	    expression,
	    typeParameters
	  };
	  const defs = NODE_FIELDS.TSInstantiationExpression;
	  validate(defs.expression, node, "expression", expression, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  return node;
	}
	function tsAsExpression(expression, typeAnnotation) {
	  const node = {
	    type: "TSAsExpression",
	    expression,
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TSAsExpression;
	  validate(defs.expression, node, "expression", expression, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsSatisfiesExpression(expression, typeAnnotation) {
	  const node = {
	    type: "TSSatisfiesExpression",
	    expression,
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TSSatisfiesExpression;
	  validate(defs.expression, node, "expression", expression, 1);
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsTypeAssertion(typeAnnotation, expression) {
	  const node = {
	    type: "TSTypeAssertion",
	    typeAnnotation,
	    expression
	  };
	  const defs = NODE_FIELDS.TSTypeAssertion;
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  validate(defs.expression, node, "expression", expression, 1);
	  return node;
	}
	function tsEnumDeclaration(id, members) {
	  const node = {
	    type: "TSEnumDeclaration",
	    id,
	    members
	  };
	  const defs = NODE_FIELDS.TSEnumDeclaration;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.members, node, "members", members, 1);
	  return node;
	}
	function tsEnumMember(id, initializer = null) {
	  const node = {
	    type: "TSEnumMember",
	    id,
	    initializer
	  };
	  const defs = NODE_FIELDS.TSEnumMember;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.initializer, node, "initializer", initializer, 1);
	  return node;
	}
	function tsModuleDeclaration(id, body) {
	  const node = {
	    type: "TSModuleDeclaration",
	    id,
	    body,
	    kind: null
	  };
	  const defs = NODE_FIELDS.TSModuleDeclaration;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function tsModuleBlock(body) {
	  const node = {
	    type: "TSModuleBlock",
	    body
	  };
	  const defs = NODE_FIELDS.TSModuleBlock;
	  validate(defs.body, node, "body", body, 1);
	  return node;
	}
	function tsImportType(argument, qualifier = null, typeParameters = null) {
	  const node = {
	    type: "TSImportType",
	    argument,
	    qualifier,
	    typeParameters
	  };
	  const defs = NODE_FIELDS.TSImportType;
	  validate(defs.argument, node, "argument", argument, 1);
	  validate(defs.qualifier, node, "qualifier", qualifier, 1);
	  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
	  return node;
	}
	function tsImportEqualsDeclaration(id, moduleReference) {
	  const node = {
	    type: "TSImportEqualsDeclaration",
	    id,
	    moduleReference,
	    isExport: null
	  };
	  const defs = NODE_FIELDS.TSImportEqualsDeclaration;
	  validate(defs.id, node, "id", id, 1);
	  validate(defs.moduleReference, node, "moduleReference", moduleReference, 1);
	  return node;
	}
	function tsExternalModuleReference(expression) {
	  const node = {
	    type: "TSExternalModuleReference",
	    expression
	  };
	  const defs = NODE_FIELDS.TSExternalModuleReference;
	  validate(defs.expression, node, "expression", expression, 1);
	  return node;
	}
	function tsNonNullExpression(expression) {
	  const node = {
	    type: "TSNonNullExpression",
	    expression
	  };
	  const defs = NODE_FIELDS.TSNonNullExpression;
	  validate(defs.expression, node, "expression", expression, 1);
	  return node;
	}
	function tsExportAssignment(expression) {
	  const node = {
	    type: "TSExportAssignment",
	    expression
	  };
	  const defs = NODE_FIELDS.TSExportAssignment;
	  validate(defs.expression, node, "expression", expression, 1);
	  return node;
	}
	function tsNamespaceExportDeclaration(id) {
	  const node = {
	    type: "TSNamespaceExportDeclaration",
	    id
	  };
	  const defs = NODE_FIELDS.TSNamespaceExportDeclaration;
	  validate(defs.id, node, "id", id, 1);
	  return node;
	}
	function tsTypeAnnotation(typeAnnotation) {
	  const node = {
	    type: "TSTypeAnnotation",
	    typeAnnotation
	  };
	  const defs = NODE_FIELDS.TSTypeAnnotation;
	  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
	  return node;
	}
	function tsTypeParameterInstantiation(params) {
	  const node = {
	    type: "TSTypeParameterInstantiation",
	    params
	  };
	  const defs = NODE_FIELDS.TSTypeParameterInstantiation;
	  validate(defs.params, node, "params", params, 1);
	  return node;
	}
	function tsTypeParameterDeclaration(params) {
	  const node = {
	    type: "TSTypeParameterDeclaration",
	    params
	  };
	  const defs = NODE_FIELDS.TSTypeParameterDeclaration;
	  validate(defs.params, node, "params", params, 1);
	  return node;
	}
	function tsTypeParameter(constraint = null, _default = null, name) {
	  const node = {
	    type: "TSTypeParameter",
	    constraint,
	    default: _default,
	    name
	  };
	  const defs = NODE_FIELDS.TSTypeParameter;
	  validate(defs.constraint, node, "constraint", constraint, 1);
	  validate(defs.default, node, "default", _default, 1);
	  validate(defs.name, node, "name", name);
	  return node;
	}
	function NumberLiteral(value) {
	  (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
	  return numericLiteral(value);
	}
	function RegexLiteral(pattern, flags = "") {
	  (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
	  return regExpLiteral(pattern, flags);
	}
	function RestProperty(argument) {
	  (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
	  return restElement(argument);
	}
	function SpreadProperty(argument) {
	  (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
	  return spreadElement(argument);
	}

	
	return generated$2;
}

var hasRequiredCleanJSXElementLiteralChild;

function requireCleanJSXElementLiteralChild () {
	if (hasRequiredCleanJSXElementLiteralChild) return cleanJSXElementLiteralChild;
	hasRequiredCleanJSXElementLiteralChild = 1;

	Object.defineProperty(cleanJSXElementLiteralChild, "__esModule", {
	  value: true
	});
	cleanJSXElementLiteralChild.default = cleanJSXElementLiteralChild$1;
	var _index = requireGenerated$2();
	var _index2 = requireLib$1();
	function cleanJSXElementLiteralChild$1(child, args) {
	  const lines = child.value.split(/\r\n|\n|\r/);
	  let lastNonEmptyLine = 0;
	  for (let i = 0; i < lines.length; i++) {
	    if (/[^ \t]/.exec(lines[i])) {
	      lastNonEmptyLine = i;
	    }
	  }
	  let str = "";
	  for (let i = 0; i < lines.length; i++) {
	    const line = lines[i];
	    const isFirstLine = i === 0;
	    const isLastLine = i === lines.length - 1;
	    const isLastNonEmptyLine = i === lastNonEmptyLine;
	    let trimmedLine = line.replace(/\t/g, " ");
	    if (!isFirstLine) {
	      trimmedLine = trimmedLine.replace(/^ +/, "");
	    }
	    if (!isLastLine) {
	      trimmedLine = trimmedLine.replace(/ +$/, "");
	    }
	    if (trimmedLine) {
	      if (!isLastNonEmptyLine) {
	        trimmedLine += " ";
	      }
	      str += trimmedLine;
	    }
	  }
	  if (str) args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
	}

	
	return cleanJSXElementLiteralChild;
}

var hasRequiredBuildChildren;

function requireBuildChildren () {
	if (hasRequiredBuildChildren) return buildChildren;
	hasRequiredBuildChildren = 1;

	Object.defineProperty(buildChildren, "__esModule", {
	  value: true
	});
	buildChildren.default = buildChildren$1;
	var _index = requireGenerated$3();
	var _cleanJSXElementLiteralChild = requireCleanJSXElementLiteralChild();
	function buildChildren$1(node) {
	  const elements = [];
	  for (let i = 0; i < node.children.length; i++) {
	    let child = node.children[i];
	    if ((0, _index.isJSXText)(child)) {
	      (0, _cleanJSXElementLiteralChild.default)(child, elements);
	      continue;
	    }
	    if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;
	    if ((0, _index.isJSXEmptyExpression)(child)) continue;
	    elements.push(child);
	  }
	  return elements;
	}

	
	return buildChildren;
}

var assertNode = {};

var isNode = {};

var hasRequiredIsNode;

function requireIsNode () {
	if (hasRequiredIsNode) return isNode;
	hasRequiredIsNode = 1;

	Object.defineProperty(isNode, "__esModule", {
	  value: true
	});
	isNode.default = isNode$1;
	var _index = requireDefinitions();
	function isNode$1(node) {
	  return !!(node && _index.VISITOR_KEYS[node.type]);
	}

	
	return isNode;
}

var hasRequiredAssertNode;

function requireAssertNode () {
	if (hasRequiredAssertNode) return assertNode;
	hasRequiredAssertNode = 1;

	Object.defineProperty(assertNode, "__esModule", {
	  value: true
	});
	assertNode.default = assertNode$1;
	var _isNode = requireIsNode();
	function assertNode$1(node) {
	  if (!(0, _isNode.default)(node)) {
	    var _node$type;
	    const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
	    throw new TypeError(`Not a valid node of type "${type}"`);
	  }
	}

	
	return assertNode;
}

var generated$1 = {};

var hasRequiredGenerated$1;

function requireGenerated$1 () {
	if (hasRequiredGenerated$1) return generated$1;
	hasRequiredGenerated$1 = 1;

	Object.defineProperty(generated$1, "__esModule", {
	  value: true
	});
	generated$1.assertAccessor = assertAccessor;
	generated$1.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
	generated$1.assertArgumentPlaceholder = assertArgumentPlaceholder;
	generated$1.assertArrayExpression = assertArrayExpression;
	generated$1.assertArrayPattern = assertArrayPattern;
	generated$1.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
	generated$1.assertArrowFunctionExpression = assertArrowFunctionExpression;
	generated$1.assertAssignmentExpression = assertAssignmentExpression;
	generated$1.assertAssignmentPattern = assertAssignmentPattern;
	generated$1.assertAwaitExpression = assertAwaitExpression;
	generated$1.assertBigIntLiteral = assertBigIntLiteral;
	generated$1.assertBinary = assertBinary;
	generated$1.assertBinaryExpression = assertBinaryExpression;
	generated$1.assertBindExpression = assertBindExpression;
	generated$1.assertBlock = assertBlock;
	generated$1.assertBlockParent = assertBlockParent;
	generated$1.assertBlockStatement = assertBlockStatement;
	generated$1.assertBooleanLiteral = assertBooleanLiteral;
	generated$1.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
	generated$1.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
	generated$1.assertBreakStatement = assertBreakStatement;
	generated$1.assertCallExpression = assertCallExpression;
	generated$1.assertCatchClause = assertCatchClause;
	generated$1.assertClass = assertClass;
	generated$1.assertClassAccessorProperty = assertClassAccessorProperty;
	generated$1.assertClassBody = assertClassBody;
	generated$1.assertClassDeclaration = assertClassDeclaration;
	generated$1.assertClassExpression = assertClassExpression;
	generated$1.assertClassImplements = assertClassImplements;
	generated$1.assertClassMethod = assertClassMethod;
	generated$1.assertClassPrivateMethod = assertClassPrivateMethod;
	generated$1.assertClassPrivateProperty = assertClassPrivateProperty;
	generated$1.assertClassProperty = assertClassProperty;
	generated$1.assertCompletionStatement = assertCompletionStatement;
	generated$1.assertConditional = assertConditional;
	generated$1.assertConditionalExpression = assertConditionalExpression;
	generated$1.assertContinueStatement = assertContinueStatement;
	generated$1.assertDebuggerStatement = assertDebuggerStatement;
	generated$1.assertDecimalLiteral = assertDecimalLiteral;
	generated$1.assertDeclaration = assertDeclaration;
	generated$1.assertDeclareClass = assertDeclareClass;
	generated$1.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
	generated$1.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
	generated$1.assertDeclareFunction = assertDeclareFunction;
	generated$1.assertDeclareInterface = assertDeclareInterface;
	generated$1.assertDeclareModule = assertDeclareModule;
	generated$1.assertDeclareModuleExports = assertDeclareModuleExports;
	generated$1.assertDeclareOpaqueType = assertDeclareOpaqueType;
	generated$1.assertDeclareTypeAlias = assertDeclareTypeAlias;
	generated$1.assertDeclareVariable = assertDeclareVariable;
	generated$1.assertDeclaredPredicate = assertDeclaredPredicate;
	generated$1.assertDecorator = assertDecorator;
	generated$1.assertDirective = assertDirective;
	generated$1.assertDirectiveLiteral = assertDirectiveLiteral;
	generated$1.assertDoExpression = assertDoExpression;
	generated$1.assertDoWhileStatement = assertDoWhileStatement;
	generated$1.assertEmptyStatement = assertEmptyStatement;
	generated$1.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
	generated$1.assertEnumBody = assertEnumBody;
	generated$1.assertEnumBooleanBody = assertEnumBooleanBody;
	generated$1.assertEnumBooleanMember = assertEnumBooleanMember;
	generated$1.assertEnumDeclaration = assertEnumDeclaration;
	generated$1.assertEnumDefaultedMember = assertEnumDefaultedMember;
	generated$1.assertEnumMember = assertEnumMember;
	generated$1.assertEnumNumberBody = assertEnumNumberBody;
	generated$1.assertEnumNumberMember = assertEnumNumberMember;
	generated$1.assertEnumStringBody = assertEnumStringBody;
	generated$1.assertEnumStringMember = assertEnumStringMember;
	generated$1.assertEnumSymbolBody = assertEnumSymbolBody;
	generated$1.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
	generated$1.assertExportAllDeclaration = assertExportAllDeclaration;
	generated$1.assertExportDeclaration = assertExportDeclaration;
	generated$1.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
	generated$1.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
	generated$1.assertExportNamedDeclaration = assertExportNamedDeclaration;
	generated$1.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
	generated$1.assertExportSpecifier = assertExportSpecifier;
	generated$1.assertExpression = assertExpression;
	generated$1.assertExpressionStatement = assertExpressionStatement;
	generated$1.assertExpressionWrapper = assertExpressionWrapper;
	generated$1.assertFile = assertFile;
	generated$1.assertFlow = assertFlow;
	generated$1.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
	generated$1.assertFlowDeclaration = assertFlowDeclaration;
	generated$1.assertFlowPredicate = assertFlowPredicate;
	generated$1.assertFlowType = assertFlowType;
	generated$1.assertFor = assertFor;
	generated$1.assertForInStatement = assertForInStatement;
	generated$1.assertForOfStatement = assertForOfStatement;
	generated$1.assertForStatement = assertForStatement;
	generated$1.assertForXStatement = assertForXStatement;
	generated$1.assertFunction = assertFunction;
	generated$1.assertFunctionDeclaration = assertFunctionDeclaration;
	generated$1.assertFunctionExpression = assertFunctionExpression;
	generated$1.assertFunctionParent = assertFunctionParent;
	generated$1.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
	generated$1.assertFunctionTypeParam = assertFunctionTypeParam;
	generated$1.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
	generated$1.assertIdentifier = assertIdentifier;
	generated$1.assertIfStatement = assertIfStatement;
	generated$1.assertImmutable = assertImmutable;
	generated$1.assertImport = assertImport;
	generated$1.assertImportAttribute = assertImportAttribute;
	generated$1.assertImportDeclaration = assertImportDeclaration;
	generated$1.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
	generated$1.assertImportExpression = assertImportExpression;
	generated$1.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
	generated$1.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
	generated$1.assertImportSpecifier = assertImportSpecifier;
	generated$1.assertIndexedAccessType = assertIndexedAccessType;
	generated$1.assertInferredPredicate = assertInferredPredicate;
	generated$1.assertInterfaceDeclaration = assertInterfaceDeclaration;
	generated$1.assertInterfaceExtends = assertInterfaceExtends;
	generated$1.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
	generated$1.assertInterpreterDirective = assertInterpreterDirective;
	generated$1.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
	generated$1.assertJSX = assertJSX;
	generated$1.assertJSXAttribute = assertJSXAttribute;
	generated$1.assertJSXClosingElement = assertJSXClosingElement;
	generated$1.assertJSXClosingFragment = assertJSXClosingFragment;
	generated$1.assertJSXElement = assertJSXElement;
	generated$1.assertJSXEmptyExpression = assertJSXEmptyExpression;
	generated$1.assertJSXExpressionContainer = assertJSXExpressionContainer;
	generated$1.assertJSXFragment = assertJSXFragment;
	generated$1.assertJSXIdentifier = assertJSXIdentifier;
	generated$1.assertJSXMemberExpression = assertJSXMemberExpression;
	generated$1.assertJSXNamespacedName = assertJSXNamespacedName;
	generated$1.assertJSXOpeningElement = assertJSXOpeningElement;
	generated$1.assertJSXOpeningFragment = assertJSXOpeningFragment;
	generated$1.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
	generated$1.assertJSXSpreadChild = assertJSXSpreadChild;
	generated$1.assertJSXText = assertJSXText;
	generated$1.assertLVal = assertLVal;
	generated$1.assertLabeledStatement = assertLabeledStatement;
	generated$1.assertLiteral = assertLiteral;
	generated$1.assertLogicalExpression = assertLogicalExpression;
	generated$1.assertLoop = assertLoop;
	generated$1.assertMemberExpression = assertMemberExpression;
	generated$1.assertMetaProperty = assertMetaProperty;
	generated$1.assertMethod = assertMethod;
	generated$1.assertMiscellaneous = assertMiscellaneous;
	generated$1.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
	generated$1.assertModuleDeclaration = assertModuleDeclaration;
	generated$1.assertModuleExpression = assertModuleExpression;
	generated$1.assertModuleSpecifier = assertModuleSpecifier;
	generated$1.assertNewExpression = assertNewExpression;
	generated$1.assertNoop = assertNoop;
	generated$1.assertNullLiteral = assertNullLiteral;
	generated$1.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
	generated$1.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
	generated$1.assertNumberLiteral = assertNumberLiteral;
	generated$1.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
	generated$1.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
	generated$1.assertNumericLiteral = assertNumericLiteral;
	generated$1.assertObjectExpression = assertObjectExpression;
	generated$1.assertObjectMember = assertObjectMember;
	generated$1.assertObjectMethod = assertObjectMethod;
	generated$1.assertObjectPattern = assertObjectPattern;
	generated$1.assertObjectProperty = assertObjectProperty;
	generated$1.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
	generated$1.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
	generated$1.assertObjectTypeIndexer = assertObjectTypeIndexer;
	generated$1.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
	generated$1.assertObjectTypeProperty = assertObjectTypeProperty;
	generated$1.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
	generated$1.assertOpaqueType = assertOpaqueType;
	generated$1.assertOptionalCallExpression = assertOptionalCallExpression;
	generated$1.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
	generated$1.assertOptionalMemberExpression = assertOptionalMemberExpression;
	generated$1.assertParenthesizedExpression = assertParenthesizedExpression;
	generated$1.assertPattern = assertPattern;
	generated$1.assertPatternLike = assertPatternLike;
	generated$1.assertPipelineBareFunction = assertPipelineBareFunction;
	generated$1.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
	generated$1.assertPipelineTopicExpression = assertPipelineTopicExpression;
	generated$1.assertPlaceholder = assertPlaceholder;
	generated$1.assertPrivate = assertPrivate;
	generated$1.assertPrivateName = assertPrivateName;
	generated$1.assertProgram = assertProgram;
	generated$1.assertProperty = assertProperty;
	generated$1.assertPureish = assertPureish;
	generated$1.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
	generated$1.assertRecordExpression = assertRecordExpression;
	generated$1.assertRegExpLiteral = assertRegExpLiteral;
	generated$1.assertRegexLiteral = assertRegexLiteral;
	generated$1.assertRestElement = assertRestElement;
	generated$1.assertRestProperty = assertRestProperty;
	generated$1.assertReturnStatement = assertReturnStatement;
	generated$1.assertScopable = assertScopable;
	generated$1.assertSequenceExpression = assertSequenceExpression;
	generated$1.assertSpreadElement = assertSpreadElement;
	generated$1.assertSpreadProperty = assertSpreadProperty;
	generated$1.assertStandardized = assertStandardized;
	generated$1.assertStatement = assertStatement;
	generated$1.assertStaticBlock = assertStaticBlock;
	generated$1.assertStringLiteral = assertStringLiteral;
	generated$1.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
	generated$1.assertStringTypeAnnotation = assertStringTypeAnnotation;
	generated$1.assertSuper = assertSuper;
	generated$1.assertSwitchCase = assertSwitchCase;
	generated$1.assertSwitchStatement = assertSwitchStatement;
	generated$1.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
	generated$1.assertTSAnyKeyword = assertTSAnyKeyword;
	generated$1.assertTSArrayType = assertTSArrayType;
	generated$1.assertTSAsExpression = assertTSAsExpression;
	generated$1.assertTSBaseType = assertTSBaseType;
	generated$1.assertTSBigIntKeyword = assertTSBigIntKeyword;
	generated$1.assertTSBooleanKeyword = assertTSBooleanKeyword;
	generated$1.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
	generated$1.assertTSConditionalType = assertTSConditionalType;
	generated$1.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
	generated$1.assertTSConstructorType = assertTSConstructorType;
	generated$1.assertTSDeclareFunction = assertTSDeclareFunction;
	generated$1.assertTSDeclareMethod = assertTSDeclareMethod;
	generated$1.assertTSEntityName = assertTSEntityName;
	generated$1.assertTSEnumDeclaration = assertTSEnumDeclaration;
	generated$1.assertTSEnumMember = assertTSEnumMember;
	generated$1.assertTSExportAssignment = assertTSExportAssignment;
	generated$1.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
	generated$1.assertTSExternalModuleReference = assertTSExternalModuleReference;
	generated$1.assertTSFunctionType = assertTSFunctionType;
	generated$1.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
	generated$1.assertTSImportType = assertTSImportType;
	generated$1.assertTSIndexSignature = assertTSIndexSignature;
	generated$1.assertTSIndexedAccessType = assertTSIndexedAccessType;
	generated$1.assertTSInferType = assertTSInferType;
	generated$1.assertTSInstantiationExpression = assertTSInstantiationExpression;
	generated$1.assertTSInterfaceBody = assertTSInterfaceBody;
	generated$1.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
	generated$1.assertTSIntersectionType = assertTSIntersectionType;
	generated$1.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
	generated$1.assertTSLiteralType = assertTSLiteralType;
	generated$1.assertTSMappedType = assertTSMappedType;
	generated$1.assertTSMethodSignature = assertTSMethodSignature;
	generated$1.assertTSModuleBlock = assertTSModuleBlock;
	generated$1.assertTSModuleDeclaration = assertTSModuleDeclaration;
	generated$1.assertTSNamedTupleMember = assertTSNamedTupleMember;
	generated$1.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
	generated$1.assertTSNeverKeyword = assertTSNeverKeyword;
	generated$1.assertTSNonNullExpression = assertTSNonNullExpression;
	generated$1.assertTSNullKeyword = assertTSNullKeyword;
	generated$1.assertTSNumberKeyword = assertTSNumberKeyword;
	generated$1.assertTSObjectKeyword = assertTSObjectKeyword;
	generated$1.assertTSOptionalType = assertTSOptionalType;
	generated$1.assertTSParameterProperty = assertTSParameterProperty;
	generated$1.assertTSParenthesizedType = assertTSParenthesizedType;
	generated$1.assertTSPropertySignature = assertTSPropertySignature;
	generated$1.assertTSQualifiedName = assertTSQualifiedName;
	generated$1.assertTSRestType = assertTSRestType;
	generated$1.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
	generated$1.assertTSStringKeyword = assertTSStringKeyword;
	generated$1.assertTSSymbolKeyword = assertTSSymbolKeyword;
	generated$1.assertTSThisType = assertTSThisType;
	generated$1.assertTSTupleType = assertTSTupleType;
	generated$1.assertTSType = assertTSType;
	generated$1.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
	generated$1.assertTSTypeAnnotation = assertTSTypeAnnotation;
	generated$1.assertTSTypeAssertion = assertTSTypeAssertion;
	generated$1.assertTSTypeElement = assertTSTypeElement;
	generated$1.assertTSTypeLiteral = assertTSTypeLiteral;
	generated$1.assertTSTypeOperator = assertTSTypeOperator;
	generated$1.assertTSTypeParameter = assertTSTypeParameter;
	generated$1.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
	generated$1.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
	generated$1.assertTSTypePredicate = assertTSTypePredicate;
	generated$1.assertTSTypeQuery = assertTSTypeQuery;
	generated$1.assertTSTypeReference = assertTSTypeReference;
	generated$1.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
	generated$1.assertTSUnionType = assertTSUnionType;
	generated$1.assertTSUnknownKeyword = assertTSUnknownKeyword;
	generated$1.assertTSVoidKeyword = assertTSVoidKeyword;
	generated$1.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
	generated$1.assertTemplateElement = assertTemplateElement;
	generated$1.assertTemplateLiteral = assertTemplateLiteral;
	generated$1.assertTerminatorless = assertTerminatorless;
	generated$1.assertThisExpression = assertThisExpression;
	generated$1.assertThisTypeAnnotation = assertThisTypeAnnotation;
	generated$1.assertThrowStatement = assertThrowStatement;
	generated$1.assertTopicReference = assertTopicReference;
	generated$1.assertTryStatement = assertTryStatement;
	generated$1.assertTupleExpression = assertTupleExpression;
	generated$1.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
	generated$1.assertTypeAlias = assertTypeAlias;
	generated$1.assertTypeAnnotation = assertTypeAnnotation;
	generated$1.assertTypeCastExpression = assertTypeCastExpression;
	generated$1.assertTypeParameter = assertTypeParameter;
	generated$1.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
	generated$1.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
	generated$1.assertTypeScript = assertTypeScript;
	generated$1.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
	generated$1.assertUnaryExpression = assertUnaryExpression;
	generated$1.assertUnaryLike = assertUnaryLike;
	generated$1.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
	generated$1.assertUpdateExpression = assertUpdateExpression;
	generated$1.assertUserWhitespacable = assertUserWhitespacable;
	generated$1.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
	generated$1.assertVariableDeclaration = assertVariableDeclaration;
	generated$1.assertVariableDeclarator = assertVariableDeclarator;
	generated$1.assertVariance = assertVariance;
	generated$1.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
	generated$1.assertWhile = assertWhile;
	generated$1.assertWhileStatement = assertWhileStatement;
	generated$1.assertWithStatement = assertWithStatement;
	generated$1.assertYieldExpression = assertYieldExpression;
	var _is = requireIs();
	var _deprecationWarning = requireDeprecationWarning();
	function assert(type, node, opts) {
	  if (!(0, _is.default)(type, node, opts)) {
	    throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);
	  }
	}
	function assertArrayExpression(node, opts) {
	  assert("ArrayExpression", node, opts);
	}
	function assertAssignmentExpression(node, opts) {
	  assert("AssignmentExpression", node, opts);
	}
	function assertBinaryExpression(node, opts) {
	  assert("BinaryExpression", node, opts);
	}
	function assertInterpreterDirective(node, opts) {
	  assert("InterpreterDirective", node, opts);
	}
	function assertDirective(node, opts) {
	  assert("Directive", node, opts);
	}
	function assertDirectiveLiteral(node, opts) {
	  assert("DirectiveLiteral", node, opts);
	}
	function assertBlockStatement(node, opts) {
	  assert("BlockStatement", node, opts);
	}
	function assertBreakStatement(node, opts) {
	  assert("BreakStatement", node, opts);
	}
	function assertCallExpression(node, opts) {
	  assert("CallExpression", node, opts);
	}
	function assertCatchClause(node, opts) {
	  assert("CatchClause", node, opts);
	}
	function assertConditionalExpression(node, opts) {
	  assert("ConditionalExpression", node, opts);
	}
	function assertContinueStatement(node, opts) {
	  assert("ContinueStatement", node, opts);
	}
	function assertDebuggerStatement(node, opts) {
	  assert("DebuggerStatement", node, opts);
	}
	function assertDoWhileStatement(node, opts) {
	  assert("DoWhileStatement", node, opts);
	}
	function assertEmptyStatement(node, opts) {
	  assert("EmptyStatement", node, opts);
	}
	function assertExpressionStatement(node, opts) {
	  assert("ExpressionStatement", node, opts);
	}
	function assertFile(node, opts) {
	  assert("File", node, opts);
	}
	function assertForInStatement(node, opts) {
	  assert("ForInStatement", node, opts);
	}
	function assertForStatement(node, opts) {
	  assert("ForStatement", node, opts);
	}
	function assertFunctionDeclaration(node, opts) {
	  assert("FunctionDeclaration", node, opts);
	}
	function assertFunctionExpression(node, opts) {
	  assert("FunctionExpression", node, opts);
	}
	function assertIdentifier(node, opts) {
	  assert("Identifier", node, opts);
	}
	function assertIfStatement(node, opts) {
	  assert("IfStatement", node, opts);
	}
	function assertLabeledStatement(node, opts) {
	  assert("LabeledStatement", node, opts);
	}
	function assertStringLiteral(node, opts) {
	  assert("StringLiteral", node, opts);
	}
	function assertNumericLiteral(node, opts) {
	  assert("NumericLiteral", node, opts);
	}
	function assertNullLiteral(node, opts) {
	  assert("NullLiteral", node, opts);
	}
	function assertBooleanLiteral(node, opts) {
	  assert("BooleanLiteral", node, opts);
	}
	function assertRegExpLiteral(node, opts) {
	  assert("RegExpLiteral", node, opts);
	}
	function assertLogicalExpression(node, opts) {
	  assert("LogicalExpression", node, opts);
	}
	function assertMemberExpression(node, opts) {
	  assert("MemberExpression", node, opts);
	}
	function assertNewExpression(node, opts) {
	  assert("NewExpression", node, opts);
	}
	function assertProgram(node, opts) {
	  assert("Program", node, opts);
	}
	function assertObjectExpression(node, opts) {
	  assert("ObjectExpression", node, opts);
	}
	function assertObjectMethod(node, opts) {
	  assert("ObjectMethod", node, opts);
	}
	function assertObjectProperty(node, opts) {
	  assert("ObjectProperty", node, opts);
	}
	function assertRestElement(node, opts) {
	  assert("RestElement", node, opts);
	}
	function assertReturnStatement(node, opts) {
	  assert("ReturnStatement", node, opts);
	}
	function assertSequenceExpression(node, opts) {
	  assert("SequenceExpression", node, opts);
	}
	function assertParenthesizedExpression(node, opts) {
	  assert("ParenthesizedExpression", node, opts);
	}
	function assertSwitchCase(node, opts) {
	  assert("SwitchCase", node, opts);
	}
	function assertSwitchStatement(node, opts) {
	  assert("SwitchStatement", node, opts);
	}
	function assertThisExpression(node, opts) {
	  assert("ThisExpression", node, opts);
	}
	function assertThrowStatement(node, opts) {
	  assert("ThrowStatement", node, opts);
	}
	function assertTryStatement(node, opts) {
	  assert("TryStatement", node, opts);
	}
	function assertUnaryExpression(node, opts) {
	  assert("UnaryExpression", node, opts);
	}
	function assertUpdateExpression(node, opts) {
	  assert("UpdateExpression", node, opts);
	}
	function assertVariableDeclaration(node, opts) {
	  assert("VariableDeclaration", node, opts);
	}
	function assertVariableDeclarator(node, opts) {
	  assert("VariableDeclarator", node, opts);
	}
	function assertWhileStatement(node, opts) {
	  assert("WhileStatement", node, opts);
	}
	function assertWithStatement(node, opts) {
	  assert("WithStatement", node, opts);
	}
	function assertAssignmentPattern(node, opts) {
	  assert("AssignmentPattern", node, opts);
	}
	function assertArrayPattern(node, opts) {
	  assert("ArrayPattern", node, opts);
	}
	function assertArrowFunctionExpression(node, opts) {
	  assert("ArrowFunctionExpression", node, opts);
	}
	function assertClassBody(node, opts) {
	  assert("ClassBody", node, opts);
	}
	function assertClassExpression(node, opts) {
	  assert("ClassExpression", node, opts);
	}
	function assertClassDeclaration(node, opts) {
	  assert("ClassDeclaration", node, opts);
	}
	function assertExportAllDeclaration(node, opts) {
	  assert("ExportAllDeclaration", node, opts);
	}
	function assertExportDefaultDeclaration(node, opts) {
	  assert("ExportDefaultDeclaration", node, opts);
	}
	function assertExportNamedDeclaration(node, opts) {
	  assert("ExportNamedDeclaration", node, opts);
	}
	function assertExportSpecifier(node, opts) {
	  assert("ExportSpecifier", node, opts);
	}
	function assertForOfStatement(node, opts) {
	  assert("ForOfStatement", node, opts);
	}
	function assertImportDeclaration(node, opts) {
	  assert("ImportDeclaration", node, opts);
	}
	function assertImportDefaultSpecifier(node, opts) {
	  assert("ImportDefaultSpecifier", node, opts);
	}
	function assertImportNamespaceSpecifier(node, opts) {
	  assert("ImportNamespaceSpecifier", node, opts);
	}
	function assertImportSpecifier(node, opts) {
	  assert("ImportSpecifier", node, opts);
	}
	function assertImportExpression(node, opts) {
	  assert("ImportExpression", node, opts);
	}
	function assertMetaProperty(node, opts) {
	  assert("MetaProperty", node, opts);
	}
	function assertClassMethod(node, opts) {
	  assert("ClassMethod", node, opts);
	}
	function assertObjectPattern(node, opts) {
	  assert("ObjectPattern", node, opts);
	}
	function assertSpreadElement(node, opts) {
	  assert("SpreadElement", node, opts);
	}
	function assertSuper(node, opts) {
	  assert("Super", node, opts);
	}
	function assertTaggedTemplateExpression(node, opts) {
	  assert("TaggedTemplateExpression", node, opts);
	}
	function assertTemplateElement(node, opts) {
	  assert("TemplateElement", node, opts);
	}
	function assertTemplateLiteral(node, opts) {
	  assert("TemplateLiteral", node, opts);
	}
	function assertYieldExpression(node, opts) {
	  assert("YieldExpression", node, opts);
	}
	function assertAwaitExpression(node, opts) {
	  assert("AwaitExpression", node, opts);
	}
	function assertImport(node, opts) {
	  assert("Import", node, opts);
	}
	function assertBigIntLiteral(node, opts) {
	  assert("BigIntLiteral", node, opts);
	}
	function assertExportNamespaceSpecifier(node, opts) {
	  assert("ExportNamespaceSpecifier", node, opts);
	}
	function assertOptionalMemberExpression(node, opts) {
	  assert("OptionalMemberExpression", node, opts);
	}
	function assertOptionalCallExpression(node, opts) {
	  assert("OptionalCallExpression", node, opts);
	}
	function assertClassProperty(node, opts) {
	  assert("ClassProperty", node, opts);
	}
	function assertClassAccessorProperty(node, opts) {
	  assert("ClassAccessorProperty", node, opts);
	}
	function assertClassPrivateProperty(node, opts) {
	  assert("ClassPrivateProperty", node, opts);
	}
	function assertClassPrivateMethod(node, opts) {
	  assert("ClassPrivateMethod", node, opts);
	}
	function assertPrivateName(node, opts) {
	  assert("PrivateName", node, opts);
	}
	function assertStaticBlock(node, opts) {
	  assert("StaticBlock", node, opts);
	}
	function assertAnyTypeAnnotation(node, opts) {
	  assert("AnyTypeAnnotation", node, opts);
	}
	function assertArrayTypeAnnotation(node, opts) {
	  assert("ArrayTypeAnnotation", node, opts);
	}
	function assertBooleanTypeAnnotation(node, opts) {
	  assert("BooleanTypeAnnotation", node, opts);
	}
	function assertBooleanLiteralTypeAnnotation(node, opts) {
	  assert("BooleanLiteralTypeAnnotation", node, opts);
	}
	function assertNullLiteralTypeAnnotation(node, opts) {
	  assert("NullLiteralTypeAnnotation", node, opts);
	}
	function assertClassImplements(node, opts) {
	  assert("ClassImplements", node, opts);
	}
	function assertDeclareClass(node, opts) {
	  assert("DeclareClass", node, opts);
	}
	function assertDeclareFunction(node, opts) {
	  assert("DeclareFunction", node, opts);
	}
	function assertDeclareInterface(node, opts) {
	  assert("DeclareInterface", node, opts);
	}
	function assertDeclareModule(node, opts) {
	  assert("DeclareModule", node, opts);
	}
	function assertDeclareModuleExports(node, opts) {
	  assert("DeclareModuleExports", node, opts);
	}
	function assertDeclareTypeAlias(node, opts) {
	  assert("DeclareTypeAlias", node, opts);
	}
	function assertDeclareOpaqueType(node, opts) {
	  assert("DeclareOpaqueType", node, opts);
	}
	function assertDeclareVariable(node, opts) {
	  assert("DeclareVariable", node, opts);
	}
	function assertDeclareExportDeclaration(node, opts) {
	  assert("DeclareExportDeclaration", node, opts);
	}
	function assertDeclareExportAllDeclaration(node, opts) {
	  assert("DeclareExportAllDeclaration", node, opts);
	}
	function assertDeclaredPredicate(node, opts) {
	  assert("DeclaredPredicate", node, opts);
	}
	function assertExistsTypeAnnotation(node, opts) {
	  assert("ExistsTypeAnnotation", node, opts);
	}
	function assertFunctionTypeAnnotation(node, opts) {
	  assert("FunctionTypeAnnotation", node, opts);
	}
	function assertFunctionTypeParam(node, opts) {
	  assert("FunctionTypeParam", node, opts);
	}
	function assertGenericTypeAnnotation(node, opts) {
	  assert("GenericTypeAnnotation", node, opts);
	}
	function assertInferredPredicate(node, opts) {
	  assert("InferredPredicate", node, opts);
	}
	function assertInterfaceExtends(node, opts) {
	  assert("InterfaceExtends", node, opts);
	}
	function assertInterfaceDeclaration(node, opts) {
	  assert("InterfaceDeclaration", node, opts);
	}
	function assertInterfaceTypeAnnotation(node, opts) {
	  assert("InterfaceTypeAnnotation", node, opts);
	}
	function assertIntersectionTypeAnnotation(node, opts) {
	  assert("IntersectionTypeAnnotation", node, opts);
	}
	function assertMixedTypeAnnotation(node, opts) {
	  assert("MixedTypeAnnotation", node, opts);
	}
	function assertEmptyTypeAnnotation(node, opts) {
	  assert("EmptyTypeAnnotation", node, opts);
	}
	function assertNullableTypeAnnotation(node, opts) {
	  assert("NullableTypeAnnotation", node, opts);
	}
	function assertNumberLiteralTypeAnnotation(node, opts) {
	  assert("NumberLiteralTypeAnnotation", node, opts);
	}
	function assertNumberTypeAnnotation(node, opts) {
	  assert("NumberTypeAnnotation", node, opts);
	}
	function assertObjectTypeAnnotation(node, opts) {
	  assert("ObjectTypeAnnotation", node, opts);
	}
	function assertObjectTypeInternalSlot(node, opts) {
	  assert("ObjectTypeInternalSlot", node, opts);
	}
	function assertObjectTypeCallProperty(node, opts) {
	  assert("ObjectTypeCallProperty", node, opts);
	}
	function assertObjectTypeIndexer(node, opts) {
	  assert("ObjectTypeIndexer", node, opts);
	}
	function assertObjectTypeProperty(node, opts) {
	  assert("ObjectTypeProperty", node, opts);
	}
	function assertObjectTypeSpreadProperty(node, opts) {
	  assert("ObjectTypeSpreadProperty", node, opts);
	}
	function assertOpaqueType(node, opts) {
	  assert("OpaqueType", node, opts);
	}
	function assertQualifiedTypeIdentifier(node, opts) {
	  assert("QualifiedTypeIdentifier", node, opts);
	}
	function assertStringLiteralTypeAnnotation(node, opts) {
	  assert("StringLiteralTypeAnnotation", node, opts);
	}
	function assertStringTypeAnnotation(node, opts) {
	  assert("StringTypeAnnotation", node, opts);
	}
	function assertSymbolTypeAnnotation(node, opts) {
	  assert("SymbolTypeAnnotation", node, opts);
	}
	function assertThisTypeAnnotation(node, opts) {
	  assert("ThisTypeAnnotation", node, opts);
	}
	function assertTupleTypeAnnotation(node, opts) {
	  assert("TupleTypeAnnotation", node, opts);
	}
	function assertTypeofTypeAnnotation(node, opts) {
	  assert("TypeofTypeAnnotation", node, opts);
	}
	function assertTypeAlias(node, opts) {
	  assert("TypeAlias", node, opts);
	}
	function assertTypeAnnotation(node, opts) {
	  assert("TypeAnnotation", node, opts);
	}
	function assertTypeCastExpression(node, opts) {
	  assert("TypeCastExpression", node, opts);
	}
	function assertTypeParameter(node, opts) {
	  assert("TypeParameter", node, opts);
	}
	function assertTypeParameterDeclaration(node, opts) {
	  assert("TypeParameterDeclaration", node, opts);
	}
	function assertTypeParameterInstantiation(node, opts) {
	  assert("TypeParameterInstantiation", node, opts);
	}
	function assertUnionTypeAnnotation(node, opts) {
	  assert("UnionTypeAnnotation", node, opts);
	}
	function assertVariance(node, opts) {
	  assert("Variance", node, opts);
	}
	function assertVoidTypeAnnotation(node, opts) {
	  assert("VoidTypeAnnotation", node, opts);
	}
	function assertEnumDeclaration(node, opts) {
	  assert("EnumDeclaration", node, opts);
	}
	function assertEnumBooleanBody(node, opts) {
	  assert("EnumBooleanBody", node, opts);
	}
	function assertEnumNumberBody(node, opts) {
	  assert("EnumNumberBody", node, opts);
	}
	function assertEnumStringBody(node, opts) {
	  assert("EnumStringBody", node, opts);
	}
	function assertEnumSymbolBody(node, opts) {
	  assert("EnumSymbolBody", node, opts);
	}
	function assertEnumBooleanMember(node, opts) {
	  assert("EnumBooleanMember", node, opts);
	}
	function assertEnumNumberMember(node, opts) {
	  assert("EnumNumberMember", node, opts);
	}
	function assertEnumStringMember(node, opts) {
	  assert("EnumStringMember", node, opts);
	}
	function assertEnumDefaultedMember(node, opts) {
	  assert("EnumDefaultedMember", node, opts);
	}
	function assertIndexedAccessType(node, opts) {
	  assert("IndexedAccessType", node, opts);
	}
	function assertOptionalIndexedAccessType(node, opts) {
	  assert("OptionalIndexedAccessType", node, opts);
	}
	function assertJSXAttribute(node, opts) {
	  assert("JSXAttribute", node, opts);
	}
	function assertJSXClosingElement(node, opts) {
	  assert("JSXClosingElement", node, opts);
	}
	function assertJSXElement(node, opts) {
	  assert("JSXElement", node, opts);
	}
	function assertJSXEmptyExpression(node, opts) {
	  assert("JSXEmptyExpression", node, opts);
	}
	function assertJSXExpressionContainer(node, opts) {
	  assert("JSXExpressionContainer", node, opts);
	}
	function assertJSXSpreadChild(node, opts) {
	  assert("JSXSpreadChild", node, opts);
	}
	function assertJSXIdentifier(node, opts) {
	  assert("JSXIdentifier", node, opts);
	}
	function assertJSXMemberExpression(node, opts) {
	  assert("JSXMemberExpression", node, opts);
	}
	function assertJSXNamespacedName(node, opts) {
	  assert("JSXNamespacedName", node, opts);
	}
	function assertJSXOpeningElement(node, opts) {
	  assert("JSXOpeningElement", node, opts);
	}
	function assertJSXSpreadAttribute(node, opts) {
	  assert("JSXSpreadAttribute", node, opts);
	}
	function assertJSXText(node, opts) {
	  assert("JSXText", node, opts);
	}
	function assertJSXFragment(node, opts) {
	  assert("JSXFragment", node, opts);
	}
	function assertJSXOpeningFragment(node, opts) {
	  assert("JSXOpeningFragment", node, opts);
	}
	function assertJSXClosingFragment(node, opts) {
	  assert("JSXClosingFragment", node, opts);
	}
	function assertNoop(node, opts) {
	  assert("Noop", node, opts);
	}
	function assertPlaceholder(node, opts) {
	  assert("Placeholder", node, opts);
	}
	function assertV8IntrinsicIdentifier(node, opts) {
	  assert("V8IntrinsicIdentifier", node, opts);
	}
	function assertArgumentPlaceholder(node, opts) {
	  assert("ArgumentPlaceholder", node, opts);
	}
	function assertBindExpression(node, opts) {
	  assert("BindExpression", node, opts);
	}
	function assertImportAttribute(node, opts) {
	  assert("ImportAttribute", node, opts);
	}
	function assertDecorator(node, opts) {
	  assert("Decorator", node, opts);
	}
	function assertDoExpression(node, opts) {
	  assert("DoExpression", node, opts);
	}
	function assertExportDefaultSpecifier(node, opts) {
	  assert("ExportDefaultSpecifier", node, opts);
	}
	function assertRecordExpression(node, opts) {
	  assert("RecordExpression", node, opts);
	}
	function assertTupleExpression(node, opts) {
	  assert("TupleExpression", node, opts);
	}
	function assertDecimalLiteral(node, opts) {
	  assert("DecimalLiteral", node, opts);
	}
	function assertModuleExpression(node, opts) {
	  assert("ModuleExpression", node, opts);
	}
	function assertTopicReference(node, opts) {
	  assert("TopicReference", node, opts);
	}
	function assertPipelineTopicExpression(node, opts) {
	  assert("PipelineTopicExpression", node, opts);
	}
	function assertPipelineBareFunction(node, opts) {
	  assert("PipelineBareFunction", node, opts);
	}
	function assertPipelinePrimaryTopicReference(node, opts) {
	  assert("PipelinePrimaryTopicReference", node, opts);
	}
	function assertTSParameterProperty(node, opts) {
	  assert("TSParameterProperty", node, opts);
	}
	function assertTSDeclareFunction(node, opts) {
	  assert("TSDeclareFunction", node, opts);
	}
	function assertTSDeclareMethod(node, opts) {
	  assert("TSDeclareMethod", node, opts);
	}
	function assertTSQualifiedName(node, opts) {
	  assert("TSQualifiedName", node, opts);
	}
	function assertTSCallSignatureDeclaration(node, opts) {
	  assert("TSCallSignatureDeclaration", node, opts);
	}
	function assertTSConstructSignatureDeclaration(node, opts) {
	  assert("TSConstructSignatureDeclaration", node, opts);
	}
	function assertTSPropertySignature(node, opts) {
	  assert("TSPropertySignature", node, opts);
	}
	function assertTSMethodSignature(node, opts) {
	  assert("TSMethodSignature", node, opts);
	}
	function assertTSIndexSignature(node, opts) {
	  assert("TSIndexSignature", node, opts);
	}
	function assertTSAnyKeyword(node, opts) {
	  assert("TSAnyKeyword", node, opts);
	}
	function assertTSBooleanKeyword(node, opts) {
	  assert("TSBooleanKeyword", node, opts);
	}
	function assertTSBigIntKeyword(node, opts) {
	  assert("TSBigIntKeyword", node, opts);
	}
	function assertTSIntrinsicKeyword(node, opts) {
	  assert("TSIntrinsicKeyword", node, opts);
	}
	function assertTSNeverKeyword(node, opts) {
	  assert("TSNeverKeyword", node, opts);
	}
	function assertTSNullKeyword(node, opts) {
	  assert("TSNullKeyword", node, opts);
	}
	function assertTSNumberKeyword(node, opts) {
	  assert("TSNumberKeyword", node, opts);
	}
	function assertTSObjectKeyword(node, opts) {
	  assert("TSObjectKeyword", node, opts);
	}
	function assertTSStringKeyword(node, opts) {
	  assert("TSStringKeyword", node, opts);
	}
	function assertTSSymbolKeyword(node, opts) {
	  assert("TSSymbolKeyword", node, opts);
	}
	function assertTSUndefinedKeyword(node, opts) {
	  assert("TSUndefinedKeyword", node, opts);
	}
	function assertTSUnknownKeyword(node, opts) {
	  assert("TSUnknownKeyword", node, opts);
	}
	function assertTSVoidKeyword(node, opts) {
	  assert("TSVoidKeyword", node, opts);
	}
	function assertTSThisType(node, opts) {
	  assert("TSThisType", node, opts);
	}
	function assertTSFunctionType(node, opts) {
	  assert("TSFunctionType", node, opts);
	}
	function assertTSConstructorType(node, opts) {
	  assert("TSConstructorType", node, opts);
	}
	function assertTSTypeReference(node, opts) {
	  assert("TSTypeReference", node, opts);
	}
	function assertTSTypePredicate(node, opts) {
	  assert("TSTypePredicate", node, opts);
	}
	function assertTSTypeQuery(node, opts) {
	  assert("TSTypeQuery", node, opts);
	}
	function assertTSTypeLiteral(node, opts) {
	  assert("TSTypeLiteral", node, opts);
	}
	function assertTSArrayType(node, opts) {
	  assert("TSArrayType", node, opts);
	}
	function assertTSTupleType(node, opts) {
	  assert("TSTupleType", node, opts);
	}
	function assertTSOptionalType(node, opts) {
	  assert("TSOptionalType", node, opts);
	}
	function assertTSRestType(node, opts) {
	  assert("TSRestType", node, opts);
	}
	function assertTSNamedTupleMember(node, opts) {
	  assert("TSNamedTupleMember", node, opts);
	}
	function assertTSUnionType(node, opts) {
	  assert("TSUnionType", node, opts);
	}
	function assertTSIntersectionType(node, opts) {
	  assert("TSIntersectionType", node, opts);
	}
	function assertTSConditionalType(node, opts) {
	  assert("TSConditionalType", node, opts);
	}
	function assertTSInferType(node, opts) {
	  assert("TSInferType", node, opts);
	}
	function assertTSParenthesizedType(node, opts) {
	  assert("TSParenthesizedType", node, opts);
	}
	function assertTSTypeOperator(node, opts) {
	  assert("TSTypeOperator", node, opts);
	}
	function assertTSIndexedAccessType(node, opts) {
	  assert("TSIndexedAccessType", node, opts);
	}
	function assertTSMappedType(node, opts) {
	  assert("TSMappedType", node, opts);
	}
	function assertTSLiteralType(node, opts) {
	  assert("TSLiteralType", node, opts);
	}
	function assertTSExpressionWithTypeArguments(node, opts) {
	  assert("TSExpressionWithTypeArguments", node, opts);
	}
	function assertTSInterfaceDeclaration(node, opts) {
	  assert("TSInterfaceDeclaration", node, opts);
	}
	function assertTSInterfaceBody(node, opts) {
	  assert("TSInterfaceBody", node, opts);
	}
	function assertTSTypeAliasDeclaration(node, opts) {
	  assert("TSTypeAliasDeclaration", node, opts);
	}
	function assertTSInstantiationExpression(node, opts) {
	  assert("TSInstantiationExpression", node, opts);
	}
	function assertTSAsExpression(node, opts) {
	  assert("TSAsExpression", node, opts);
	}
	function assertTSSatisfiesExpression(node, opts) {
	  assert("TSSatisfiesExpression", node, opts);
	}
	function assertTSTypeAssertion(node, opts) {
	  assert("TSTypeAssertion", node, opts);
	}
	function assertTSEnumDeclaration(node, opts) {
	  assert("TSEnumDeclaration", node, opts);
	}
	function assertTSEnumMember(node, opts) {
	  assert("TSEnumMember", node, opts);
	}
	function assertTSModuleDeclaration(node, opts) {
	  assert("TSModuleDeclaration", node, opts);
	}
	function assertTSModuleBlock(node, opts) {
	  assert("TSModuleBlock", node, opts);
	}
	function assertTSImportType(node, opts) {
	  assert("TSImportType", node, opts);
	}
	function assertTSImportEqualsDeclaration(node, opts) {
	  assert("TSImportEqualsDeclaration", node, opts);
	}
	function assertTSExternalModuleReference(node, opts) {
	  assert("TSExternalModuleReference", node, opts);
	}
	function assertTSNonNullExpression(node, opts) {
	  assert("TSNonNullExpression", node, opts);
	}
	function assertTSExportAssignment(node, opts) {
	  assert("TSExportAssignment", node, opts);
	}
	function assertTSNamespaceExportDeclaration(node, opts) {
	  assert("TSNamespaceExportDeclaration", node, opts);
	}
	function assertTSTypeAnnotation(node, opts) {
	  assert("TSTypeAnnotation", node, opts);
	}
	function assertTSTypeParameterInstantiation(node, opts) {
	  assert("TSTypeParameterInstantiation", node, opts);
	}
	function assertTSTypeParameterDeclaration(node, opts) {
	  assert("TSTypeParameterDeclaration", node, opts);
	}
	function assertTSTypeParameter(node, opts) {
	  assert("TSTypeParameter", node, opts);
	}
	function assertStandardized(node, opts) {
	  assert("Standardized", node, opts);
	}
	function assertExpression(node, opts) {
	  assert("Expression", node, opts);
	}
	function assertBinary(node, opts) {
	  assert("Binary", node, opts);
	}
	function assertScopable(node, opts) {
	  assert("Scopable", node, opts);
	}
	function assertBlockParent(node, opts) {
	  assert("BlockParent", node, opts);
	}
	function assertBlock(node, opts) {
	  assert("Block", node, opts);
	}
	function assertStatement(node, opts) {
	  assert("Statement", node, opts);
	}
	function assertTerminatorless(node, opts) {
	  assert("Terminatorless", node, opts);
	}
	function assertCompletionStatement(node, opts) {
	  assert("CompletionStatement", node, opts);
	}
	function assertConditional(node, opts) {
	  assert("Conditional", node, opts);
	}
	function assertLoop(node, opts) {
	  assert("Loop", node, opts);
	}
	function assertWhile(node, opts) {
	  assert("While", node, opts);
	}
	function assertExpressionWrapper(node, opts) {
	  assert("ExpressionWrapper", node, opts);
	}
	function assertFor(node, opts) {
	  assert("For", node, opts);
	}
	function assertForXStatement(node, opts) {
	  assert("ForXStatement", node, opts);
	}
	function assertFunction(node, opts) {
	  assert("Function", node, opts);
	}
	function assertFunctionParent(node, opts) {
	  assert("FunctionParent", node, opts);
	}
	function assertPureish(node, opts) {
	  assert("Pureish", node, opts);
	}
	function assertDeclaration(node, opts) {
	  assert("Declaration", node, opts);
	}
	function assertPatternLike(node, opts) {
	  assert("PatternLike", node, opts);
	}
	function assertLVal(node, opts) {
	  assert("LVal", node, opts);
	}
	function assertTSEntityName(node, opts) {
	  assert("TSEntityName", node, opts);
	}
	function assertLiteral(node, opts) {
	  assert("Literal", node, opts);
	}
	function assertImmutable(node, opts) {
	  assert("Immutable", node, opts);
	}
	function assertUserWhitespacable(node, opts) {
	  assert("UserWhitespacable", node, opts);
	}
	function assertMethod(node, opts) {
	  assert("Method", node, opts);
	}
	function assertObjectMember(node, opts) {
	  assert("ObjectMember", node, opts);
	}
	function assertProperty(node, opts) {
	  assert("Property", node, opts);
	}
	function assertUnaryLike(node, opts) {
	  assert("UnaryLike", node, opts);
	}
	function assertPattern(node, opts) {
	  assert("Pattern", node, opts);
	}
	function assertClass(node, opts) {
	  assert("Class", node, opts);
	}
	function assertImportOrExportDeclaration(node, opts) {
	  assert("ImportOrExportDeclaration", node, opts);
	}
	function assertExportDeclaration(node, opts) {
	  assert("ExportDeclaration", node, opts);
	}
	function assertModuleSpecifier(node, opts) {
	  assert("ModuleSpecifier", node, opts);
	}
	function assertAccessor(node, opts) {
	  assert("Accessor", node, opts);
	}
	function assertPrivate(node, opts) {
	  assert("Private", node, opts);
	}
	function assertFlow(node, opts) {
	  assert("Flow", node, opts);
	}
	function assertFlowType(node, opts) {
	  assert("FlowType", node, opts);
	}
	function assertFlowBaseAnnotation(node, opts) {
	  assert("FlowBaseAnnotation", node, opts);
	}
	function assertFlowDeclaration(node, opts) {
	  assert("FlowDeclaration", node, opts);
	}
	function assertFlowPredicate(node, opts) {
	  assert("FlowPredicate", node, opts);
	}
	function assertEnumBody(node, opts) {
	  assert("EnumBody", node, opts);
	}
	function assertEnumMember(node, opts) {
	  assert("EnumMember", node, opts);
	}
	function assertJSX(node, opts) {
	  assert("JSX", node, opts);
	}
	function assertMiscellaneous(node, opts) {
	  assert("Miscellaneous", node, opts);
	}
	function assertTypeScript(node, opts) {
	  assert("TypeScript", node, opts);
	}
	function assertTSTypeElement(node, opts) {
	  assert("TSTypeElement", node, opts);
	}
	function assertTSType(node, opts) {
	  assert("TSType", node, opts);
	}
	function assertTSBaseType(node, opts) {
	  assert("TSBaseType", node, opts);
	}
	function assertNumberLiteral(node, opts) {
	  (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
	  assert("NumberLiteral", node, opts);
	}
	function assertRegexLiteral(node, opts) {
	  (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
	  assert("RegexLiteral", node, opts);
	}
	function assertRestProperty(node, opts) {
	  (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
	  assert("RestProperty", node, opts);
	}
	function assertSpreadProperty(node, opts) {
	  (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
	  assert("SpreadProperty", node, opts);
	}
	function assertModuleDeclaration(node, opts) {
	  (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
	  assert("ModuleDeclaration", node, opts);
	}

	
	return generated$1;
}

var createTypeAnnotationBasedOnTypeof = {};

var hasRequiredCreateTypeAnnotationBasedOnTypeof;

function requireCreateTypeAnnotationBasedOnTypeof () {
	if (hasRequiredCreateTypeAnnotationBasedOnTypeof) return createTypeAnnotationBasedOnTypeof;
	hasRequiredCreateTypeAnnotationBasedOnTypeof = 1;

	Object.defineProperty(createTypeAnnotationBasedOnTypeof, "__esModule", {
	  value: true
	});
	createTypeAnnotationBasedOnTypeof.default = void 0;
	var _index = requireGenerated$2();
	createTypeAnnotationBasedOnTypeof.default = createTypeAnnotationBasedOnTypeof$1;
	function createTypeAnnotationBasedOnTypeof$1(type) {
	  switch (type) {
	    case "string":
	      return (0, _index.stringTypeAnnotation)();
	    case "number":
	      return (0, _index.numberTypeAnnotation)();
	    case "undefined":
	      return (0, _index.voidTypeAnnotation)();
	    case "boolean":
	      return (0, _index.booleanTypeAnnotation)();
	    case "function":
	      return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
	    case "object":
	      return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
	    case "symbol":
	      return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
	    case "bigint":
	      return (0, _index.anyTypeAnnotation)();
	  }
	  throw new Error("Invalid typeof value: " + type);
	}

	
	return createTypeAnnotationBasedOnTypeof;
}

var createFlowUnionType = {};

var removeTypeDuplicates$1 = {};

var hasRequiredRemoveTypeDuplicates$1;

function requireRemoveTypeDuplicates$1 () {
	if (hasRequiredRemoveTypeDuplicates$1) return removeTypeDuplicates$1;
	hasRequiredRemoveTypeDuplicates$1 = 1;

	Object.defineProperty(removeTypeDuplicates$1, "__esModule", {
	  value: true
	});
	removeTypeDuplicates$1.default = removeTypeDuplicates;
	var _index = requireGenerated$3();
	function getQualifiedName(node) {
	  return (0, _index.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
	}
	function removeTypeDuplicates(nodesIn) {
	  const nodes = Array.from(nodesIn);
	  const generics = new Map();
	  const bases = new Map();
	  const typeGroups = new Set();
	  const types = [];
	  for (let i = 0; i < nodes.length; i++) {
	    const node = nodes[i];
	    if (!node) continue;
	    if (types.includes(node)) {
	      continue;
	    }
	    if ((0, _index.isAnyTypeAnnotation)(node)) {
	      return [node];
	    }
	    if ((0, _index.isFlowBaseAnnotation)(node)) {
	      bases.set(node.type, node);
	      continue;
	    }
	    if ((0, _index.isUnionTypeAnnotation)(node)) {
	      if (!typeGroups.has(node.types)) {
	        nodes.push(...node.types);
	        typeGroups.add(node.types);
	      }
	      continue;
	    }
	    if ((0, _index.isGenericTypeAnnotation)(node)) {
	      const name = getQualifiedName(node.id);
	      if (generics.has(name)) {
	        let existing = generics.get(name);
	        if (existing.typeParameters) {
	          if (node.typeParameters) {
	            existing.typeParameters.params.push(...node.typeParameters.params);
	            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
	          }
	        } else {
	          existing = node.typeParameters;
	        }
	      } else {
	        generics.set(name, node);
	      }
	      continue;
	    }
	    types.push(node);
	  }
	  for (const [, baseType] of bases) {
	    types.push(baseType);
	  }
	  for (const [, genericName] of generics) {
	    types.push(genericName);
	  }
	  return types;
	}

	
	return removeTypeDuplicates$1;
}

var hasRequiredCreateFlowUnionType;

function requireCreateFlowUnionType () {
	if (hasRequiredCreateFlowUnionType) return createFlowUnionType;
	hasRequiredCreateFlowUnionType = 1;

	Object.defineProperty(createFlowUnionType, "__esModule", {
	  value: true
	});
	createFlowUnionType.default = createFlowUnionType$1;
	var _index = requireGenerated$2();
	var _removeTypeDuplicates = requireRemoveTypeDuplicates$1();
	function createFlowUnionType$1(types) {
	  const flattened = (0, _removeTypeDuplicates.default)(types);
	  if (flattened.length === 1) {
	    return flattened[0];
	  } else {
	    return (0, _index.unionTypeAnnotation)(flattened);
	  }
	}

	
	return createFlowUnionType;
}

var createTSUnionType = {};

var removeTypeDuplicates = {};

var hasRequiredRemoveTypeDuplicates;

function requireRemoveTypeDuplicates () {
	if (hasRequiredRemoveTypeDuplicates) return removeTypeDuplicates;
	hasRequiredRemoveTypeDuplicates = 1;

	Object.defineProperty(removeTypeDuplicates, "__esModule", {
	  value: true
	});
	removeTypeDuplicates.default = removeTypeDuplicates$1;
	var _index = requireGenerated$3();
	function getQualifiedName(node) {
	  return (0, _index.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;
	}
	function removeTypeDuplicates$1(nodesIn) {
	  const nodes = Array.from(nodesIn);
	  const generics = new Map();
	  const bases = new Map();
	  const typeGroups = new Set();
	  const types = [];
	  for (let i = 0; i < nodes.length; i++) {
	    const node = nodes[i];
	    if (!node) continue;
	    if (types.includes(node)) {
	      continue;
	    }
	    if ((0, _index.isTSAnyKeyword)(node)) {
	      return [node];
	    }
	    if ((0, _index.isTSBaseType)(node)) {
	      bases.set(node.type, node);
	      continue;
	    }
	    if ((0, _index.isTSUnionType)(node)) {
	      if (!typeGroups.has(node.types)) {
	        nodes.push(...node.types);
	        typeGroups.add(node.types);
	      }
	      continue;
	    }
	    if ((0, _index.isTSTypeReference)(node) && node.typeParameters) {
	      const name = getQualifiedName(node.typeName);
	      if (generics.has(name)) {
	        let existing = generics.get(name);
	        if (existing.typeParameters) {
	          if (node.typeParameters) {
	            existing.typeParameters.params.push(...node.typeParameters.params);
	            existing.typeParameters.params = removeTypeDuplicates$1(existing.typeParameters.params);
	          }
	        } else {
	          existing = node.typeParameters;
	        }
	      } else {
	        generics.set(name, node);
	      }
	      continue;
	    }
	    types.push(node);
	  }
	  for (const [, baseType] of bases) {
	    types.push(baseType);
	  }
	  for (const [, genericName] of generics) {
	    types.push(genericName);
	  }
	  return types;
	}

	
	return removeTypeDuplicates;
}

var hasRequiredCreateTSUnionType;

function requireCreateTSUnionType () {
	if (hasRequiredCreateTSUnionType) return createTSUnionType;
	hasRequiredCreateTSUnionType = 1;

	Object.defineProperty(createTSUnionType, "__esModule", {
	  value: true
	});
	createTSUnionType.default = createTSUnionType$1;
	var _index = requireGenerated$2();
	var _removeTypeDuplicates = requireRemoveTypeDuplicates();
	var _index2 = requireGenerated$3();
	function createTSUnionType$1(typeAnnotations) {
	  const types = typeAnnotations.map(type => {
	    return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
	  });
	  const flattened = (0, _removeTypeDuplicates.default)(types);
	  if (flattened.length === 1) {
	    return flattened[0];
	  } else {
	    return (0, _index.tsUnionType)(flattened);
	  }
	}

	
	return createTSUnionType;
}

var uppercase = {};

var hasRequiredUppercase;

function requireUppercase () {
	if (hasRequiredUppercase) return uppercase;
	hasRequiredUppercase = 1;
	(function (exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports, "AnyTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.anyTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "ArgumentPlaceholder", {
		  enumerable: true,
		  get: function () {
		    return _index.argumentPlaceholder;
		  }
		});
		Object.defineProperty(exports, "ArrayExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.arrayExpression;
		  }
		});
		Object.defineProperty(exports, "ArrayPattern", {
		  enumerable: true,
		  get: function () {
		    return _index.arrayPattern;
		  }
		});
		Object.defineProperty(exports, "ArrayTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.arrayTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "ArrowFunctionExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.arrowFunctionExpression;
		  }
		});
		Object.defineProperty(exports, "AssignmentExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.assignmentExpression;
		  }
		});
		Object.defineProperty(exports, "AssignmentPattern", {
		  enumerable: true,
		  get: function () {
		    return _index.assignmentPattern;
		  }
		});
		Object.defineProperty(exports, "AwaitExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.awaitExpression;
		  }
		});
		Object.defineProperty(exports, "BigIntLiteral", {
		  enumerable: true,
		  get: function () {
		    return _index.bigIntLiteral;
		  }
		});
		Object.defineProperty(exports, "BinaryExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.binaryExpression;
		  }
		});
		Object.defineProperty(exports, "BindExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.bindExpression;
		  }
		});
		Object.defineProperty(exports, "BlockStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.blockStatement;
		  }
		});
		Object.defineProperty(exports, "BooleanLiteral", {
		  enumerable: true,
		  get: function () {
		    return _index.booleanLiteral;
		  }
		});
		Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.booleanLiteralTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "BooleanTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.booleanTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "BreakStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.breakStatement;
		  }
		});
		Object.defineProperty(exports, "CallExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.callExpression;
		  }
		});
		Object.defineProperty(exports, "CatchClause", {
		  enumerable: true,
		  get: function () {
		    return _index.catchClause;
		  }
		});
		Object.defineProperty(exports, "ClassAccessorProperty", {
		  enumerable: true,
		  get: function () {
		    return _index.classAccessorProperty;
		  }
		});
		Object.defineProperty(exports, "ClassBody", {
		  enumerable: true,
		  get: function () {
		    return _index.classBody;
		  }
		});
		Object.defineProperty(exports, "ClassDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.classDeclaration;
		  }
		});
		Object.defineProperty(exports, "ClassExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.classExpression;
		  }
		});
		Object.defineProperty(exports, "ClassImplements", {
		  enumerable: true,
		  get: function () {
		    return _index.classImplements;
		  }
		});
		Object.defineProperty(exports, "ClassMethod", {
		  enumerable: true,
		  get: function () {
		    return _index.classMethod;
		  }
		});
		Object.defineProperty(exports, "ClassPrivateMethod", {
		  enumerable: true,
		  get: function () {
		    return _index.classPrivateMethod;
		  }
		});
		Object.defineProperty(exports, "ClassPrivateProperty", {
		  enumerable: true,
		  get: function () {
		    return _index.classPrivateProperty;
		  }
		});
		Object.defineProperty(exports, "ClassProperty", {
		  enumerable: true,
		  get: function () {
		    return _index.classProperty;
		  }
		});
		Object.defineProperty(exports, "ConditionalExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.conditionalExpression;
		  }
		});
		Object.defineProperty(exports, "ContinueStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.continueStatement;
		  }
		});
		Object.defineProperty(exports, "DebuggerStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.debuggerStatement;
		  }
		});
		Object.defineProperty(exports, "DecimalLiteral", {
		  enumerable: true,
		  get: function () {
		    return _index.decimalLiteral;
		  }
		});
		Object.defineProperty(exports, "DeclareClass", {
		  enumerable: true,
		  get: function () {
		    return _index.declareClass;
		  }
		});
		Object.defineProperty(exports, "DeclareExportAllDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.declareExportAllDeclaration;
		  }
		});
		Object.defineProperty(exports, "DeclareExportDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.declareExportDeclaration;
		  }
		});
		Object.defineProperty(exports, "DeclareFunction", {
		  enumerable: true,
		  get: function () {
		    return _index.declareFunction;
		  }
		});
		Object.defineProperty(exports, "DeclareInterface", {
		  enumerable: true,
		  get: function () {
		    return _index.declareInterface;
		  }
		});
		Object.defineProperty(exports, "DeclareModule", {
		  enumerable: true,
		  get: function () {
		    return _index.declareModule;
		  }
		});
		Object.defineProperty(exports, "DeclareModuleExports", {
		  enumerable: true,
		  get: function () {
		    return _index.declareModuleExports;
		  }
		});
		Object.defineProperty(exports, "DeclareOpaqueType", {
		  enumerable: true,
		  get: function () {
		    return _index.declareOpaqueType;
		  }
		});
		Object.defineProperty(exports, "DeclareTypeAlias", {
		  enumerable: true,
		  get: function () {
		    return _index.declareTypeAlias;
		  }
		});
		Object.defineProperty(exports, "DeclareVariable", {
		  enumerable: true,
		  get: function () {
		    return _index.declareVariable;
		  }
		});
		Object.defineProperty(exports, "DeclaredPredicate", {
		  enumerable: true,
		  get: function () {
		    return _index.declaredPredicate;
		  }
		});
		Object.defineProperty(exports, "Decorator", {
		  enumerable: true,
		  get: function () {
		    return _index.decorator;
		  }
		});
		Object.defineProperty(exports, "Directive", {
		  enumerable: true,
		  get: function () {
		    return _index.directive;
		  }
		});
		Object.defineProperty(exports, "DirectiveLiteral", {
		  enumerable: true,
		  get: function () {
		    return _index.directiveLiteral;
		  }
		});
		Object.defineProperty(exports, "DoExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.doExpression;
		  }
		});
		Object.defineProperty(exports, "DoWhileStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.doWhileStatement;
		  }
		});
		Object.defineProperty(exports, "EmptyStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.emptyStatement;
		  }
		});
		Object.defineProperty(exports, "EmptyTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.emptyTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "EnumBooleanBody", {
		  enumerable: true,
		  get: function () {
		    return _index.enumBooleanBody;
		  }
		});
		Object.defineProperty(exports, "EnumBooleanMember", {
		  enumerable: true,
		  get: function () {
		    return _index.enumBooleanMember;
		  }
		});
		Object.defineProperty(exports, "EnumDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.enumDeclaration;
		  }
		});
		Object.defineProperty(exports, "EnumDefaultedMember", {
		  enumerable: true,
		  get: function () {
		    return _index.enumDefaultedMember;
		  }
		});
		Object.defineProperty(exports, "EnumNumberBody", {
		  enumerable: true,
		  get: function () {
		    return _index.enumNumberBody;
		  }
		});
		Object.defineProperty(exports, "EnumNumberMember", {
		  enumerable: true,
		  get: function () {
		    return _index.enumNumberMember;
		  }
		});
		Object.defineProperty(exports, "EnumStringBody", {
		  enumerable: true,
		  get: function () {
		    return _index.enumStringBody;
		  }
		});
		Object.defineProperty(exports, "EnumStringMember", {
		  enumerable: true,
		  get: function () {
		    return _index.enumStringMember;
		  }
		});
		Object.defineProperty(exports, "EnumSymbolBody", {
		  enumerable: true,
		  get: function () {
		    return _index.enumSymbolBody;
		  }
		});
		Object.defineProperty(exports, "ExistsTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.existsTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "ExportAllDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.exportAllDeclaration;
		  }
		});
		Object.defineProperty(exports, "ExportDefaultDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.exportDefaultDeclaration;
		  }
		});
		Object.defineProperty(exports, "ExportDefaultSpecifier", {
		  enumerable: true,
		  get: function () {
		    return _index.exportDefaultSpecifier;
		  }
		});
		Object.defineProperty(exports, "ExportNamedDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.exportNamedDeclaration;
		  }
		});
		Object.defineProperty(exports, "ExportNamespaceSpecifier", {
		  enumerable: true,
		  get: function () {
		    return _index.exportNamespaceSpecifier;
		  }
		});
		Object.defineProperty(exports, "ExportSpecifier", {
		  enumerable: true,
		  get: function () {
		    return _index.exportSpecifier;
		  }
		});
		Object.defineProperty(exports, "ExpressionStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.expressionStatement;
		  }
		});
		Object.defineProperty(exports, "File", {
		  enumerable: true,
		  get: function () {
		    return _index.file;
		  }
		});
		Object.defineProperty(exports, "ForInStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.forInStatement;
		  }
		});
		Object.defineProperty(exports, "ForOfStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.forOfStatement;
		  }
		});
		Object.defineProperty(exports, "ForStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.forStatement;
		  }
		});
		Object.defineProperty(exports, "FunctionDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.functionDeclaration;
		  }
		});
		Object.defineProperty(exports, "FunctionExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.functionExpression;
		  }
		});
		Object.defineProperty(exports, "FunctionTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.functionTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "FunctionTypeParam", {
		  enumerable: true,
		  get: function () {
		    return _index.functionTypeParam;
		  }
		});
		Object.defineProperty(exports, "GenericTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.genericTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "Identifier", {
		  enumerable: true,
		  get: function () {
		    return _index.identifier;
		  }
		});
		Object.defineProperty(exports, "IfStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.ifStatement;
		  }
		});
		Object.defineProperty(exports, "Import", {
		  enumerable: true,
		  get: function () {
		    return _index.import;
		  }
		});
		Object.defineProperty(exports, "ImportAttribute", {
		  enumerable: true,
		  get: function () {
		    return _index.importAttribute;
		  }
		});
		Object.defineProperty(exports, "ImportDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.importDeclaration;
		  }
		});
		Object.defineProperty(exports, "ImportDefaultSpecifier", {
		  enumerable: true,
		  get: function () {
		    return _index.importDefaultSpecifier;
		  }
		});
		Object.defineProperty(exports, "ImportExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.importExpression;
		  }
		});
		Object.defineProperty(exports, "ImportNamespaceSpecifier", {
		  enumerable: true,
		  get: function () {
		    return _index.importNamespaceSpecifier;
		  }
		});
		Object.defineProperty(exports, "ImportSpecifier", {
		  enumerable: true,
		  get: function () {
		    return _index.importSpecifier;
		  }
		});
		Object.defineProperty(exports, "IndexedAccessType", {
		  enumerable: true,
		  get: function () {
		    return _index.indexedAccessType;
		  }
		});
		Object.defineProperty(exports, "InferredPredicate", {
		  enumerable: true,
		  get: function () {
		    return _index.inferredPredicate;
		  }
		});
		Object.defineProperty(exports, "InterfaceDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.interfaceDeclaration;
		  }
		});
		Object.defineProperty(exports, "InterfaceExtends", {
		  enumerable: true,
		  get: function () {
		    return _index.interfaceExtends;
		  }
		});
		Object.defineProperty(exports, "InterfaceTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.interfaceTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "InterpreterDirective", {
		  enumerable: true,
		  get: function () {
		    return _index.interpreterDirective;
		  }
		});
		Object.defineProperty(exports, "IntersectionTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.intersectionTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "JSXAttribute", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxAttribute;
		  }
		});
		Object.defineProperty(exports, "JSXClosingElement", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxClosingElement;
		  }
		});
		Object.defineProperty(exports, "JSXClosingFragment", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxClosingFragment;
		  }
		});
		Object.defineProperty(exports, "JSXElement", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxElement;
		  }
		});
		Object.defineProperty(exports, "JSXEmptyExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxEmptyExpression;
		  }
		});
		Object.defineProperty(exports, "JSXExpressionContainer", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxExpressionContainer;
		  }
		});
		Object.defineProperty(exports, "JSXFragment", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxFragment;
		  }
		});
		Object.defineProperty(exports, "JSXIdentifier", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxIdentifier;
		  }
		});
		Object.defineProperty(exports, "JSXMemberExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxMemberExpression;
		  }
		});
		Object.defineProperty(exports, "JSXNamespacedName", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxNamespacedName;
		  }
		});
		Object.defineProperty(exports, "JSXOpeningElement", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxOpeningElement;
		  }
		});
		Object.defineProperty(exports, "JSXOpeningFragment", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxOpeningFragment;
		  }
		});
		Object.defineProperty(exports, "JSXSpreadAttribute", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxSpreadAttribute;
		  }
		});
		Object.defineProperty(exports, "JSXSpreadChild", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxSpreadChild;
		  }
		});
		Object.defineProperty(exports, "JSXText", {
		  enumerable: true,
		  get: function () {
		    return _index.jsxText;
		  }
		});
		Object.defineProperty(exports, "LabeledStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.labeledStatement;
		  }
		});
		Object.defineProperty(exports, "LogicalExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.logicalExpression;
		  }
		});
		Object.defineProperty(exports, "MemberExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.memberExpression;
		  }
		});
		Object.defineProperty(exports, "MetaProperty", {
		  enumerable: true,
		  get: function () {
		    return _index.metaProperty;
		  }
		});
		Object.defineProperty(exports, "MixedTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.mixedTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "ModuleExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.moduleExpression;
		  }
		});
		Object.defineProperty(exports, "NewExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.newExpression;
		  }
		});
		Object.defineProperty(exports, "Noop", {
		  enumerable: true,
		  get: function () {
		    return _index.noop;
		  }
		});
		Object.defineProperty(exports, "NullLiteral", {
		  enumerable: true,
		  get: function () {
		    return _index.nullLiteral;
		  }
		});
		Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.nullLiteralTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "NullableTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.nullableTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "NumberLiteral", {
		  enumerable: true,
		  get: function () {
		    return _index.numberLiteral;
		  }
		});
		Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.numberLiteralTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "NumberTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.numberTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "NumericLiteral", {
		  enumerable: true,
		  get: function () {
		    return _index.numericLiteral;
		  }
		});
		Object.defineProperty(exports, "ObjectExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.objectExpression;
		  }
		});
		Object.defineProperty(exports, "ObjectMethod", {
		  enumerable: true,
		  get: function () {
		    return _index.objectMethod;
		  }
		});
		Object.defineProperty(exports, "ObjectPattern", {
		  enumerable: true,
		  get: function () {
		    return _index.objectPattern;
		  }
		});
		Object.defineProperty(exports, "ObjectProperty", {
		  enumerable: true,
		  get: function () {
		    return _index.objectProperty;
		  }
		});
		Object.defineProperty(exports, "ObjectTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.objectTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "ObjectTypeCallProperty", {
		  enumerable: true,
		  get: function () {
		    return _index.objectTypeCallProperty;
		  }
		});
		Object.defineProperty(exports, "ObjectTypeIndexer", {
		  enumerable: true,
		  get: function () {
		    return _index.objectTypeIndexer;
		  }
		});
		Object.defineProperty(exports, "ObjectTypeInternalSlot", {
		  enumerable: true,
		  get: function () {
		    return _index.objectTypeInternalSlot;
		  }
		});
		Object.defineProperty(exports, "ObjectTypeProperty", {
		  enumerable: true,
		  get: function () {
		    return _index.objectTypeProperty;
		  }
		});
		Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
		  enumerable: true,
		  get: function () {
		    return _index.objectTypeSpreadProperty;
		  }
		});
		Object.defineProperty(exports, "OpaqueType", {
		  enumerable: true,
		  get: function () {
		    return _index.opaqueType;
		  }
		});
		Object.defineProperty(exports, "OptionalCallExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.optionalCallExpression;
		  }
		});
		Object.defineProperty(exports, "OptionalIndexedAccessType", {
		  enumerable: true,
		  get: function () {
		    return _index.optionalIndexedAccessType;
		  }
		});
		Object.defineProperty(exports, "OptionalMemberExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.optionalMemberExpression;
		  }
		});
		Object.defineProperty(exports, "ParenthesizedExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.parenthesizedExpression;
		  }
		});
		Object.defineProperty(exports, "PipelineBareFunction", {
		  enumerable: true,
		  get: function () {
		    return _index.pipelineBareFunction;
		  }
		});
		Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
		  enumerable: true,
		  get: function () {
		    return _index.pipelinePrimaryTopicReference;
		  }
		});
		Object.defineProperty(exports, "PipelineTopicExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.pipelineTopicExpression;
		  }
		});
		Object.defineProperty(exports, "Placeholder", {
		  enumerable: true,
		  get: function () {
		    return _index.placeholder;
		  }
		});
		Object.defineProperty(exports, "PrivateName", {
		  enumerable: true,
		  get: function () {
		    return _index.privateName;
		  }
		});
		Object.defineProperty(exports, "Program", {
		  enumerable: true,
		  get: function () {
		    return _index.program;
		  }
		});
		Object.defineProperty(exports, "QualifiedTypeIdentifier", {
		  enumerable: true,
		  get: function () {
		    return _index.qualifiedTypeIdentifier;
		  }
		});
		Object.defineProperty(exports, "RecordExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.recordExpression;
		  }
		});
		Object.defineProperty(exports, "RegExpLiteral", {
		  enumerable: true,
		  get: function () {
		    return _index.regExpLiteral;
		  }
		});
		Object.defineProperty(exports, "RegexLiteral", {
		  enumerable: true,
		  get: function () {
		    return _index.regexLiteral;
		  }
		});
		Object.defineProperty(exports, "RestElement", {
		  enumerable: true,
		  get: function () {
		    return _index.restElement;
		  }
		});
		Object.defineProperty(exports, "RestProperty", {
		  enumerable: true,
		  get: function () {
		    return _index.restProperty;
		  }
		});
		Object.defineProperty(exports, "ReturnStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.returnStatement;
		  }
		});
		Object.defineProperty(exports, "SequenceExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.sequenceExpression;
		  }
		});
		Object.defineProperty(exports, "SpreadElement", {
		  enumerable: true,
		  get: function () {
		    return _index.spreadElement;
		  }
		});
		Object.defineProperty(exports, "SpreadProperty", {
		  enumerable: true,
		  get: function () {
		    return _index.spreadProperty;
		  }
		});
		Object.defineProperty(exports, "StaticBlock", {
		  enumerable: true,
		  get: function () {
		    return _index.staticBlock;
		  }
		});
		Object.defineProperty(exports, "StringLiteral", {
		  enumerable: true,
		  get: function () {
		    return _index.stringLiteral;
		  }
		});
		Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.stringLiteralTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "StringTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.stringTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "Super", {
		  enumerable: true,
		  get: function () {
		    return _index.super;
		  }
		});
		Object.defineProperty(exports, "SwitchCase", {
		  enumerable: true,
		  get: function () {
		    return _index.switchCase;
		  }
		});
		Object.defineProperty(exports, "SwitchStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.switchStatement;
		  }
		});
		Object.defineProperty(exports, "SymbolTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.symbolTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "TSAnyKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsAnyKeyword;
		  }
		});
		Object.defineProperty(exports, "TSArrayType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsArrayType;
		  }
		});
		Object.defineProperty(exports, "TSAsExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.tsAsExpression;
		  }
		});
		Object.defineProperty(exports, "TSBigIntKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsBigIntKeyword;
		  }
		});
		Object.defineProperty(exports, "TSBooleanKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsBooleanKeyword;
		  }
		});
		Object.defineProperty(exports, "TSCallSignatureDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.tsCallSignatureDeclaration;
		  }
		});
		Object.defineProperty(exports, "TSConditionalType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsConditionalType;
		  }
		});
		Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.tsConstructSignatureDeclaration;
		  }
		});
		Object.defineProperty(exports, "TSConstructorType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsConstructorType;
		  }
		});
		Object.defineProperty(exports, "TSDeclareFunction", {
		  enumerable: true,
		  get: function () {
		    return _index.tsDeclareFunction;
		  }
		});
		Object.defineProperty(exports, "TSDeclareMethod", {
		  enumerable: true,
		  get: function () {
		    return _index.tsDeclareMethod;
		  }
		});
		Object.defineProperty(exports, "TSEnumDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.tsEnumDeclaration;
		  }
		});
		Object.defineProperty(exports, "TSEnumMember", {
		  enumerable: true,
		  get: function () {
		    return _index.tsEnumMember;
		  }
		});
		Object.defineProperty(exports, "TSExportAssignment", {
		  enumerable: true,
		  get: function () {
		    return _index.tsExportAssignment;
		  }
		});
		Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
		  enumerable: true,
		  get: function () {
		    return _index.tsExpressionWithTypeArguments;
		  }
		});
		Object.defineProperty(exports, "TSExternalModuleReference", {
		  enumerable: true,
		  get: function () {
		    return _index.tsExternalModuleReference;
		  }
		});
		Object.defineProperty(exports, "TSFunctionType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsFunctionType;
		  }
		});
		Object.defineProperty(exports, "TSImportEqualsDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.tsImportEqualsDeclaration;
		  }
		});
		Object.defineProperty(exports, "TSImportType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsImportType;
		  }
		});
		Object.defineProperty(exports, "TSIndexSignature", {
		  enumerable: true,
		  get: function () {
		    return _index.tsIndexSignature;
		  }
		});
		Object.defineProperty(exports, "TSIndexedAccessType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsIndexedAccessType;
		  }
		});
		Object.defineProperty(exports, "TSInferType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsInferType;
		  }
		});
		Object.defineProperty(exports, "TSInstantiationExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.tsInstantiationExpression;
		  }
		});
		Object.defineProperty(exports, "TSInterfaceBody", {
		  enumerable: true,
		  get: function () {
		    return _index.tsInterfaceBody;
		  }
		});
		Object.defineProperty(exports, "TSInterfaceDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.tsInterfaceDeclaration;
		  }
		});
		Object.defineProperty(exports, "TSIntersectionType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsIntersectionType;
		  }
		});
		Object.defineProperty(exports, "TSIntrinsicKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsIntrinsicKeyword;
		  }
		});
		Object.defineProperty(exports, "TSLiteralType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsLiteralType;
		  }
		});
		Object.defineProperty(exports, "TSMappedType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsMappedType;
		  }
		});
		Object.defineProperty(exports, "TSMethodSignature", {
		  enumerable: true,
		  get: function () {
		    return _index.tsMethodSignature;
		  }
		});
		Object.defineProperty(exports, "TSModuleBlock", {
		  enumerable: true,
		  get: function () {
		    return _index.tsModuleBlock;
		  }
		});
		Object.defineProperty(exports, "TSModuleDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.tsModuleDeclaration;
		  }
		});
		Object.defineProperty(exports, "TSNamedTupleMember", {
		  enumerable: true,
		  get: function () {
		    return _index.tsNamedTupleMember;
		  }
		});
		Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.tsNamespaceExportDeclaration;
		  }
		});
		Object.defineProperty(exports, "TSNeverKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsNeverKeyword;
		  }
		});
		Object.defineProperty(exports, "TSNonNullExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.tsNonNullExpression;
		  }
		});
		Object.defineProperty(exports, "TSNullKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsNullKeyword;
		  }
		});
		Object.defineProperty(exports, "TSNumberKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsNumberKeyword;
		  }
		});
		Object.defineProperty(exports, "TSObjectKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsObjectKeyword;
		  }
		});
		Object.defineProperty(exports, "TSOptionalType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsOptionalType;
		  }
		});
		Object.defineProperty(exports, "TSParameterProperty", {
		  enumerable: true,
		  get: function () {
		    return _index.tsParameterProperty;
		  }
		});
		Object.defineProperty(exports, "TSParenthesizedType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsParenthesizedType;
		  }
		});
		Object.defineProperty(exports, "TSPropertySignature", {
		  enumerable: true,
		  get: function () {
		    return _index.tsPropertySignature;
		  }
		});
		Object.defineProperty(exports, "TSQualifiedName", {
		  enumerable: true,
		  get: function () {
		    return _index.tsQualifiedName;
		  }
		});
		Object.defineProperty(exports, "TSRestType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsRestType;
		  }
		});
		Object.defineProperty(exports, "TSSatisfiesExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.tsSatisfiesExpression;
		  }
		});
		Object.defineProperty(exports, "TSStringKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsStringKeyword;
		  }
		});
		Object.defineProperty(exports, "TSSymbolKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsSymbolKeyword;
		  }
		});
		Object.defineProperty(exports, "TSThisType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsThisType;
		  }
		});
		Object.defineProperty(exports, "TSTupleType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsTupleType;
		  }
		});
		Object.defineProperty(exports, "TSTypeAliasDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.tsTypeAliasDeclaration;
		  }
		});
		Object.defineProperty(exports, "TSTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.tsTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "TSTypeAssertion", {
		  enumerable: true,
		  get: function () {
		    return _index.tsTypeAssertion;
		  }
		});
		Object.defineProperty(exports, "TSTypeLiteral", {
		  enumerable: true,
		  get: function () {
		    return _index.tsTypeLiteral;
		  }
		});
		Object.defineProperty(exports, "TSTypeOperator", {
		  enumerable: true,
		  get: function () {
		    return _index.tsTypeOperator;
		  }
		});
		Object.defineProperty(exports, "TSTypeParameter", {
		  enumerable: true,
		  get: function () {
		    return _index.tsTypeParameter;
		  }
		});
		Object.defineProperty(exports, "TSTypeParameterDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.tsTypeParameterDeclaration;
		  }
		});
		Object.defineProperty(exports, "TSTypeParameterInstantiation", {
		  enumerable: true,
		  get: function () {
		    return _index.tsTypeParameterInstantiation;
		  }
		});
		Object.defineProperty(exports, "TSTypePredicate", {
		  enumerable: true,
		  get: function () {
		    return _index.tsTypePredicate;
		  }
		});
		Object.defineProperty(exports, "TSTypeQuery", {
		  enumerable: true,
		  get: function () {
		    return _index.tsTypeQuery;
		  }
		});
		Object.defineProperty(exports, "TSTypeReference", {
		  enumerable: true,
		  get: function () {
		    return _index.tsTypeReference;
		  }
		});
		Object.defineProperty(exports, "TSUndefinedKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsUndefinedKeyword;
		  }
		});
		Object.defineProperty(exports, "TSUnionType", {
		  enumerable: true,
		  get: function () {
		    return _index.tsUnionType;
		  }
		});
		Object.defineProperty(exports, "TSUnknownKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsUnknownKeyword;
		  }
		});
		Object.defineProperty(exports, "TSVoidKeyword", {
		  enumerable: true,
		  get: function () {
		    return _index.tsVoidKeyword;
		  }
		});
		Object.defineProperty(exports, "TaggedTemplateExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.taggedTemplateExpression;
		  }
		});
		Object.defineProperty(exports, "TemplateElement", {
		  enumerable: true,
		  get: function () {
		    return _index.templateElement;
		  }
		});
		Object.defineProperty(exports, "TemplateLiteral", {
		  enumerable: true,
		  get: function () {
		    return _index.templateLiteral;
		  }
		});
		Object.defineProperty(exports, "ThisExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.thisExpression;
		  }
		});
		Object.defineProperty(exports, "ThisTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.thisTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "ThrowStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.throwStatement;
		  }
		});
		Object.defineProperty(exports, "TopicReference", {
		  enumerable: true,
		  get: function () {
		    return _index.topicReference;
		  }
		});
		Object.defineProperty(exports, "TryStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.tryStatement;
		  }
		});
		Object.defineProperty(exports, "TupleExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.tupleExpression;
		  }
		});
		Object.defineProperty(exports, "TupleTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.tupleTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "TypeAlias", {
		  enumerable: true,
		  get: function () {
		    return _index.typeAlias;
		  }
		});
		Object.defineProperty(exports, "TypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.typeAnnotation;
		  }
		});
		Object.defineProperty(exports, "TypeCastExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.typeCastExpression;
		  }
		});
		Object.defineProperty(exports, "TypeParameter", {
		  enumerable: true,
		  get: function () {
		    return _index.typeParameter;
		  }
		});
		Object.defineProperty(exports, "TypeParameterDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.typeParameterDeclaration;
		  }
		});
		Object.defineProperty(exports, "TypeParameterInstantiation", {
		  enumerable: true,
		  get: function () {
		    return _index.typeParameterInstantiation;
		  }
		});
		Object.defineProperty(exports, "TypeofTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.typeofTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "UnaryExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.unaryExpression;
		  }
		});
		Object.defineProperty(exports, "UnionTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.unionTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "UpdateExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.updateExpression;
		  }
		});
		Object.defineProperty(exports, "V8IntrinsicIdentifier", {
		  enumerable: true,
		  get: function () {
		    return _index.v8IntrinsicIdentifier;
		  }
		});
		Object.defineProperty(exports, "VariableDeclaration", {
		  enumerable: true,
		  get: function () {
		    return _index.variableDeclaration;
		  }
		});
		Object.defineProperty(exports, "VariableDeclarator", {
		  enumerable: true,
		  get: function () {
		    return _index.variableDeclarator;
		  }
		});
		Object.defineProperty(exports, "Variance", {
		  enumerable: true,
		  get: function () {
		    return _index.variance;
		  }
		});
		Object.defineProperty(exports, "VoidTypeAnnotation", {
		  enumerable: true,
		  get: function () {
		    return _index.voidTypeAnnotation;
		  }
		});
		Object.defineProperty(exports, "WhileStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.whileStatement;
		  }
		});
		Object.defineProperty(exports, "WithStatement", {
		  enumerable: true,
		  get: function () {
		    return _index.withStatement;
		  }
		});
		Object.defineProperty(exports, "YieldExpression", {
		  enumerable: true,
		  get: function () {
		    return _index.yieldExpression;
		  }
		});
		var _index = requireGenerated$2();

		
} (uppercase));
	return uppercase;
}

var productions = {};

var hasRequiredProductions;

function requireProductions () {
	if (hasRequiredProductions) return productions;
	hasRequiredProductions = 1;

	Object.defineProperty(productions, "__esModule", {
	  value: true
	});
	productions.buildUndefinedNode = buildUndefinedNode;
	var _index = requireGenerated$2();
	function buildUndefinedNode() {
	  return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
	}

	
	return productions;
}

var cloneNode = {};

var hasRequiredCloneNode;

function requireCloneNode () {
	if (hasRequiredCloneNode) return cloneNode;
	hasRequiredCloneNode = 1;

	Object.defineProperty(cloneNode, "__esModule", {
	  value: true
	});
	cloneNode.default = cloneNode$1;
	var _index = requireDefinitions();
	var _index2 = requireGenerated$3();
	const {
	  hasOwn
	} = {
	  hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
	};
	function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
	  if (obj && typeof obj.type === "string") {
	    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
	  }
	  return obj;
	}
	function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
	  if (Array.isArray(obj)) {
	    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));
	  }
	  return cloneIfNode(obj, deep, withoutLoc, commentsCache);
	}
	function cloneNode$1(node, deep = true, withoutLoc = false) {
	  return cloneNodeInternal(node, deep, withoutLoc, new Map());
	}
	function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
	  if (!node) return node;
	  const {
	    type
	  } = node;
	  const newNode = {
	    type: node.type
	  };
	  if ((0, _index2.isIdentifier)(node)) {
	    newNode.name = node.name;
	    if (hasOwn(node, "optional") && typeof node.optional === "boolean") {
	      newNode.optional = node.optional;
	    }
	    if (hasOwn(node, "typeAnnotation")) {
	      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
	    }
	    if (hasOwn(node, "decorators")) {
	      newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;
	    }
	  } else if (!hasOwn(_index.NODE_FIELDS, type)) {
	    throw new Error(`Unknown node type: "${type}"`);
	  } else {
	    for (const field of Object.keys(_index.NODE_FIELDS[type])) {
	      if (hasOwn(node, field)) {
	        if (deep) {
	          newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
	        } else {
	          newNode[field] = node[field];
	        }
	      }
	    }
	  }
	  if (hasOwn(node, "loc")) {
	    if (withoutLoc) {
	      newNode.loc = null;
	    } else {
	      newNode.loc = node.loc;
	    }
	  }
	  if (hasOwn(node, "leadingComments")) {
	    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
	  }
	  if (hasOwn(node, "innerComments")) {
	    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
	  }
	  if (hasOwn(node, "trailingComments")) {
	    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
	  }
	  if (hasOwn(node, "extra")) {
	    newNode.extra = Object.assign({}, node.extra);
	  }
	  return newNode;
	}
	function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
	  if (!comments || !deep) {
	    return comments;
	  }
	  return comments.map(comment => {
	    const cache = commentsCache.get(comment);
	    if (cache) return cache;
	    const {
	      type,
	      value,
	      loc
	    } = comment;
	    const ret = {
	      type,
	      value,
	      loc
	    };
	    if (withoutLoc) {
	      ret.loc = null;
	    }
	    commentsCache.set(comment, ret);
	    return ret;
	  });
	}

	
	return cloneNode;
}

var clone = {};

var hasRequiredClone;

function requireClone () {
	if (hasRequiredClone) return clone;
	hasRequiredClone = 1;

	Object.defineProperty(clone, "__esModule", {
	  value: true
	});
	clone.default = clone$1;
	var _cloneNode = requireCloneNode();
	function clone$1(node) {
	  return (0, _cloneNode.default)(node, false);
	}

	
	return clone;
}

var cloneDeep = {};

var hasRequiredCloneDeep;

function requireCloneDeep () {
	if (hasRequiredCloneDeep) return cloneDeep;
	hasRequiredCloneDeep = 1;

	Object.defineProperty(cloneDeep, "__esModule", {
	  value: true
	});
	cloneDeep.default = cloneDeep$1;
	var _cloneNode = requireCloneNode();
	function cloneDeep$1(node) {
	  return (0, _cloneNode.default)(node);
	}

	
	return cloneDeep;
}

var cloneDeepWithoutLoc = {};

var hasRequiredCloneDeepWithoutLoc;

function requireCloneDeepWithoutLoc () {
	if (hasRequiredCloneDeepWithoutLoc) return cloneDeepWithoutLoc;
	hasRequiredCloneDeepWithoutLoc = 1;

	Object.defineProperty(cloneDeepWithoutLoc, "__esModule", {
	  value: true
	});
	cloneDeepWithoutLoc.default = cloneDeepWithoutLoc$1;
	var _cloneNode = requireCloneNode();
	function cloneDeepWithoutLoc$1(node) {
	  return (0, _cloneNode.default)(node, true, true);
	}

	
	return cloneDeepWithoutLoc;
}

var cloneWithoutLoc = {};

var hasRequiredCloneWithoutLoc;

function requireCloneWithoutLoc () {
	if (hasRequiredCloneWithoutLoc) return cloneWithoutLoc;
	hasRequiredCloneWithoutLoc = 1;

	Object.defineProperty(cloneWithoutLoc, "__esModule", {
	  value: true
	});
	cloneWithoutLoc.default = cloneWithoutLoc$1;
	var _cloneNode = requireCloneNode();
	function cloneWithoutLoc$1(node) {
	  return (0, _cloneNode.default)(node, false, true);
	}

	
	return cloneWithoutLoc;
}

var addComment = {};

var addComments = {};

var hasRequiredAddComments;

function requireAddComments () {
	if (hasRequiredAddComments) return addComments;
	hasRequiredAddComments = 1;

	Object.defineProperty(addComments, "__esModule", {
	  value: true
	});
	addComments.default = addComments$1;
	function addComments$1(node, type, comments) {
	  if (!comments || !node) return node;
	  const key = `${type}Comments`;
	  if (node[key]) {
	    if (type === "leading") {
	      node[key] = comments.concat(node[key]);
	    } else {
	      node[key].push(...comments);
	    }
	  } else {
	    node[key] = comments;
	  }
	  return node;
	}

	
	return addComments;
}

var hasRequiredAddComment;

function requireAddComment () {
	if (hasRequiredAddComment) return addComment;
	hasRequiredAddComment = 1;

	Object.defineProperty(addComment, "__esModule", {
	  value: true
	});
	addComment.default = addComment$1;
	var _addComments = requireAddComments();
	function addComment$1(node, type, content, line) {
	  return (0, _addComments.default)(node, type, [{
	    type: line ? "CommentLine" : "CommentBlock",
	    value: content
	  }]);
	}

	
	return addComment;
}

var inheritInnerComments = {};

var inherit = {};

var hasRequiredInherit;

function requireInherit () {
	if (hasRequiredInherit) return inherit;
	hasRequiredInherit = 1;

	Object.defineProperty(inherit, "__esModule", {
	  value: true
	});
	inherit.default = inherit$1;
	function inherit$1(key, child, parent) {
	  if (child && parent) {
	    child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
	  }
	}

	
	return inherit;
}

var hasRequiredInheritInnerComments;

function requireInheritInnerComments () {
	if (hasRequiredInheritInnerComments) return inheritInnerComments;
	hasRequiredInheritInnerComments = 1;

	Object.defineProperty(inheritInnerComments, "__esModule", {
	  value: true
	});
	inheritInnerComments.default = inheritInnerComments$1;
	var _inherit = requireInherit();
	function inheritInnerComments$1(child, parent) {
	  (0, _inherit.default)("innerComments", child, parent);
	}

	
	return inheritInnerComments;
}

var inheritLeadingComments = {};

var hasRequiredInheritLeadingComments;

function requireInheritLeadingComments () {
	if (hasRequiredInheritLeadingComments) return inheritLeadingComments;
	hasRequiredInheritLeadingComments = 1;

	Object.defineProperty(inheritLeadingComments, "__esModule", {
	  value: true
	});
	inheritLeadingComments.default = inheritLeadingComments$1;
	var _inherit = requireInherit();
	function inheritLeadingComments$1(child, parent) {
	  (0, _inherit.default)("leadingComments", child, parent);
	}

	
	return inheritLeadingComment